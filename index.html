<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>DIVING CENTER – Fiche Plongée (GENERIC) v2</title>


 <!-- PWA / Manifest -->
<link rel="manifest" href="manifest_divinglog.json">

<!-- Icons -->
<link rel="icon" type="image/png" sizes="192x192" href="OCEAN_INFINITY_exact_192.png">
<link rel="icon" type="image/png" sizes="512x512" href="OCEAN_INFINITY_exact_512.png">

<!-- iOS support -->
<link rel="apple-touch-icon" href="OCEAN_INFINITY_exact_192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="OCEAN INFINITY">

<!-- Theme -->
<meta name="theme-color" content="#0B5F73">

<!-- Meta -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <style>
    /* ===========================
       THEME CCR DIVING / SEA ANGEL
       =========================== */
    :root {
      --bg-main: #050b16;
      --bg-card: #0b1527;
      --bg-card-soft: #101d33;
      --border-soft: #223b5c;
      --text-main: #e4ecfb;
      --text-muted: #9fb4d7;
      --accent-cyan: #00a8ff;
      --accent-green: #39ff88;
      --accent-red: #ff6b6b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 20px 12px 40px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(circle at top, #101b33 0, #050b16 55%, #02040a 100%);
      color: var(--text-main);
      font-size: 18px;
    }

    /* ===========================
       MOBILE STABILITY PATCH (iOS/Android/Tablette)
       - dynamic viewport (Safari toolbar)
       - safe-area
       - predictable scroll + touch
       =========================== */
    html, body { height: 100%; }
    body {
      min-height: 100dvh; /* iOS Safari dynamic viewport */
      padding-bottom: calc(40px + env(safe-area-inset-bottom));
      -webkit-text-size-adjust: 100%;
      overscroll-behavior-y: none;
    }

    /* ===========================
       FULLSCREEN FIX (iPhone/PWA) – anti "blanc sur les côtés"
       =========================== */
    html{
      background: var(--bg-main);
      width: 100%;
      overflow-x: hidden;
    }

    body{
      width: 100%;
      overflow-x: hidden;

      /* safe-area horizontale (évite les bandes/offset bizarres en PWA) */
      padding-left: calc(12px + env(safe-area-inset-left));
      padding-right: calc(12px + env(safe-area-inset-right));
    }

    /* garantit que le wrapper ne peut jamais dépasser l'écran */
    .container{
      width: 100%;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Prefer dynamic viewport height when available (avoid 55vh jumping on iOS) */
    @supports (height: 100dvh) {
      .plongeurs-jour-container { max-height: 55dvh; }
    }

    /* Ensure one clear vertical scroll owner where needed */
    .plongeurs-jour-container { touch-action: pan-y; }

    /* Horizontal scroll areas: allow pan-x without stealing vertical scroll */
    .palier-hscroll,
    .hscroll,
    .table-scroll { touch-action: pan-x; }

    /* Improve tap reliability on mobile */
    button, .btn, input, select, textarea { touch-action: manipulation; }



    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .section {
      margin-bottom: 18px;
      padding: 14px 16px 16px;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-soft);
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.45);
    }

    .section-title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--accent-cyan);
      margin-bottom: 14px;
    }

    .section-title::before {
      content: "✦ ";
      color: var(--accent-green);
    }

    label {
      display: block;
      font-size: 15px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .field {
      margin-bottom: 10px;
    }

    input[type="text"],
    input[type="number"],
    input[type="time"],
    textarea,
    select {
      width: 100%;
      padding: 14px 16px;
      border-radius: 10px;
      border: 1px solid #2a4570;
      background: #0b172c;
      color: var(--text-main);
      font-size: 20px;
      outline: none;
      transition:
        border-color 0.15s ease,
        box-shadow 0.15s ease,
        background 0.15s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="time"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 0 1px rgba(0, 168, 255, 0.3);
      background: #0e1d35;
    }

    textarea {
      resize: vertical;
      min-height: 72px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    @media (max-width: 700px) {
      .row {
        flex-direction: column;
      }
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      background: #13274a;
      color: var(--text-main);
      transition:
        background 0.15s ease,
        transform 0.05s ease,
        box-shadow 0.15s ease,
        border-color 0.15s ease,
        color 0.15s ease;
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0, 0, 0, 0);
    }

    /* Small buttons (used for +5/+10/+15/+20 scenarios) */
    .btn.small{
      padding: 10px 16px;
      font-size: 16px;
      min-width: 72px;
    }

    .btn-primary {
      background: linear-gradient(130deg, #10b981, #39ff88);
      color: #061110;
      border-color: rgba(0, 0, 0, 0.5);
      box-shadow: 0 0 14px rgba(57, 255, 136, 0.35);
    }

    .btn-primary:hover {
      background: linear-gradient(130deg, #0da26f, #2fff7c);
    }

  

    .btn-reset {
      background: #150c1b;
      border-color: rgba(255, 107, 107, 0.65);
      color: #ffb3b3;
      font-size: 12px;
    }

    .btn-reset:hover {
      background: #2a101f;
    }

    .export-options {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 14px;
      font-size: 15px;
    }

    .export-options label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 0;
      color: var(--text-main);
    }

    .export-options input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent-green);
      cursor: pointer;
    }

    .footer-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
      margin-top: 8px;
    }

    .footer-actions .btn-primary {
      flex: 1;
      min-width: 160px;
      justify-content: center;
    }

    .footer-actions .btn-reset {
      padding-inline: 18px;
    }

    @media (max-width: 700px) {
      .footer-actions {
        flex-direction: column;
      }

      .footer-actions .btn-primary,
      .footer-actions .btn-reset {
        width: 100%;
        justify-content: center;
      }
    }

    /* ===========================
       PLONGEURS DU JOUR - CARTES
       =========================== */
    .plongeurs-jour-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    
     /* NEW: scroll si 250 plongeurs */
      max-height: 55vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;

     /* optionnel: évite que la scrollbar masque le contenu */
      padding-right: 4px;
    }


    .diver-card {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 8px;
      background: var(--bg-card-soft);
      border: 1px solid var(--border-soft);
    
      position: relative;
    }

    .diver-card input[type="checkbox"] {
      margin-top: 4px;
    }

    .diver-card-main {
      flex: 1;
      min-width: 0; /* critical: allow children to overflow/scroll horizontally inside flex layouts */
    }

    /* AFTER: horizontal scroll wrapper for large stop tables (prevents layout overflow) */
    .palier-hscroll{
      width: 100%;
      max-width: 100%;
      min-width: 0;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
    }

    /* AFTER: realised fields row (Runtime / Sortie / Profondeur) — horizontal scroll like the palier table */
    .after-real-row{
      width: 100%;
      max-width: 100%;
      min-width: 0;
      display: flex;
      flex-wrap: nowrap;
      gap: 10px;
      align-items: center;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .after-real-row > div{
      flex: 0 0 auto; /* prevent shrink into unreadable vertical stacks */
      min-width: max-content;
    }


    /* Keep the row label visible while scrolling horizontally */
    .after-stops-table th:first-child,
    .after-stops-table td:first-child{
      position: sticky;
      left: 0;
      z-index: 2;
      background: var(--bg-card-soft);
    }

    .diver-card-name {
      font-weight: 600;
      color: var(--text-main);
      font-size: 14px;
    }

    .diver-card-cert {
      font-size: 13px;
      color: var(--text-muted);
    }

    .plongeurs-jour-status {
      font-size: 13px;
      color: var(--text-muted);
    }

    /* ===========================
       GROUPES & AFFECTATION
       =========================== */
    .group-row {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 8px;
    }

       .group-column {
      /* 3 cartes par ligne sur grands écrans */
      flex: 1 1 calc(33.333% - 10px);
      min-width: 220px;

      /* Carte encapsulée */
      background: rgba(0, 0, 0, 0.35);
      border-radius:-radius: 12px;
      border: 1px solid var(--border-soft);
      padding: 10px 10px 8px;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.35);

      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .group-column-full {
      flex: 1 1 100%;
    }

    .add-group-container {
      margin-top: 8px;
      margin-bottom: 8px;
      text-align: right;
    }
      .group-header {
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text-main);
      font-size: 15px;

      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .group-header-left{
      display: inline-flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      min-width: 180px;
    }

    .group-header-title{
      display:inline-block;
    }

    .group-header-controls{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .group-header-controls select{
      min-height: 30px;
      padding: 4px 8px;
      font-size: 12.5px;
      border-radius: 10px;
    }

    .group-header-controls button{
      min-height: 30px;
      padding: 4px 8px;
      font-size: 12.5px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color: var(--text-main);
    }

    .group-details-toggle{
      cursor: pointer;
      user-select: none;
      opacity: 0.9;
    }

    .group-details-toggle:hover{
      opacity: 1;
      text-decoration: underline;
    }


    /* Delete button inside group header */
    .group-delete-btn {
      margin-left: auto;
      font-size: 13px;
      color: #ff6666;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,0,0,0.12);
    }

    .group-delete-btn:hover {
      background: rgba(255,0,0,0.25);
    }

    /* Group actions under header (prevents delete button sharing header row) */
    .group-actions {
      margin-top: 6px;
    }
    .group-actions .group-delete-btn {
      display: block;
      width: 100%;
      margin-left: 0;
      text-align: center;
      padding: 6px 10px;
    }

    /* Group type / supervisor badges in header */
    .group-header .group-badges{
      display:inline-flex;
      align-items:center;
      gap:8px;
      margin-left:10px;
      flex-wrap:wrap;
    }
    .group-type-badge{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.2px;
      border: 1px solid rgba(255,255,255,0.14);
    }
    .group-type-AUTONOME{ background: rgba(30,136,229,0.22); color:#d7ecff; }
    .group-type-ENCADREE{ background: rgba(251,140,0,0.22); color:#ffe8c5; }
    .group-type-FORMATION{ background: rgba(67,160,71,0.22); color:#dfffe1; }
    .group-role-badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      max-width: 52vw;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }


   

    .group-buttons {
      display: flex;
      flex-direction: row;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: nowrap;
    }

    .group-buttons .btn {
      flex: 1 1 0;
      justify-content: center;
      text-align: center;
    }

    .group-buttons {
      display: flex;
      flex-direction: row;   /* Avant / Après on the same line */
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: nowrap;
    }

    .group-buttons .btn {
      flex: 1 1 0;           /* same width for both */
      justify-content: center;
      text-align: center;
    }

    .group-diver-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
/* Mobile: PDJ tools et listes de plongeurs (stabilité iPhone/Android)
   - pas de scroll horizontal pour la liste des plongeurs d'un groupe (trop "perdu" sur petit écran)
   - on garde une liste verticale lisible
*/
@media (max-width: 700px) {
  /* Outils PDJ: chips sur 2 lignes, filtre aptitude en pleine largeur */
  #pdj_tools .pdj-row {
    align-items: stretch;
  }
  #pdj_tools .pdj-select {
    width: 100%;
  }

  /* Listes des plongeurs par groupe: vertical (pas de nowrap horizontal) */
  div[id^="group-G"][id$="-list"].group-diver-list {
    flex-direction: column;
    flex-wrap: nowrap;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  div[id^="group-G"][id$="-list"].group-diver-list .group-diver-card {
    width: max-content;
    min-width: 100%;
  }

  div[id^="group-G"][id$="-list"].group-diver-list .group-diver-name {
    white-space: nowrap;
  }
}
}

    .group-diver-card {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      border-radius: 8px;
      background: var(--bg-card-soft);
      border: 1px solid var(--border-soft);
      font-size: 13px;
      cursor: grab;
    }

    .group-diver-name {
      font-weight: 500;
    }

    .group-diver-list.drop-target-over {
      border: 1px dashed var(--accent-cyan);
      background: rgba(0, 168, 255, 0.08);
    }

    .group-field-locked {
      opacity: 0.6;
    }


    .group-mini-btn {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--border-soft);
      background: rgba(255, 255, 255, 0.04);
    }

    /* FORCE: 1 groupe par ligne (colonne verticale) */
    #group-main-row {
      flex-direction: column;
      flex-wrap: nowrap;
    }

    #group-main-row .group-column {
      flex: 1 1 100%;
      min-width: 0;
    }

    /* ===========================
       MENU SÉLECTION GROUPE (OVERLAY)
       =========================== */
    .group-select-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .group-select-dialog {
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-soft);
      padding: 14px 16px;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.6);
    }

    .group-select-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-main);
    }

    .group-select-sub {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .group-select-buttons {
      max-height: 260px;
      overflow-y: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }

    .group-select-buttons .btn {
      flex: 1 1 45%;
      justify-content: center;
      font-size: 14px;
      padding: 6px 10px;
    }

    .group-select-footer {
      text-align: right;
    }

    .group-select-cancel {
      font-size: 13px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .group-select-cancel:hover {
      text-decoration: underline;
    }
    /* ===========================
       MENU SÉLECTION GROUPE (OVERLAY)
       =========================== */
    .group-select-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .group-select-dialog {
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-soft);
      padding: 14px 16px;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 0 18px rgba(0, 0, 0, 0.6);
    }

    .group-select-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-main);
    }

    .group-select-sub {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .group-select-buttons {
      max-height: 260px; /* <= hybrid: no scroll when few groups, scroll when many */
      overflow-y: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }

    .group-select-buttons .btn {
      flex: 1 1 45%;
      justify-content: center;
      font-size: 14px;
      padding: 6px 10px;
    }

    .group-select-footer {
      text-align: right;
    }

    .group-select-cancel {
      font-size: 13px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .group-select-cancel:hover {
      text-decoration: underline;
    }

    /* ===========================
       PREVIEW PDF A4
       =========================== */
    #pdf-preview {
      margin-top: 14px;
    }

    .pdf-page {
      background: #ffffff;
      color: #000000;
      width: 210mm;
      min-height: 297mm;
      margin: 0 auto 18px;
      padding: 20mm 18mm;
      box-sizing: border-box;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
      font-family: "Times New Roman", "Georgia", serif;
      font-size: 12pt;
    }

    .pdf-title {
      font-size: 16pt;
      font-weight: 700;
      text-align: center;
      margin-bottom: 10pt;
      text-transform: none;
    }

    .pdf-section-title {
      font-size: 12pt;
      font-weight: 700;
      margin-top: 8pt;
      margin-bottom: 4pt;
    }

    .pdf-text {
      font-size: 12pt;
      line-height: 1.3;
      margin: 0 0 4pt 0;
    }

    .pdf-muted {
      color: #555555;
    }

    .pdf-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 4pt;
      font-size: 11pt;
    }

    .pdf-table th,
    .pdf-table td {
      border: 1px solid #cccccc;
      padding: 3pt 4pt;
      text-align: left;
    }

    .pdf-table th {
      background: #f3f3f3;
      font-weight: 600;
    }

    .pdf-small {
      font-size: 10pt;
    }

 
  
    .btn-secondary {
      border-color: rgba(120, 120, 120, 0.5);
      background: radial-gradient(circle at top left, #1a1f2b, #0a0f1a);
      color: #e6e6e6;
    }


    .add-diver-form {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px;
      background: rgba(0,0,0,0.20);
    }

    .diver-card-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 54px;
      height: 22px;
      padding: 0 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      font-size: 11px;
      color: #ffffff;
      margin-left: 10px;
      white-space: nowrap;
    }

    /* Mini status boxes inside "Plongeurs du jour" diver rows */
    .diver-mini-status {
      display: flex;
      gap: 8px;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    .mini-box {
      display: inline-flex;
      align-items: center;
      height: 22px;
      padding: 0 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-size: 11px;
      color: #eaf2ff;
      white-space: nowrap;
    }

    .mini-palier.is-empty {
      border-color: rgba(255, 70, 70, 0.85);
      background: rgba(255, 70, 70, 0.12);
      color: #ffd6d6;
    }

    .mini-palier.is-ok {
      border-color: rgba(80, 210, 140, 0.85);
      background: rgba(80, 210, 140, 0.12);
      color: #d6ffe9;
    }

    /* Plongeurs du jour: 3 columns inside the diver card */
    .diver-card-grid {
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      align-items: center;
      gap: 8px;
    }

    
    .boat-wrap{
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .mini-boat{
      font-weight:700;
      letter-spacing:0.2px;
    }
    .mini-boat.is-empty{
      opacity:0.75;
    }
    .boat-select{
      height: 22px;
      padding: 0 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: #eaf2ff;
      font-size: 11px;
      outline: none;
    }
.diver-card-grid .diver-card-name {
      margin: 0;
      font-size: 14px;
    }

    .diver-card-grid .mini-box {
      margin: 0;
    }

    .diver-card-cert {
      margin-top: 4px;
    }

    /* Palier modal (minimal) */
    .palier-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.70);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 99999;
    }
    .palier-modal-dialog {
      width: min(520px, 92vw);
      background: var(--bg-card);
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 0 18px rgba(0,0,0,0.65);
    }
    .palier-modal-title {
      font-size: 15px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text-main);
    }
    .palier-quick {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .palier-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 10px;
      max-height: 45vh;
      overflow: auto;
      padding-right: 4px;
    }
    .palier-row {
      display: grid;
      grid-template-columns: 70px 1fr 34px;
      gap: 8px;
      align-items: center;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px;
      padding: 6px 8px;
    }
    .palier-row .pal-depth {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
    }
    .palier-row input[type="number"]{
      font-size: 14px;
      padding: 6px 8px;
      border-radius: 8px;
    }
    .palier-del {
      cursor: pointer;
      text-align: center;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,0,0,0.12);
      color: #ffb3b3;
      padding: 4px 0;
      font-size: 12px;
    }
    .palier-modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
/* =========================================
   PATCH UI — tailles homogènes plongeurs
   Nom / Certification / Aptitude / Paliers
   ========================================= */

    :root{
      --fs-diver-name: 18px;
      --fs-diver-sub:  16px;   /* cert */
      --fs-diver-badge:15px;   /* aptitude / paliers */
    }

    /* PLONGEURS DU JOUR */
    .diver-card-name{
      font-size: var(--fs-diver-name) !important;
      font-weight: 700;
      line-height: 1.35;
    }

    .diver-card-cert{
      font-size: var(--fs-diver-sub) !important;
      line-height: 1.25;
    }

    /* Badges (APTITUDE / PALIERS) */
    .mini-box{
      font-size: var(--fs-diver-badge) !important;
      height: auto;            /* évite le “coupé” quand on augmente la police */
      min-height: 24px;
      padding: 4px 10px;
      line-height: 1.2;
    }

     /* GROUPES (cartes plongeurs dans dispo + dans chaque groupe) */
     .group-diver-card{
       font-size: var(--fs-diver-name) !important; /* base lisible */
    }

     .group-diver-name{
      font-size: var(--fs-diver-name) !important;
      font-weight: 700;
      line-height: 1.35;
    }

     /* Comme tu réutilises .diver-card-cert dans les cartes de groupe, ça suit déjà.
        On garde un petit spacing propre. */
     .group-diver-card .diver-card-cert{
      margin-top: 6px;
    }

  
    /* AFTER plongée: tableau horizontal des paliers (par plongeur) */
    .after-stops-table{
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;
    }
    .after-stops-table th,
    .after-stops-table td{
      padding: 6px 8px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.10);
      white-space: nowrap;
    }
    .after-stops-table th:first-child,
    .after-stops-table td:first-child{
      text-align: left;
      min-width: 110px;
      font-weight: 600;
    }
    .after-stops-table input[type="number"]{
      width: 64px;
      max-width: 64px;
      text-align: center;
    }

/* =========================================================
   AFTER plongée — UI DP/Sécu : Réalisé + Action + Paliers
   (CSS only, no logic change)
   Scope: #group_after_divers_container
   ========================================================= */


/* v1.001 — Incidents (par plongeur) : bouton discret + mini-panel */
.incident-btn{
  padding: 8px 10px;
  font-size: 14px;
  line-height: 1;
  border-radius: 10px;
  background: rgba(255, 204, 102, 0.10);
  border: 1px solid rgba(255, 204, 102, 0.55);
  color: #ffe7b0;
  white-space: nowrap;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.20) inset;
}
.incident-btn:hover{
  background: rgba(255, 204, 102, 0.14);
  border-color: rgba(255, 204, 102, 0.70);
}
.incident-btn[data-has="1"]{
  background: rgba(255, 204, 102, 0.22);
  border-color: rgba(255, 204, 102, 0.90);
  color: #fff0c9;
  box-shadow: 0 0 0 1px rgba(255, 204, 102, 0.25) inset, 0 0 14px rgba(255, 204, 102, 0.18);
}
.incident-panel{
  margin-top: 8px;
  padding: 10px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.04);
  display: none; /* toggled in JS */
  position: relative;
}

/* Layout: 2 colonnes alignées (4 + 4) */
.incident-panel .inc-grid{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 12px;
  margin-top: 6px;
}
.incident-panel .inc-col{
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.incident-panel .inc-col .inc-tag{
  width: 100%;
}
.incident-panel .inc-close{
  position: absolute;
  top: 6px;
  right: 8px;
  width: 28px;
  height: 28px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.22);
  color: var(--text-main);
  font-weight: 900;
  line-height: 1;
  cursor: pointer;
}



/* v1.001 — Scroll interne “Plongeurs du groupe – données réelles”
   (ne change pas la structure des cartes) */
#group_after_divers_container{
  max-height: 62vh;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  padding-right: 4px; /* évite que la scrollbar masque les inputs */
}

/* v1.001 — Confort “plein soleil” : profondeur réalisée en gris minéral */
#group_after_divers_container input[id^="after_depth__"]{
  background: #0b172c;
  border-color: #2a4570;
  color: var(--text-main);
}


#group_after_divers_container .diver-card-main{
  gap: 10px;
}

/* ---------- RÉALISÉ : rendre “runtime / profondeur / sortie” en tuiles lisibles ---------- */
/* Cible les wrappers existants via leurs inputs (ton fichier n’a pas de classes dédiées) */
#group_after_divers_container .diver-card-main div:has(input[id^="after_rt__"]),
#group_after_divers_container .diver-card-main div:has(input[id^="after_depth__"]),
#group_after_divers_container .diver-card-main div:has(input[id^="after_exit__"]) {
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
}

/* Labels “Runtime réalisé / Heure de sortie / Profondeur réalisée” */
#group_after_divers_container .diver-card-main div:has(input[id^="after_rt__"]) .help-text,
#group_after_divers_container .diver-card-main div:has(input[id^="after_depth__"]) .help-text,
#group_after_divers_container .diver-card-main div:has(input[id^="after_exit__"]) .help-text{
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .10em;
  text-transform: uppercase;
  opacity: .85;
}

/* Valeurs : grosses, centrées (effet “résultat”) */
#group_after_divers_container input[id^="after_rt__"],
#group_after_divers_container input[id^="after_depth__"],
#group_after_divers_container input[id^="after_exit__"]{
  font-size: 26px;
  font-weight: 900;
  text-align: center;
  padding: 10px 12px;
  border-radius: 12px;
  height: 48px;
  line-height: 1.05;
  letter-spacing: 0.02em;
}

/* STEP 7: lisibilité plein soleil (Android/iOS) : focus + contraste */
#group_after_divers_container input[id^="after_rt__"]:focus,
#group_after_divers_container input[id^="after_depth__"]:focus,
#group_after_divers_container input[id^="after_exit__"]:focus{
  outline: none;
  border-color: rgba(120,160,255,0.75);
  box-shadow: 0 0 0 3px rgba(120,160,255,0.28);
}

/* Lever les maxWidth inline (rt=64px, exit=110px…) pour rendre “propre” */
#group_after_divers_container input[id^="after_rt__"],
#group_after_divers_container input[id^="after_depth__"]{
  max-width: none !important;
  width: 90px;
}
#group_after_divers_container input[id^="after_exit__"]{
  max-width: none !important;
  width: 110px;
}

/* Supprimer les spinners (runtime + profondeur) */
#group_after_divers_container input[id^="after_rt__"]::-webkit-outer-spin-button,
#group_after_divers_container input[id^="after_rt__"]::-webkit-inner-spin-button,
#group_after_divers_container input[id^="after_depth__"]::-webkit-outer-spin-button,
#group_after_divers_container input[id^="after_depth__"]::-webkit-inner-spin-button{
  -webkit-appearance: none;
  margin: 0;
}
#group_after_divers_container input[id^="after_rt__"],
#group_after_divers_container input[id^="after_depth__"]{
  -moz-appearance: textfield;
  appearance: textfield;
}

/* ---------- ACTION CRITIQUE : Déco réalisée (bouton plein, très visible) ---------- */
/* Le bouton est dans la carte après les champs et avant le tableau (ton flux actuel) */
#group_after_divers_container .diver-card-main button.btn{
  width: 100%;
  padding: 14px 14px;
  font-size: 16px;
  font-weight: 900;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(120,160,255,0.22);
  box-shadow: 0 8px 18px rgba(0,0,0,0.18);
}

/* ---------- TABLEAU PALIERS : visibilité (Prévu vs Réel) ---------- */
#group_after_divers_container .after-stops-table{
  border-collapse: separate;
  border-spacing: 0;
  overflow: hidden;
  border-radius: 12px;
}

/* Header profondeurs */
#group_after_divers_container .after-stops-table thead th{
  background: rgba(120,160,255,0.28);
  font-weight: 900;
  border-bottom: 2px solid rgba(255,255,255,0.18);

  /* STEP 5: header reste visible (si la carte scrolle verticalement) */
  position: sticky;
  top: 0;
  z-index: 3;
}

/* Corner cell (header + first column) must sit above both sticky layers */
#group_after_divers_container .after-stops-table thead th:first-child{
  z-index: 5;
}

/* Première colonne “Palier / RT1 prévu / Réel” */
#group_after_divers_container .after-stops-table th:first-child,
#group_after_divers_container .after-stops-table td:first-child{
  background: rgba(255,255,255,0.06);
  font-weight: 900;
}

/* Ligne 1 = RT1 prévu */
#group_after_divers_container .after-stops-table tbody tr:nth-child(1) td{
  background: rgba(120,160,255,0.14);
  font-weight: 800;
}

/* Ligne 2 = Réel */
#group_after_divers_container .after-stops-table tbody tr:nth-child(2) td{
  background: rgba(120,210,150,0.14);
  font-weight: 800;
}

/* Cellules vides “—” plus discrètes */
#group_after_divers_container .after-stops-table td{
  font-size: 14px;
}
#group_after_divers_container .after-stops-table td{
  opacity: 1;
}
#group_after_divers_container .after-stops-table td:is(:empty){
  opacity: .35;
}
#group_after_divers_container .after-stops-table td{
  /* fallback: si c’est un "—" (texte), on ne peut pas cibler sans JS.
     Mais la différence Prévu/Réel est déjà claire via les lignes. */
}


/* ---------- STEP 6: TABLEAU PALIERS — lisibilité plein soleil ---------- */
#group_after_divers_container .after-stops-table th,
#group_after_divers_container .after-stops-table td{
  padding: 10px 12px;
  white-space: nowrap;
  border-right: 1px solid rgba(255,255,255,0.10);
}

#group_after_divers_container .after-stops-table th:last-child,
#group_after_divers_container .after-stops-table td:last-child{
  border-right: none;
}

/* Largeur lisible des colonnes */
#group_after_divers_container .after-stops-table td:first-child,
#group_after_divers_container .after-stops-table th:first-child{
  min-width: 160px;
  text-align: left;
  box-shadow: 8px 0 14px rgba(0,0,0,0.18);
}

#group_after_divers_container .after-stops-table th:not(:first-child),
#group_after_divers_container .after-stops-table td:not(:first-child){
  min-width: 58px;
  text-align: center;
}

/* Contraste doux, terrain */
#group_after_divers_container .after-stops-table{
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.03);
}

/* AFTER plongée — ordre visuel des constats réalisés */

/* Runtime en premier */
#group_after_divers_container .diver-card-main div:has(input[id^="after_rt__"]) {
  order: 1;
}

/* Profondeur en second */
#group_after_divers_container .diver-card-main div:has(input[id^="after_depth__"]) {
  order: 2;
}

/* Heure de sortie en troisième */
#group_after_divers_container .diver-card-main div:has(input[id^="after_exit__"]) {
  order: 3;
}

/* AFTER — bouton Déco réalisée (carte plongeur) */
#group_after_divers_container .diver-card-main button.btn {
  width: 100%;
  min-height: 60px;          /* zone tactile */
  padding: 18px 20px;
  font-size: 20px;
  font-weight: 900;
  border-radius: 18px;
  letter-spacing: 0.03em;
}

/* ===== MODAL PALIERS — agrandir les boutons de profondeur ===== */

/* Conteneur du modal */
.modal-content {
  font-size: 16px;
}

/* Boutons paliers (3m, 6m, 9m, 12m…) */
.modal-content button {
  min-height: 44px;          /* standard accessibilité */
  padding: 10px 16px;
  font-size: 16px;
  font-weight: 800;
  border-radius: 14px;
}

/* Bouton "+ Ajouter" */
.modal-content button:last-child {
  font-size: 16px;
  font-weight: 900;
  padding: 12px 18px;
}

/* MODAL — actions finales */
.modal-content .btn {
  min-height: 48px;
  font-size: 16px;
  font-weight: 900;
  border-radius: 16px;
}

/* =========================================================
   AFTER — Agrandir action "Déco réalisée" + modal paliers
   (ciblage basé sur le fichier: .btn + .group-mini-btn)
   ========================================================= */

/* 1) Bouton "Déco réalisée" dans la carte (pas les mini-boutons) */
#group_after_divers_container .diver-card-main .btn:not(.group-mini-btn){
  width: 100% !important;
  min-height: 64px !important;
  padding: 18px 22px !important;
  font-size: 20px !important;
  font-weight: 900 !important;
  border-radius: 18px !important;
}

/* 2) MODAL paliers : les chips 3m/6m/9m/12m/+ Ajouter */
.palier-modal .group-mini-btn{
  min-height: 46px !important;
  padding: 10px 16px !important;
  font-size: 16px !important;
  font-weight: 900 !important;
  border-radius: 14px !important;
}

/* 3) MODAL : Annuler / Sauvegarder */
.palier-modal .palier-modal-footer .btn{
  min-height: 54px !important;
  padding: 14px 22px !important;
  font-size: 18px !important;
  font-weight: 900 !important;
  border-radius: 16px !important;
}


/* === Incidents (par plongeur) — mini-panel compact === */
.incident-btn{
  height: 48px;
  padding: 0 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.06);
  color: var(--text-main);
  font-weight: 800;
  letter-spacing: .02em;
}
.incident-btn[data-n="0"]{ opacity: .75; }

.incident-panel{
  position: absolute;
  left: 10px;
  right: 10px;
  top: 44px;
  background: rgba(10,12,16,0.92);
  border: 1px solid rgba(255,255,255,0.16);
  border-radius: 14px;
  padding: 10px 10px 12px;
  z-index: 30;
  box-shadow: 0 10px 24px rgba(0,0,0,0.45);
}
.inc-title{
  font-size: 12px;
  font-weight: 900;
  letter-spacing: .08em;
  text-transform: uppercase;
  opacity: .9;
  margin: 6px 0 6px;
}
.inc-row{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 6px;
}
.inc-tag{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  user-select: none;
}
.inc-tag input{ transform: translateY(1px); }
.inc-tag span{ font-size: 13px; font-weight: 700; }
.inc-note{
  width: 100%;
  resize: none;
  margin-top: 4px;
  border-radius: 10px;
  padding: 8px 10px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: var(--text-main);
  font-weight: 650;
}
@media (min-width: 760px){
  .incident-panel{ left:auto; right: 10px; width: 520px; }
}

/* === Programme du jour (Avant plongée) : lisibilité cross-device === */
#sec-before-group {
  font-size: 1.05rem;
  line-height: 1.35;
}

#sec-before-group .field label {
  font-size: 1rem;
  font-weight: 600;
}

#sec-before-group input,
#sec-before-group textarea,
#sec-before-group select {
  font-size: 1.1rem;
  padding: 6px 8px;
}

/* Boutons scénarios +5 +10 +15 +20 */
#sec-before-group .btn.small {
  font-size: 1.05rem;
  padding: 6px 10px;
}

/* Mobile phone */
@media (max-width: 480px) {
  #sec-before-group { font-size: 1.15rem; }

  #sec-before-group input,
  #sec-before-group textarea,
  #sec-before-group select {
    font-size: 1.2rem;
  }

  #sec-before-group .btn.small {
    font-size: 1.1rem;
    padding: 8px 12px;
  }
}

/* AVANT PLONGÉE — Meta groupe (Leader + plongeurs) */
#before_group_meta {
  font-size: 1.05rem;        /* ↑ taille lisible (vs texte secondaire) */
  font-weight: 500;          /* plus présent sans être un titre */
  line-height: 1.45;
  margin-top: 6px;
  margin-bottom: 12px;
  padding: 8px 12px;

  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px;

  background: rgba(255,255,255,0.04);
}

.pdj-tools { margin: 10px 0 8px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); }
.pdj-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 8px; }
.pdj-row:last-child { margin-bottom: 0; }
.pdj-chip { padding: 8px 10px; }
.pdj-chip.is-active { outline: 2px solid rgba(255,255,255,0.35); }
.pdj-select { padding: 8px 10px; border-radius: 8px; }
.pdj-count { opacity: 0.85; font-size: 0.95rem; }
.fav-star { margin-left: 8px; font-size: 18px; line-height: 1; background: transparent; border: 0; cursor: pointer; }
.fav-star.is-on { filter: drop-shadow(0 0 2px rgba(255,255,255,0.35)); }



/* PDJ Tools: vues + filtre + bulk (chirurgical) */
.pdj-tools { margin: 10px 0 8px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); }
.pdj-row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 8px; }
.pdj-row:last-child { margin-bottom: 0; }
.pdj-chip { padding: 8px 10px; }
.pdj-chip.is-active { outline: 2px solid rgba(255,255,255,0.35); }
.pdj-select { padding: 8px 10px; border-radius: 8px; }
.pdj-count { opacity: 0.85; font-size: 0.95rem; }
.fav-star { margin-left: 8px; font-size: 18px; line-height: 1; background: transparent; border: 0; cursor: pointer; }
.fav-star.is-on { filter: drop-shadow(0 0 2px rgba(255,255,255,0.35)); }


.pdj-actions {
  display: flex;
  gap: 10px;          /* espace entre les boutons */
  margin-top: 10px;
  flex-wrap: wrap;    /* iPhone: évite les boutons hors écran */
}

@media (max-width: 520px){
  .pdj-actions{ flex-direction: column; }
  .pdj-actions .btn{ width: 100%; }
}

.pdj-actions .btn {
  flex: 1;            /* même largeur */
}



@media (max-width: 420px) {
  #pdj_tools .pdj-row {
    flex-direction: column;
  }
  #pdj_tools .pdj-chip {
    width: 100%;
  }
}

.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}

    .validation-banner{
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 10px;
      margin-bottom: 10px;
      font-weight: 700;
      line-height: 1.25;
      border: 1px solid var(--border-soft);
    }
    .validation-banner.error{
      background: rgba(255, 77, 79, 0.12);
      border-color: rgba(255, 77, 79, 0.35);
    }
    .validation-banner.warning{
      background: rgba(255, 193, 7, 0.14);
      border-color: rgba(255, 193, 7, 0.40);
    }
    .validation-banner .vb-title{ margin-bottom: 6px; }
    .validation-banner ul{ margin: 0; padding-left: 18px; }
    .validation-banner li{ font-weight: 600; margin: 2px 0; }

    .group-meta-panel{
      margin-top: 8px;
      padding: 8px 8px 10px;
      border: 1px dashed rgba(255,255,255,0.20);
      border-radius: 10px;
      background: rgba(0,0,0,0.10);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .group-meta-row{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }
    .group-meta-row label{
      font-weight:700;
      font-size: 13px;
      opacity: 0.95;
      margin-right: 6px;
    }
    .group-meta-row select{
      flex: 1 1 180px;
      min-width: 180px;
    }
    .group-meta-row .btn{
      flex: 0 0 auto;
      padding: 8px 10px;
      font-size: 13px;
    }

#pdfActionsBar {
  position: sticky;
  bottom: 0;
  background: #fff;
  border-top: 1px solid #ddd;
  padding: 12px;
  display: flex;
  gap: 14px;
  justify-content: center;
  z-index: 1000;
}

.pdf-btn {
  padding: 10px 18px;
  font-size: 15px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
}

.pdf-btn.primary { background:#0b3c5d; color:#fff; }
.pdf-btn.success { background:#2e8b57; color:#fff; }
.pdf-btn.neutral { background:#e0e0e0; color:#333; }

.pdf-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* PATCH — PDF state label + signed stamp */
.pdf-state-label{
  display:inline-flex;
  align-items:center;
  padding:8px 10px;
  border-radius:999px;
  font-size:13px;
  font-weight:700;
  background:#f2f2f2;
  color:#333;
  border:1px solid #ddd;
}
.pdf-state-label.state-validated{ background:#e6f0ff; border-color:#b8d2ff; color:#0b3c5d; }
.pdf-state-label.state-signed{ background:#e9f7ee; border-color:#bfe6cc; color:#1f6b3d; }

#pdfSignedStamp{
  position: sticky;
  top: 0;
  z-index: 900;
  margin: 10px 0;
  padding: 10px 12px;
  border: 2px solid #2e8b57;
  border-radius: 8px;
  background: #ffffff;
  font-weight: 800;
}


/* --- QR Scan modal --- */
.modal-overlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.35);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:9999;
  padding:16px;
}
.modal-card{
  background:#fff;
  border-radius:14px;
  box-shadow:0 12px 30px rgba(0,0,0,0.18);
  border:1px solid #cfe0ff;
}

/* =========================================
   PATCH UI — menu ⋯ Export/Import bibliothèque
   ========================================= */
.lib-menu-wrap{
  position: relative;
  display: inline-flex;
  align-items: center;
}
.btn-ellipsis{
  padding: 10px 14px;
  min-width: 44px;
  font-size: 18px;
  line-height: 1;
}
.lib-menu{
  position: absolute;
  right: 0;
  top: calc(100% + 6px);
  background: rgba(10,18,36,0.98);
  border: 1px solid rgba(255,255,255,0.14);
  border-radius: 12px;
  padding: 6px;
  min-width: 220px;
  z-index: 9999;
  box-shadow: 0 10px 22px rgba(0,0,0,0.45);
}
.lib-menu-item{
  width: 100%;
  text-align: left;
  background: transparent;
  border: 0;
  color: var(--text-main);
  font-weight: 700;
  font-size: 14px;
  padding: 10px 10px;
  border-radius: 10px;
  cursor: pointer;
}
.lib-menu-item:hover{
  background: rgba(255,255,255,0.08);
}



/* ===== NUMPAD UNIVERSAL ===== */
.numpad-field{ display:flex; gap:8px; align-items:center; }
.numpad-open{
  width:56px; height:44px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.08);
  color: var(--text-main);
  font-weight:900;
}

.numpad-overlay{
  position:fixed; inset:0;
  background: rgba(0,0,0,0.45);
  display:none;
  align-items:flex-end;
  justify-content:center;
  z-index:9999;
}
.numpad{
  width:min(420px, calc(100vw - 20px));
  margin:10px;
  border-radius:16px;
  padding:12px;
  background: rgba(10,12,16,0.96);
  border: 1px solid rgba(255,255,255,0.18);
}
.numpad-grid{
  display:grid;
  grid-template-columns:repeat(3, 1fr);
  gap:10px;
}
.numpad-btn{
  height:54px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.07);
  color: var(--text-main);
  font-size:20px;
  font-weight:900;
}
.numpad-actions{ display:flex; gap:10px; margin-top:10px; }
.numpad-btn.wide{ flex:1; }

/* === NUMPAD : logo OCEAN INFINITY en filigrane === */
.numpad{
  position: relative;
}

.numpad::before{
  content: "";
  position: absolute;
  inset: 0;
  background-image: url("./OCEAN_INFINITY_exact_512.png");
  background-repeat: no-repeat;
  background-position: center;
  background-size: 55%;
  opacity: 0.08;
  pointer-events: none;
  z-index: 0;
}

/* garantit que les touches restent cliquables au-dessus */
.numpad > *{
  position: relative;
  z-index: 1;
}

/* === SPLASH logo (200ms) === */
#app_splash{
  position: fixed;
  inset: 0;
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(6, 12, 20, 0.98);
  opacity: 1;
  transition: opacity 260ms ease-out;
}
#app_splash.hide{ opacity: 0; pointer-events:none; }
#app_splash img{
  width: min(420px, 84vw);
  height: auto;
  max-height: 70vh;
  opacity: 0.98;
  filter: drop-shadow(0 10px 20px rgba(0,0,0,0.55));
}


    /* PDJ search (replaces Récents) */
    .pdj-search{
      flex: 1;
      min-width: 140px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.18);
      color: #fff;
      outline: none;
    }
    .pdj-search::placeholder{ color: rgba(255,255,255,0.75); }

  
/* ===== PDJ TOOLS BAR FIX (order + no empty band) ===== */
#pdj_tools .pdj-row{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
}
#pdj_tools .pdj-search{
  flex:1 1 180px;
  min-width:180px;
}
#pdj_tools .pdj-select{
  width:auto !important;
  min-width:190px;
  flex:0 0 auto;
}


  /* G4: export QR status visibility */
  .status-text{ color:#cfe0ff; font-weight:700; }

/* =======================
   A1 REFONTE – ÉCRAN SCANNER QR (plein écran)
   ======================= */
#qr_scanner_screen{
  position:fixed;
  inset:0;
  z-index:99999;
  background:rgba(5, 12, 26, 0.92);
  display:none;
}
#qr_scanner_screen .qrss-card{
  position:absolute;
  inset:12px;
  background:#fff;
  border-radius:14px;
  box-shadow:0 12px 30px rgba(0,0,0,0.30);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}
#qr_scanner_screen .qrss-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:12px 14px;
  border-bottom:1px solid #e6ecff;
}
#qr_scanner_screen .qrss-title{
  font-weight:800;
  font-size:16px;
  color:#0b1a44;
}
#qr_scanner_screen .qrss-close{
  border:1px solid #d7def7;
  background:#f6f8ff;
  border-radius:10px;
  padding:8px 10px;
  font-weight:800;
}
#qr_scanner_screen .qrss-body{
  padding:12px 14px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:0; /* allow scroll area */
}
#qr_scanner_screen .qrss-status{
  padding:10px 12px;
  border-radius:12px;
  background:#f3f6ff;
  border:1px solid #dbe5ff;
  color:#0b1a44;
  font-weight:700;
  font-size:14px;
}
.qrss-debug{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;}

#qr_scanner_screen .qrss-videoWrap{
  border-radius:12px;
  overflow:hidden;
  background:#000;
  border:1px solid #dbe5ff;
}
#qr_scanner_screen video{
  width:100%;
  height:auto;
  max-height:38vh;
  object-fit:cover;
  display:block;
  background:#000;
}
#qr_scanner_screen .qrss-actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
#qr_scanner_screen .qrss-actions button{
  flex:1 1 160px;
  min-width:140px;
  border-radius:12px;
  padding:12px 12px;
  font-weight:900;
}
#qr_scanner_screen .qrss-actions .primary{
  background:#0b63ff;
  color:#fff;
  border:1px solid #0b63ff;
}
#qr_scanner_screen .qrss-actions .secondary{
  background:#ffffff;
  color:#0b1a44;
  border:1px solid #d7def7;
}
#qr_scanner_screen .qrss-footnote{
  color:#5b6b99;
  font-size:12px;
  line-height:1.35;
}
@media (max-width:520px){
  #qr_scanner_screen .qrss-card{ inset:10px; }
  #qr_scanner_screen .qrss-actions button{ flex:1 1 100%; min-width:0; }
}

</style>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

</head>
<body>
<div id="centerSetupModal" class="modal-overlay" style="display:none;">
  <div class="modal-card" style="max-width:520px; width:100%; padding:16px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
      <div style="font-weight:900; font-size:16px; color:#0b3c5d;">Configuration centre</div>
      <button type="button" class="btn btn-secondary" id="btnCenterSetupClose" style="padding:8px 12px;">Fermer</button>
    </div>

    <div class="pdf-muted" style="font-size:13px; margin-bottom:10px;">
      À faire une seule fois au démarrage. Stocké en local sur cet appareil / navigateur.
    </div>

    <div class="row" style="gap:10px; flex-wrap:wrap;">
    <div class="field" style="flex:2; min-width:220px;">
      <label>Centre</label>
      <div id="center_display" class="mono" style="padding:10px 12px;border:1px solid #d7d7d7;border-radius:10px;background:#fff;color:#0b3a5a;font-weight:700;">—</div>
    </div>
    <div class="field" style="flex:1; min-width:160px;">
      <label>&nbsp;</label>
      <button type="button" class="btn btn-secondary" id="btn_center_setup" style="width:100%;">⚙️ Centre</button>
    </div>

      <div class="field" style="flex:2; min-width:220px;">
        <label for="center_name_input">Nom du centre</label>
        <input id="center_name_input" type="text" placeholder="Ex: Sea Angel / Club XYZ"/>
      </div>
      <div class="field" style="flex:1; min-width:140px;">
        <label for="center_boats_input">Nb bateaux (option)</label>
        <input id="center_boats_input" type="number" min="1" max="8" inputmode="numeric" placeholder="1"/>
      </div>
    </div>

    <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:10px; align-items:flex-end;">
      <div class="field" style="flex:2; min-width:220px;">
        <label for="center_id_input">ID centre (généré)</label>
        <input id="center_id_input" type="text" readonly style="opacity:0.9; background:#f6f8ff;"/>
      </div>
      <div class="field" style="flex:1; min-width:140px;">
        <label>&nbsp;</label>
        <button type="button" class="btn btn-secondary" id="btnCenterIdRegen" style="width:100%;">↻ Regénérer</button>
      </div>
    </div>

    <div class="row" style="gap:10px; margin-top:14px; justify-content:flex-end;">
      <button type="button" class="btn btn-primary" id="btnCenterSetupSave">Enregistrer</button>
    </div>
  </div>
</div>


  <!-- Splash (logo plein écran 200ms) -->
  <div id="app_splash" aria-hidden="true">
    <img src="./OCEAN_INFINITY_exact_512.png" alt="Ocean Infinity">
  </div>

<div class="container">
<!-- SECTION: CONTEXTE (CONSTANTES + SITE + GPS) -->
  <section class="section" id="sec-site-gps">
    <div class="section-title">Contexte du jour</div>
    <p class="help-text">Renseignez les constantes (DP / bateau / sécurité surface), puis le site et les coordonnées GPS (format marin).</p>

    <!-- Constantes -->
    <div class="row" style="align-items:flex-end; gap:10px; flex-wrap:wrap;">
      <div class="field" style="flex:1; min-width:160px;">
        <label for="dive_const_dp">DP</label>
        <div style="display:flex; gap:6px; align-items:center;">
          <input id="dive_const_dp" type="text" placeholder="Nom DP" list="dp_list" style="flex:1;"/>
          <button type="button" class="btn btn-secondary" id="btn_dp_add" title="Ajouter / ouvrir la base formateurs DP" style="white-space:nowrap;">📚</button>
          <button type="button" class="btn btn-secondary" id="btn_instructor_sync" title="Synchroniser la base instructeurs depuis la bibliothèque plongeurs (ajout uniquement)" style="white-space:nowrap;">↻</button>
        </div>
      </div>
      <datalist id="dp_list"></datalist>
      <div class="field" style="flex:1; min-width:160px;">
        <label for="dive_const_boat">Bateau</label>
        <input id="dive_const_boat" type="text" placeholder="Nom bateau"/>
      </div>
      <div class="field" style="flex:1; min-width:180px;">
        <label for="dive_const_surface">Sécurité surface</label>
        <input id="dive_const_surface" type="text" placeholder="Nom sécu surface"/>
      </div>
    </div>

    <!-- Site -->
    <div class="row" style="align-items:flex-end; gap:10px; flex-wrap:wrap; margin-top:10px;">
      <div class="field" style="flex:2; min-width:220px;">
        <label for="dive_site_select">Site de plongée</label>
        <select id="dive_site_select"></select>
      </div>

      <div class="field" style="flex:2; min-width:220px;">
        <label for="dive_site_name">Nom (édition)</label>
        <input id="dive_site_name" type="text" placeholder="Nom du site"/>
      </div>

      <div class="field" style="flex:1; min-width:120px;">
        <label>&nbsp;</label>
        <button type="button" class="btn btn-secondary" id="btn_site_save" style="width:100%;">＋ Ajouter</button>
      </div>

      <div class="field" style="flex:1; min-width:120px;">
        <label>&nbsp;</label>
        <button type="button" class="btn btn-secondary" id="btn_site_delete" style="width:100%;">－ Supprimer</button>
      </div>
    </div>

    <!-- GPS -->
    <div class="row" style="align-items:flex-end; gap:10px; flex-wrap:wrap; margin-top:10px;">
      <div class="field" style="flex:2; min-width:220px;">
        <label>GPS (style marin)</label>
       <div id="dive_gps_nav" class="mono"
     style="
       padding:10px 12px;
       border:1px solid #d7d7d7;
       border-radius:10px;
       background:#fff;
       color:#0b3a5a;
       font-weight:600;
       opacity:1;
       -webkit-text-fill-color:#0b3a5a;
     ">
          —
        </div>
      </div>

      <div class="field" style="flex:1; min-width:140px;">
        <label for="dive_gps_lat">Lat (dd)</label>
        <input id="dive_gps_lat" type="text" inputmode="decimal" placeholder="43.70..."/>
      </div>

      <div class="field" style="flex:1; min-width:140px;">
        <label for="dive_gps_lon">Lon (dd)</label>
        <input id="dive_gps_lon" type="text" inputmode="decimal" placeholder="7.28..."/>
      </div>

      <div class="field" style="flex:1; min-width:120px;">
        <label for="dive_gps_acc">± m</label>
        <input id="dive_gps_acc" type="number" inputmode="numeric" placeholder="10"/>
      </div>

      <div class="field" style="flex:1; min-width:160px;">
        <label>&nbsp;</label>
        <button type="button" class="btn btn-secondary" id="btn_gps_capture" style="width:100%;">📍 Capturer</button>
      </div>

      <span id="site_gps_status" class="status-text" style="align-self:center;"></span>
    </div>
  </section>

  <!-- SECTION: PLONGEURS DU JOUR -->
  <section class="section" id="sec-plongeurs-jour">
    <div class="section-title">Plongeurs du jour</div>
    <p class="help-text">
      Sélectionnez les plongeurs présents sur le bateau aujourd'hui.
    </p>

    
    <div style="margin: 8px 0 10px 0; display:flex; gap:10px; flex-wrap:wrap;">
      <button type="button" class="btn btn-secondary" id="btn_add_diver">
        + Ajouter un plongeur
      </button>

      <button type="button" class="btn btn-secondary" id="btn_edit_diver">
        ✏️ Modifier un plongeur
      </button>


      <span class="lib-menu-wrap">
        <button type="button" class="btn btn-secondary btn-ellipsis" id="btn_library_menu" title="Outils bibliothèque">⋯</button>
        <div class="lib-menu" id="library_menu" style="display:none;">
          <button type="button" class="lib-menu-item" id="btn_export_library" title="Exporter la bibliothèque (plongeurs + DP/instructeurs)">⬇️ Exporter bibliothèque</button>
          <button type="button" class="lib-menu-item" id="btn_import_library" title="Importer une bibliothèque (merge non destructif)">⬆️ Importer bibliothèque</button>
          <button type="button" class="lib-menu-item" id="btn_import_csv" title="Importer un CSV centre (divers + instructeurs)">⬆️ Importer CSV (centre)</button>
        </div>
      </span>
      <input type="file" id="file_import_library" accept="application/json" style="display:none;" />
      <input type="file" id="file_import_csv" accept=".csv,text/csv" style="display:none;" />

    </div>

    <div id="add-diver-form" class="add-diver-form" style="display:none;">
      <div class="row">
        <div class="field" style="flex:1;">
          <label for="add_diver_name">Nom</label>
          <input type="text" id="add_diver_name" placeholder="Nom du plongeur">
        </div>
        <div class="field" style="flex:1;">
          <label for="add_diver_aptitude_select">Aptitude (badge)</label>
          <select id="add_diver_aptitude_select">
            <option value="">— Sélectionner —</option>
             <option value="BAPTEME">BAPTÊME</option>
             <option value="PE6">PE6</option>
             <option value="PE12">PE12</option>
             <option value="PE20">PE20</option>
             <option value="PE40">PE40</option>
             <option value="PE60">PE60</option>
             <option value="PA12">PA12</option>
             <option value="PA20">PA20</option>
             <option value="PA40">PA40</option>
             <option value="PA60">PA60</option>
             <option value="PTH70">PTH 70</option>
             <option value="PTH120">PTH 120</option>
             <option value="CCR40">CCR 40</option>
             <option value="CCR70">CCR 70</option>
             <option value="CCR100">CCR 100</option>
             <option value="CCR120">CCR 120</option>
             <option value="Autre">Autre (manuel)</option>
          </select>
          <div id="add_diver_aptitude_manual_wrap" style="display:none; margin-top:6px;">
            <input type="text" id="add_diver_aptitude_manual" placeholder="Aptitude (manuel)">
          </div>
        </div>
      </div>

      <div class="row">
        <div class="field" style="flex:1;">
          <label for="add_diver_cert_select">Certification (bibliothèque)</label>
          <select id="add_diver_cert_select">
            <option value="">Sélectionner une certification</option>
          </select>
        </div>
        <div class="field" id="add_diver_cert_manual_wrap" style="flex:1; display:none;">
          <label for="add_diver_cert_manual">Certification (manuel)</label>
          <input type="text" id="add_diver_cert_manual" placeholder="ex : TDI Advanced Trimix CCR">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <button type="button" class="btn btn-primary" id="btn_add_diver_confirm">Ajouter</button>
        <button type="button" class="btn" id="btn_add_diver_cancel">Annuler</button>
      </div>

      <div id="add-diver-status" class="status-text" style="margin-top:6px;"></div>
    </div>

    <div id="edit-diver-form" class="add-diver-form" style="display:none; margin-top:10px;">
      <div class="row">
        <div class="field" style="flex:1;">
          <label for="edit_diver_search">Recherche (nom ou licence)</label>
          <input type="text" id="edit_diver_search" list="diver_list" placeholder="Tape le prénom/nom (autocomplete)">
          <datalist id="diver_list"></datalist>
        </div>      </div>

      <div class="row" style="margin-top:6px;">
        <div class="field" style="flex:1;">
          <label for="edit_diver_name">Nom</label>
          <input type="text" id="edit_diver_name" placeholder="Nom du plongeur">
        </div>
        <div class="field" style="flex:1;">
          <label for="edit_diver_licence">N° licence</label>
          <input type="text" id="edit_diver_licence" placeholder="Licence">
        </div>
      </div>

      <div class="row">
        <div class="field" style="flex:1;">
          <label for="edit_diver_aptitude_select">Aptitude (badge)</label>
          <select id="edit_diver_aptitude_select">
            <option value="">— Sélectionner —</option>
             <option value="BAPTEME">BAPTÊME</option>
             <option value="PE6">PE6</option>
             <option value="PE12">PE12</option>
             <option value="PE20">PE20</option>
             <option value="PE40">PE40</option>
             <option value="PE60">PE60</option>
             <option value="PA12">PA12</option>
             <option value="PA20">PA20</option>
             <option value="PA40">PA40</option>
             <option value="PA60">PA60</option>
             <option value="PTH70">PTH 70</option>
             <option value="PTH120">PTH 120</option>
             <option value="CCR40">CCR 40</option>
             <option value="CCR70">CCR 70</option>
             <option value="CCR100">CCR 100</option>
             <option value="CCR120">CCR 120</option>
             <option value="Autre">Autre (manuel)</option>
          </select>
          <div id="edit_diver_aptitude_manual_wrap" style="display:none; margin-top:6px;">
            <input type="text" id="edit_diver_aptitude_manual" placeholder="Aptitude (manuel)">
          </div>
        </div>
      </div>

      <div class="row">
        <div class="field" style="flex:1;">
          <label for="edit_diver_cert_select">Certification (bibliothèque)</label>
          <select id="edit_diver_cert_select">
            <option value="">Sélectionner une certification</option>
          </select>
        </div>
        <div class="field" id="edit_diver_cert_manual_wrap" style="flex:1; display:none;">
          <label for="edit_diver_cert_manual">Certification (manuel)</label>
          <input type="text" id="edit_diver_cert_manual" placeholder="ex : TDI Advanced Trimix CCR">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <button type="button" class="btn btn-primary" id="btn_edit_diver_confirm">Enregistrer</button>
        <button type="button" class="btn" id="btn_edit_diver_cancel">Annuler</button>
      </div>

      <div id="edit-diver-status" class="status-text" style="margin-top:6px;"></div>
    </div>

<!-- <!-- SECTION: GROUPES & AFFECTATION -->
        <!-- OUTILS: Vues + filtre + bulk -->
    <div id="pdj_tools" class="pdj-tools">
      <div class="pdj-row">
        <button type="button" class="btn pdj-chip" id="pdj_view_all">Tous</button>
        <button type="button" class="btn pdj-chip" id="pdj_view_fav">Favoris</button>
        <input type="text" id="pdj_search" class="pdj-search" placeholder="Rechercher…">
        <datalist id="pdj_search_list"></datalist>
<select id="pdj_filter_apt" class="pdj-select" title="Filtrer par aptitude">
          <option value="">Aptitude : toutes</option>
        </select>
      </div>

     
<div id="plongeurs-jour-list" class="plongeurs-jour-container">
      <!-- Cartes plongeurs générées en JS à partir de diverLibrary -->
    </div>

    <div class="pdj-actions">
      <button
        type="button"
        class="btn btn-primary"
        id="btn_valider_plongeurs_jour">
        Valider les plongeurs du jour
      </button>

      <button
        type="button"
        class="btn"
        id="pdj_bulk_remove">
        Retirer les plongeurs du jour
      </button>


      <button type="button" class="btn" id="btn_qr_scan_diver" title="Scanner un QR code plongeur">
        + Scanner QR plongeur
      </button>
      <div id="qr-scan-status" class="status-text" style="margin-top:6px;"></div>

    </div>

    <div id="plongeurs-jour-status" class="status-text" style="margin-top:6px;"></div>
  </section>

  

<section class="section" id="sec-groupes">
    <div class="section-title">Groupes &amp; affectation</div>
<div class="bulk-boat-assign" style="margin:10px 0; display:flex; gap:8px; align-items:center;">
  <label for="ga_bulk_boat"><strong>Bateau (masse)</strong></label>
  <select id="ga_bulk_boat" class="pdj-select">
    <option value="">—</option>
  </select>
  <button type="button" class="btn btn-secondary" id="btn_ga_apply_boat">Appliquer à tous les PDJ</button>
  <button type="button" class="btn" id="btn_ga_clear_boat">Effacer unités PDJ</button>
</div>

<div class="bulk-boat-assign" id="ga_export_boat" style="margin:8px 0 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
  <label for="ga_export_boat_sel"><strong>Export QR – Bateau</strong></label>
  <select id="ga_export_boat_sel" class="pdj-select">
    <option value="">—</option>
  </select>
  <button type="button" class="btn btn-primary" id="btn_ga_export_qr">Générer QR</button>
  <span id="ga_export_qr_status" class="status-text"></span>
</div>

<div id="ga_export_qr_wrap" style="display:none; margin-top:8px; padding:10px; border:1px solid #cfe0ff; border-radius:12px;">
  <img id="ga_export_qr_img" alt="QR code" style="width:260px;height:260px;border-radius:8px;background:#fff;display:block;" />
  <div style="margin-top:8px; display:flex; gap:8px; align-items:center; justify-content:center;">
    <button type="button" class="btn" id="btn_ga_qr_prev">◀︎</button>
    <span id="ga_qr_page_label" style="font-weight:800;"></span>
    <button type="button" class="btn" id="btn_ga_qr_next">▶︎</button>
  </div>
</div>

    <p class="help-text">
      À partir des plongeurs du jour, affectez chacun à un groupe opérationnel.
      Cette étape n'a, pour l'instant, aucun impact sur les autres sections de la fiche.
    </p>

    <!-- Bouton pour ajouter un nouveau groupe -->
    <div class="add-group-container">
      <button type="button" class="btn btn-secondary" id="btn_add_group">
        + Ajouter un groupe
      </button>
    </div>

    <div id="group-validation-banner" class="validation-banner" style="display:none;"></div>

    <!-- Ligne Plongeurs disponibles -->
    <div class="group-row" id="group-dispo-row">
      <div class="group-column group-column-full">
        <div class="group-header">
          Plongeurs disponibles aujourd'hui
        </div>
        <div id="group-disponibles-list" class="group-diver-list">
          <!-- Cartes générées en JS à partir de diversDuJour -->
        </div>
      </div>
    </div>

       <!-- Ligne Groupes -->
    <div class="group-row" id="group-main-row">

          <!-- GROUPE 1 -->
      <div class="group-column" data-group="G1">
        <div class="group-header">
          Groupe 1
        </div>

        <div class="group-buttons">
          <button type="button" class="btn" id="g1_before">
            Avant plongée
          </button>
          <button type="button" class="btn btn-primary" id="g1_after">
            Après plongée
          </button>
        </div>

        <div id="group-G1-list" class="group-diver-list">
          <!-- Plongeurs affectés au Groupe 1 -->
        </div>
      </div>

 
    </div>

    <div id="groupes-status" class="status-text" style="margin-top:8px;"></div>
  

    <!-- ACTIONS & EXPORT (intégré dans Groupes/Affectation) -->
    <!-- SECTION: EXPORT WHATSAPP -->
  <div class="section" id="sec-export">
  <div class="section-title">Export & PDF</div>

  <div class="footer-actions">
    <button type="button" class="btn btn-primary" id="btn-preview-pdf">
      👁️ Prévisualiser PDF
    </button>

    <button type="button" class="btn btn-primary" id="btn-export-pdf">
      📄 Export PDF / WhatsApp
    </button>

    <button type="button" class="btn btn-reset" id="btn-reset">
      RESET
    </button>
  </div>

  <div id="pdf-preview"></div>
<!-- PDF Actions Bar -->
<div id="pdfActionsBar" style="display:none;">
  
  <span id="pdfStateLabel" class="pdf-state-label">Brouillon</span>
<button id="btnValidate" class="pdf-btn primary">✓ Valider le document</button>
  <button id="btnSign" class="pdf-btn success" disabled>✍️ Signer électroniquement</button>
  <button id="btnQuit" class="pdf-btn neutral">↩︎ Quitter</button>
</div>
</div>

  </section>
<section class="section" id="sec-before-group" style="display:none;">
  <div class="section-title">
    Programme du jour – Avant plongée le <span id="before_date_title">—</span>
  </div>

<!-- EN-TÊTE AVANT PLONGÉE (LAYOUT FICHE DE PLONGÉE) -->
<div class="section" style="margin-top:10px; padding:10px 12px;">

<!-- En-tête groupe (nom du groupe injecté en JS) -->
<p class="help-text" id="before_group_header">
    Groupe : <span id="before_group_name">Groupe X</span>
  </p>
<p id="before_group_meta" class="group-meta"></p>

  <!-- Ligne 0 : Date + DTR (briefing) -->
  <!-- Date (stockage) -->
  <input type="text" id="group_before_date" placeholder="JJ/MM/AAAA" style="display:none;" />


  <!-- Ligne 1 : Type de plongeurs du groupe -->
  <div class="field">
    <label>Type de plongeurs du groupe</label>
    <select id="group_before_site_group">
      <option value="AIR">AIR</option>
      <option value="TRIMIX_CCR">TRIMIX / CCR</option>
    </select>
  </div>

  <!-- Bloc TRIMIX/CCR (MultiDeco) - visible uniquement si TRIMIX/CCR -->
<div id="before_trimix_container" style="display:none; margin-top:10px; padding:10px; border:1px solid rgba(255,255,255,0.12); border-radius:10px;">
    <div style="font-weight:700; margin-bottom:8px;">MultiDeco (TRIMIX / CCR)</div>

    <div class="field">
      <label>RT1 (MultiDeco)</label>
      <textarea id="group_before_rt1" placeholder="Coller ici RT1 (MultiDeco)"></textarea>
    </div>
    <div class="field">
      <label>RT2 (MultiDeco) – optionnel</label>
      <textarea id="group_before_rt2" placeholder="Coller ici RT2 (optionnel)"></textarea>
    </div>
    <div class="field">
      <label>RT3 (MultiDeco) – optionnel</label>
      <textarea id="group_before_rt3" placeholder="Coller ici RT3 (optionnel)"></textarea>
    </div>

    <div class="row" style="align-items:center; gap:10px; flex-wrap:wrap;">
      <button type="button" class="btn" id="btn_analyser_rt1" disabled>ANALYSER</button>
      <div id="before_md_status" class="help-text" style="margin:0;">—</div>
    </div>

    <div class="help-text" style="margin-top:8px;">
      Profondeur prévue : <span id="before_md_depth">—</span> &nbsp;|&nbsp;
      RT planifié : <span id="before_md_runtime">—</span>
    </div>
  </div>



  <!-- Ligne 2 : Heure de mise à l'eau + Scénarios -->
  <div class="row" style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
    <div class="field" style="flex:1; min-width:220px;">
      <label>Heure de mise à l'eau (HH:mm)</label>
      <input type="text" id="group_before_in_planned" inputmode="numeric" placeholder="HH:MM" maxlength="5" />
    </div>

    <div class="field" style="flex:1; min-width:220px;">
      <label>Scénarios</label>
      <div class="row" style="gap:10px; flex-wrap:wrap;">
        <button type="button" class="btn small" id="btn_in_plus_5">+5</button>
        <button type="button" class="btn small" id="btn_in_plus_10">+10</button>
        <button type="button" class="btn small" id="btn_in_plus_15">+15</button>
        <button type="button" class="btn small" id="btn_in_plus_20">+20</button>
      </div>
    </div>
  </div>

  <!-- Ligne 3 : DTR + Profondeur max -->
  <div class="row" style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
    <div class="field" style="flex:1; min-width:220px;">
      <label>DTR max (min)</label>
      <div class="numpad-field">
        <input type="number" id="group_before_dtr_max" min="0" step="1" placeholder="ex: 15" />
        <button type="button" class="numpad-open" data-numpad-for="group_before_dtr_max">123</button>
      </div>
    </div>

    <div class="field" style="flex:1; min-width:220px;">
      <label>Profondeur prévue (m)</label>
      <div class="numpad-field">
        <input type="number" id="group_before_depth_planned" min="0" step="1" placeholder="ex: 60" />
        <button type="button" class="numpad-open" data-numpad-for="group_before_depth_planned">123</button>
      </div>
    </div>
  </div>

  <!-- Ligne 4 : RT planifié + Sortie estimée -->
  <div class="row" style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
    <div class="field" style="flex:1; min-width:220px;">
      <label>RT planifié (min)</label>
      <div class="numpad-field">
        <input type="number" id="group_before_runtime_group_planned" min="1" step="1" placeholder="ex: 90" />
        <button type="button" class="numpad-open" data-numpad-for="group_before_runtime_group_planned">123</button>
      </div>
    </div>

    <div class="field" style="flex:1; min-width:220px;">
      <label>Sortie estimée</label>
      <input type="text" id="group_before_exit_planned" inputmode="numeric" placeholder="HH:MM" maxlength="5" readonly />
    </div>
  </div>

  <div class="field">
    <label for="group_before_formations">Formations / Encadrement</label>
    <textarea id="group_before_formations" rows="3" placeholder="Texte libre..."></textarea>
  </div>

  <div class="field">
    <label for="group_before_observations">Observations (avant plongée)</label>
    <textarea id="group_before_observations" rows="3" placeholder="Texte libre..."></textarea>
  </div>

</div>
<!-- Plongeurs du groupe : container (rempli en JS) -->
  <div class="section" style="margin-top:12px; padding:10px 12px;">
   

    <!-- Container pour les cartes plongeurs (généré en JS) -->
    <div id="group_before_divers_container"></div>
     
  

  <!-- Actions -->
  <div class="footer-actions">
   
    <button type="button" class="btn" id="btn_before_back">
      ← Retour aux groupes
    </button>
  </div>
</section>

<section class="section" id="sec-after-group" style="display:none;">
  <div class="section-title">
    Programme du jour – Après plongée
  </div>

  <!-- En-tête groupe -->
  <p class="help-text" id="after_group_header">
    Groupe : <span id="after_group_name">Groupe X</span>
  </p>
  <p class="help-text" id="after_group_meta"></p>
  <!-- (v1.001) Simplification: EXIT groupe + incidents groupe supprimés (incidents par plongeur) -->

  

  <!-- Paliers effectués : désormais PAR PLONGEUR (voir cartes ci-dessous) -->

<!-- Plongeurs du groupe : runtime réel + paliers individuels -->
  <div class="section" style="margin-top:12px; padding:10px 12px;">
    <div class="section-title" style="font-size:16px; margin-bottom:8px;">
      Plongeurs du groupe – données réelles
    </div>
    <p class="help-text">
      Pour chaque plongeur : Runtime réalisé + Heure de sortie, puis tableau horizontal des paliers effectués.
    </p>

    
  <!-- PATCH16: FORMATION – Paliers groupe -->
  <div id="after_formation_group_paliers" class="card" style="display:none; margin:10px 0; padding:10px; border:1px solid #cfe0ff; border-radius:10px;">
    <div style="font-weight:700; margin-bottom:8px;">Paliers groupe – FORMATION</div>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button type="button" class="btn" id="btn_after_group_paliers_edit">Saisir paliers groupe</button>
      <button type="button" class="btn btn-primary" id="btn_after_group_paliers_apply">Appliquer aux plongeurs</button>
      <span class="help-text" id="after_group_paliers_hint" style="margin-left:4px;">Copie initiale uniquement (modifiable ensuite).</span>
    </div>
  </div>
  <!-- /PATCH16 -->

<div id="group_after_divers_container"></div>
      
  

  <!-- Actions -->
  <div class="footer-actions">
    
    <button type="button" class="btn" id="btn_after_back">
      ← Retour aux groupes
    </button>
  </div>
</section>

  

  <!-- SECTION: PREVIEW PDF  -->
  


<!-- QR SCAN MODAL (DIVERS) -->
<div id="qr_scan_overlay" class="modal-overlay" style="display:none;">
  <div class="modal-card" style="max-width:520px; width:92%; padding:12px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;">
      <div style="font-weight:800;">Scanner QR Plongeur</div>
      <button type="button" class="btn" id="btn_qr_scan_close">✕</button>
    </div>

    <div class="help-text" style="margin-bottom:8px;">
      Caméra (si supportée) ou coller le contenu QR en manuel.
    </div>

    <div id="qr_scan_cam_wrap" style="display:none; margin-bottom:10px;">
      <video id="qr_scan_video" playsinline style="width:100%; border-radius:10px; border:1px solid #cfe0ff;"></video>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
        <button type="button" class="btn btn-primary" id="btn_qr_scan_start">Démarrer caméra</button>
        <button type="button" class="btn" id="btn_qr_scan_stop">Stop</button>
        <button type="button" class="btn" id="btn_qr_scan_photo">Photo</button>
        <input type="file" id="qr_scan_file" accept="image/*" style="display:none;">
        <div id="qr_scan_modal_status" style="margin-top:8px; font-size:13px; color:#0b3a7a; font-weight:700;"></div>
      </div>
    </div>

    <div style="margin-top:6px;">
      <div style="font-weight:700; margin:8px 0 6px;">Import manuel</div>
      <textarea id="qr_scan_text" rows="5" style="width:100%; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px;" placeholder='{"type":"diver","firstName":"Jean","lastName":"Dupont","aptitude":"PA60","certification":"FFESSM N3","license":"12345"}'></textarea>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
        <button type="button" class="btn btn-primary" id="btn_qr_scan_import">Importer</button>
        <button type="button" class="btn" id="btn_qr_scan_clear">Effacer</button>
      </div>
    </div>

    <div id="qr_scan_modal_status" class="status-text" style="margin-top:10px;"></div>
  </div>
</div>
<!-- /QR SCAN MODAL -->

</div> <!-- /container -->

<!-- Librairies pour capture HTML → PDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>

  const STORAGE_KEY_FICHE = "seaAngel_fichePlongee_v2";
  const DIVER_LIBRARY_KEY = "seaAngel_divers_library_v1";
  const CERT_LIBRARY_KEY  = "seaAngel_cert_library_v1";
  const SITE_LIBRARY_KEY  = "seaAngel_site_library_v1";
  const DIVERS_DU_JOUR_KEY = "seaAngel_diversDuJour_v1";
  const GROUP_ASSIGN_KEY   = "seaAngel_groupAssignments_v1";


  const RECENT_DIVERS_KEY   = "seaAngel_recentDivers_v1";

  const CENTER_CFG_KEY      = "seaAngel_center_cfg_v1";


  // =========================
  // Centre (nom + id + option bateaux)
  // =========================
  function genCenterId() {
    try {
      const a = new Uint8Array(8);
      (crypto && crypto.getRandomValues) ? crypto.getRandomValues(a) : a.fill(Math.floor(Math.random()*255));
      return "C" + Array.from(a).map(x=>x.toString(16).padStart(2,"0")).join("").toUpperCase();
    } catch(e) {
      return "C" + String(Math.random()).slice(2,10) + String(Date.now()).slice(-4);
    }
  }

  function loadCenterCfg() {
    try {
      const raw = localStorage.getItem(CENTER_CFG_KEY);
      const o = raw ? JSON.parse(raw) : null;
      if (!o || typeof o !== "object") return null;
      return {
        id: (o.id || "").trim(),
        name: (o.name || "").trim(),
        boatsN: Math.max(1, Math.min(8, Number(o.boatsN || 1) || 1))
      };
    } catch(e) { return null; }
  }

  function saveCenterCfg(cfg) {
    try {
      const out = {
        id: (cfg?.id || "").trim(),
        name: (cfg?.name || "").trim(),
        boatsN: Math.max(1, Math.min(8, Number(cfg?.boatsN || 1) || 1))
      };
      localStorage.setItem(CENTER_CFG_KEY, JSON.stringify(out));
      return true;
    } catch(e) { return false; }
  }

  function getCenterDisplayName() {
    const c = loadCenterCfg();
    return (c && c.name) ? c.name : "—";
  }

  function openCenterSetupModal(forceNewId) {
    // Ensure splash is not blocking interactions
    try {
      const __s = document.getElementById('app_splash');
      if (__s){ __s.classList.add('hide'); __s.style.pointerEvents='none'; __s.style.display='none'; }
    } catch(e) {}

    const overlay = document.getElementById("centerSetupModal");
    if (!overlay) return;

    const nameEl = document.getElementById("center_name_input");
    const boatsEl = document.getElementById("center_boats_input");
    const idEl = document.getElementById("center_id_input");

    const cfg = loadCenterCfg() || {};
    if (nameEl) nameEl.value = cfg.name || "";
    if (boatsEl) boatsEl.value = String(cfg.boatsN || 1);
    const cid = (forceNewId ? "" : (cfg.id || ""));
    if (idEl) idEl.value = cid ? cid : genCenterId();

    overlay.style.display = "flex";
  }

  function closeCenterSetupModal() {
    const overlay = document.getElementById("centerSetupModal");
    if (overlay) overlay.style.display = "none";
  }

  // Return true if ok; if missing, opens modal and returns false.
  function ensureCenterCfgOrPrompt() {
    const cfg = loadCenterCfg();
    if (cfg && cfg.name && cfg.id) return true;
    openCenterSetupModal(false);
    return false;
  }

  const FAVORITE_DIVERS_KEY = "seaAngel_favoriteDivers_v1";
  const MAX_GROUPS = 20;

  const GROUP_LEADER_KEY   = "seaAngel_groupLeaders_v1";
  const GROUP_DETAILS_KEY = "seaAngel_groupDetails_v1";

  const GROUP_PRACTICE_KEY = "seaAngel_groupPractice_v1";
  const GROUP_SUPERVISOR_KEY = "seaAngel_groupSupervisors_v1";
  const INSTRUCTOR_LIBRARY_KEY = "seaAngel_instructorLibrary_v1";


  // Structure en mémoire :
  // groupDetails = {
  //   G1: { before: {...}, after: {...} },
  //   G2: { ... }
  // }
  let groupDetails = {};

// Liste des groupes logiques...
  const GROUP_IDS = ["G1"];

  const BASE_DIVERS = [
    { name: "Christian Biancheri", licence: "", cert: "TDI CCR Advanced Mixed Gas", aptitudes: "DP, E4, PTH 100m CCR" },
    { name: "Stéphane Le Béchec", licence: "", cert: "", aptitudes: "" },
    { name: "Invité 1", licence: "", cert: "", aptitudes: "" },
    { name: "Invité 2", licence: "", cert: "", aptitudes: "" }
  ];
  
  let diverLibrary = [];
  window.diverLibrary = diverLibrary; // DEBUG: expose en console
  let certLibrary = [];
  let diversDuJour = [];
  let showMissingPalierWarnings = false; // warnings rouges paliers uniquement après validation

  // PDJ tools state (view + aptitude filter)
  let pdjView = "ALL";      // "ALL" | "RECENT" | "FAV"
  let pdjAptFilter = "";    //
  let pdjSearchQuery = ""; // recherche texte (PDJ) valeur brute d.aptitudes
  let recentDivers = [];
  let favoriteDivers = [];

  let pdjToolsInitDone = false;

  // ===== PDJ / DiverLibrary invariants =====

  let pdjAptOptionsDirty = true;

  // Normalisation unique d’un plongeur
  function normalizeDiverRecord(d) {
    if (!d || typeof d !== "object") return d;

    // id
    if (!d.id) {
      d.id = "diver_" + Math.random().toString(36).slice(2, 10);
    }

    // aptitude legacy -> aptitudes
    if (d.aptitude && !d.aptitudes) {
      d.aptitudes = d.aptitude;
      delete d.aptitude;
    }

    // defaults string
    d.aptitudes = (d.aptitudes || "").toString().trim();
    d.cert = (d.cert || "").toString().trim();
    d.licence = (d.licence || "").toString().trim();

    return d;
  }

  // À appeler APRÈS toute mutation diverLibrary
  function pdjAfterDiverLibraryMutation() {
    pdjAptOptionsDirty = true;
    pdjAptFilter = "";
    pdjView = "ALL";

    const sel = document.getElementById("pdj_filter_apt");
    if (sel) sel.value = "";
  }


   let groupAssignments = {};
  GROUP_IDS.forEach(id => {
    groupAssignments[id] = [];
  });

  let groupLeaders = {};

let groupPractice = {};
let groupSupervisors = {};
let instructorLibrary = [];
let groupMetaOpen = {}; // UI-only: details panel open/closed per group


  let currentDraggedDiver = null;

  const BASE_CERTS = [
  "TDI Advanced Nitrox",
  "TDI Deco Procedures",
  "TDI Trimix",
  "TDI Advanced Trimix",
  "TDI CCR Air Diluent",
  "TDI CCR Air Diluent Deco",
  "TDI CCR Mixed Gas",
  "TDI CCR Advanced Mixed Gas",
  "IANTD Advanced Nitrox",
  "IANTD Normoxic Trimix",
  "IANTD Trimix",
  "IANTD Advanced Trimix",
  "IANTD CCR Diluent Diver",
  "IANTD CCR Normoxic Trimix Diver",
  "IANTD CCR Trimix Diver",
  "FFESSM N1",
  "FFESSM N2",
  "FFESSM N3",
  "FFESSM Trimix Élémentaire",
  "FFESSM Trimix Confirmé"
  ];


  function saveFiche() {
    try {
      const data = {};
      document.querySelectorAll("input, textarea, select").forEach(el => {
        if (!el.id) return;
        if (el.type === "checkbox" || el.type === "radio") {
          data[el.id] = el.checked;
        } else {
          data[el.id] = el.value;
        }
      });
      localStorage.setItem(STORAGE_KEY_FICHE, JSON.stringify(data));
    } catch (e) {
      console.warn("saveFiche error:", e);
    }
  }

  function loadFiche() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY_FICHE);
      if (!raw) return;
      const data = JSON.parse(raw);
      Object.keys(data).forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        if (el.type === "checkbox" || el.type === "radio") {
          el.checked = !!data[id];
        } else {
          el.value = data[id];
        }
      });
    } catch (e) {
      console.warn("loadFiche error:", e);
    }
  }

    function clearFiche() {
    // 1) Effacer les champs texte / dates / etc.
    document.querySelectorAll("input[type='text'], input[type='number'], textarea").forEach(function (el) {
      // Keep day-constants (DP / bateau / sécurité surface) across reset
      if (el && (el.id === "dive_const_dp" || el.id === "dive_const_boat" || el.id === "dive_const_surface")) return;
      el.value = "";
    });

    // 2) Effacer les checkbox
    document.querySelectorAll("input[type='checkbox']").forEach(function (el) {
      el.checked = false;
    });

    // 3) Effacer les select
    document.querySelectorAll("select").forEach(function (el) {
      el.selectedIndex = 0;
    });

    // 4) Réinitialiser les structures en mémoire
    diversDuJour = [];              // ✅ bon nom de variable
    saveDiversDuJour();
   if (typeof updateRecentFromSelection === "function") {
  updateRecentFromSelection([]);
}
    showMissingPalierWarnings = false;

    groupAssignments = {};
    groupLeaders = {};

    // IMPORTANT : remettre la liste des groupes à un seul groupe : G1
    // (GROUP_IDS est const, on modifie son contenu)
    GROUP_IDS.splice(0, GROUP_IDS.length, "G1");

    // 5) Nettoyer le DOM des groupes supplémentaires (G2, G3, …)
    const mainRow = document.getElementById("group-main-row");
    if (mainRow) {
      const cols = Array.from(mainRow.querySelectorAll(".group-column"));
      cols.forEach(col => {
        const gid = col.getAttribute("data-group");
        if (gid && gid !== "G1") {
          mainRow.removeChild(col);
        }
      });
    }

    // 6) Réinitialiser les affectations pour les groupes existants (ici seulement G1)
    resetGroupAssignments();
    saveGroupAssignments();
    saveGroupLeaders();

    // 7) Re-rendu de l’UI des groupes
    renderGroupAssignments();
    setupGroupDropZones();
    updateGroupStatus();

    // G4: Export QR par bateau (wiring UI)
    try { ensureGaExportQrWiring(); } catch(e) {}

    initGroupModeUI();
    updateGroupHeadersWithLeaders();

    
    renderValidationBanner();
// 8) Effacer le preview PDF
    const pdfPreview = document.getElementById("pdf-preview");
    if (pdfPreview) {
      pdfPreview.innerHTML = "";
    }

   // 9) Effacer le localStorage spécifique
    try {
      localStorage.removeItem(STORAGE_KEY_FICHE);     // ✅ bon nom
      localStorage.removeItem(DIVERS_DU_JOUR_KEY);
      localStorage.removeItem(GROUP_ASSIGN_KEY);
      localStorage.removeItem(GROUP_LEADER_KEY);
      localStorage.removeItem(GROUP_PRACTICE_KEY);
      localStorage.removeItem(GROUP_SUPERVISOR_KEY);
    } catch (e) {
      console.warn("clearFiche localStorage error:", e);
    }

    // 10) Statut d’info
    updatePlongeursJourStatus();
    // 10-bis) Effacer les données Avant/Après
    try {
      localStorage.removeItem(GROUP_DETAILS_KEY);
      groupDetails = {};
    } catch(e) {
      console.warn("clearFiche groupDetails error:", e);
    }
   // 11) Repositionner automatiquement la date du jour
   const today = new Date().toLocaleDateString("fr-FR", {
     weekday: "long",
     day: "numeric",
     month: "long",
     year: "numeric"
   });

   // Pour Avant Plongée
   const beforeDate = document.getElementById("group_before_date");
   if (beforeDate) beforeDate.value = today;

   // Pour Après Plongée
   const afterDate = document.getElementById("group_after_date");
   if (afterDate) afterDate.value = today;

   // 12) Reset d’affichage (évite état bloqué entre Plongeurs du jour / Groupes)
   showMissingPalierWarnings = false;
   currentGroupId = null;
   pdjView = "ALL";
   try { showMainLayout(currentGroupId); } catch(e) {}
   try { updateGpsNavDisplay();
    renderPlongeursDuJourSelector(); } catch(e) {}
   try { renderGroupAssignments(); setupGroupDropZones(); updateGroupHeadersWithLeaders(); initGroupModeUI(); updateGroupStatus(); } catch(e) {}

  }

  // ==========================
  // Storage helper: localStorage + IndexedDB fallback (iOS/PWA persistence)
  // Objectif: éviter la perte de bibliothèque sur iPhone quand localStorage est purgé/limité.
  // ==========================
  const IDB_NAME_DLOG = "divinglog_db_v1";
  const IDB_STORE_DLOG = "kv";
  function ensurePersistentStorageDlog() {
    // Best effort: request persistent storage (helps iOS/Safari/PWA retain data)
    try {
      if (navigator.storage && typeof navigator.storage.persist === "function") {
        navigator.storage.persist().then((granted) => {
          try { console.log("storage.persist granted:", granted); } catch(_) {}
        }).catch(()=>{});
      }
    } catch (e) {}
  }


  function idbOpenDlog() {
    return new Promise((resolve, reject) => {
      try {
        if (typeof indexedDB === "undefined") return reject(new Error("indexedDB unavailable"));
        const req = indexedDB.open(IDB_NAME_DLOG, 1);
        req.onupgradeneeded = () => {
          try {
            const db = req.result;
            if (!db.objectStoreNames.contains(IDB_STORE_DLOG)) db.createObjectStore(IDB_STORE_DLOG);
          } catch (e) {}
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error || new Error("indexedDB open error"));
      } catch (e) { reject(e); }
    });
  }

  function idbSetDlog(key, value) {
    return idbOpenDlog().then(db => new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(IDB_STORE_DLOG, "readwrite");
        const store = tx.objectStore(IDB_STORE_DLOG);
        store.put(value, key);
        tx.oncomplete = () => { try { db.close(); } catch(_) {} resolve(true); };
        tx.onerror = () => { try { db.close(); } catch(_) {} reject(tx.error || new Error("idb tx error")); };
      } catch (e) { try { db.close(); } catch(_) {} reject(e); }
    }));
  }

  function idbGetDlog(key) {
    return idbOpenDlog().then(db => new Promise((resolve, reject) => {
      try {
        const tx = db.transaction(IDB_STORE_DLOG, "readonly");
        const store = tx.objectStore(IDB_STORE_DLOG);
        const req = store.get(key);
        req.onsuccess = () => { try { db.close(); } catch(_) {} resolve(req.result); };
        req.onerror = () => { try { db.close(); } catch(_) {} reject(req.error || new Error("idb get error")); };
      } catch (e) { try { db.close(); } catch(_) {} reject(e); }
    }));
  }


  function loadDiverLibrary() {
    // 1) Essai localStorage (synchrone)
    try {
      const raw = localStorage.getItem(DIVER_LIBRARY_KEY);
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          arr.forEach(normalizeDiverRecord);
          diverLibrary = arr;
          window.diverLibrary = diverLibrary; // DEBUG: expose en console
          pdjAptOptionsDirty = true;
          return;
        }
      }
    } catch (e) {
      console.warn("loadDiverLibrary (localStorage) error:", e);
    }

    // 2) Fallback immédiat: BASE_DIVERS (NE PAS sauvegarder tout de suite — sinon on écrase un backup IDB)
    diverLibrary = (Array.isArray(BASE_DIVERS) ? BASE_DIVERS.slice() : [])
      .map(d => normalizeDiverRecord({ ...(d||{}) }));
    window.diverLibrary = diverLibrary; // DEBUG
    pdjAptOptionsDirty = true;
    try { renderPlongeursDuJourSelector(); } catch(_) {}

    // 3) Fallback persistant iOS: IndexedDB (asynchrone)
    //    - Si IDB contient une bibliothèque → on l’applique et on re-render.
    //    - Sinon → on initialise le stockage (save) avec BASE_DIVERS.
    try {
      idbGetDlog("diverLibrary").then((arr) => {
        if (Array.isArray(arr) && arr.length > 0) {
          try { arr.forEach(normalizeDiverRecord); } catch(_) {}
          diverLibrary = arr;
          window.diverLibrary = diverLibrary;
          pdjAptOptionsDirty = true;
          try { renderPlongeursDuJourSelector(); } catch(_) {}
          return;
        }
        // pas de backup → initialiser la persistance avec la base
        try { saveDiverLibrary(); } catch(_) {}
      }).catch(() => {
        // IDB indisponible → on reste sur BASE_DIVERS (non persistant)
      });
    } catch (e) {
      // ignore
    }
  }




  function saveDiverLibrary() {
    // Sauvegarde "best effort" : localStorage + IndexedDB fallback
    let okLS = false;
    try {
      localStorage.setItem(DIVER_LIBRARY_KEY, JSON.stringify(diverLibrary));
      okLS = true;
    } catch (e) {
      console.warn("saveDiverLibrary (localStorage) error:", e);
    }

    // iOS/PWA: IndexedDB est souvent plus persistant que localStorage
    try { idbSetDlog("diverLibrary", diverLibrary).catch(()=>{}); } catch(_) {}

    // Feedback doux si localStorage est KO (sinon l’utilisateur pense que l’import a été perdu)
    if (!okLS) {
      try { toast && toast("⚠️ Stockage iPhone limité: sauvegarde via IndexedDB (plus robuste)."); } catch(_) {}
    }
  }



  // --- Bibliothèque de certifications (certLibrary) ---

  function loadCertLibrary() {
    try {
      const raw = localStorage.getItem(CERT_LIBRARY_KEY);
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          certLibrary = arr;
          return;
        }
      }
    } catch (e) {
      console.warn("loadCertLibrary error:", e);
    }

    // Si rien en mémoire → utiliser la base
    certLibrary = BASE_CERTS.slice();
    saveCertLibrary();
  }


  function saveCertLibrary() {
    try {
      localStorage.setItem(CERT_LIBRARY_KEY, JSON.stringify(certLibrary));
    } catch (e) {
      console.warn("saveCertLibrary error:", e);
    }
  }

function populateAddDiverCertSelect() {
    const sel = document.getElementById("add_diver_cert_select");
    if (!sel) return;

    // reset
    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Sélectionner une certification";
    sel.appendChild(opt0);

    if (!Array.isArray(certLibrary) || certLibrary.length === 0) {
      loadCertLibrary();
    }

    certLibrary.forEach(c => {
      if (!c) return;
      const opt = document.createElement("option");
      opt.value = c;
      opt.textContent = c;
      sel.appendChild(opt);
    });

    const optOther = document.createElement("option");
    optOther.value = "Autre";
    optOther.textContent = "Autre (manuel)";
    sel.appendChild(optOther);
  }

  function normalizeName(str) {
    return String(str || "").trim().toLowerCase();
  }

  function setAddDiverStatus(msg) {
    const el = document.getElementById("add-diver-status");
    if (el) el.textContent = msg || "";
  }

  function toggleAddDiverManualFields() {
    const certSel = document.getElementById("add_diver_cert_select");
    const certWrap = document.getElementById("add_diver_cert_manual_wrap");
    const certManual = document.getElementById("add_diver_cert_manual");
    if (certSel && certWrap && certManual) {
      const show = (certSel.value === "Autre");
      certWrap.style.display = show ? "block" : "none";
      if (!show) certManual.value = "";
    }

    const aptSel = document.getElementById("add_diver_aptitude_select");
    const aptWrap = document.getElementById("add_diver_aptitude_manual_wrap");
    const aptManual = document.getElementById("add_diver_aptitude_manual");
    if (aptSel && aptWrap && aptManual) {
      const show = (aptSel.value === "Autre");
      aptWrap.style.display = show ? "block" : "none";
      if (!show) aptManual.value = "";
    }
  }


  function addDiverToLibraryFromForm() {
    const nameEl = document.getElementById("add_diver_name");
    const certSel = document.getElementById("add_diver_cert_select");
    const certManual = document.getElementById("add_diver_cert_manual");
    const aptSel = document.getElementById("add_diver_aptitude_select");
    const aptManual = document.getElementById("add_diver_aptitude_manual");

    const name = nameEl ? String(nameEl.value || "").trim() : "";
    if (!name) {
      setAddDiverStatus("Nom obligatoire.");
      return;
    }

    const nkey = normalizeName(name);
    if (!Array.isArray(diverLibrary)) diverLibrary = [];
    const exists = diverLibrary.some(d => d && normalizeName(d.name) === nkey);
    if (exists) {
      setAddDiverStatus("Ce plongeur existe déjà dans la bibliothèque.");
      return;
    }

    let cert = "";
    if (certSel) {
      if (certSel.value === "Autre") {
        cert = certManual ? String(certManual.value || "").trim() : "";
      } else {
        cert = String(certSel.value || "").trim();
      }
    }
    // If manual cert is provided, add it to certLibrary (same architecture as FICHE)
    if (cert && Array.isArray(certLibrary)) {
      const hasCert = certLibrary.some(c => String(c).trim() === cert);
      if (!hasCert) {
        certLibrary.push(cert);
        saveCertLibrary();
      }
    }

    let aptitude = "";
    if (aptSel) {
      if (aptSel.value === "Autre") {
        aptitude = aptManual ? String(aptManual.value || "").trim() : "";
      } else {
        aptitude = String(aptSel.value || "").trim();
      }
    }

   const diver = {
     id: "d_" + Date.now() + "_" + Math.random().toString(36).slice(2),
     name: name,
     licence: "",
     cert: cert,
     aptitudes: aptitude
   };

      while (diverLibrary.some(x => x && x.id === diver.id)) {
      diver.id = "d_" + Date.now() + "_" + Math.random().toString(36).slice(2);
    }

    normalizeDiverRecord(diver);
    diverLibrary.push(diver);

    pdjAfterDiverLibraryMutation();
    saveDiverLibrary();

    // UI refresh
    renderPlongeursDuJourSelector();

    // reset form
    if (nameEl) nameEl.value = "";
    if (certSel) certSel.value = "";
    if (certManual) certManual.value = "";
    if (aptSel) aptSel.value = "";
    if (aptManual) aptManual.value = "";
    toggleAddDiverManualFields();
    setAddDiverStatus("Plongeur ajouté.");
  }


  // ==========================
  // EDIT DIVER (manual update)
  // Policy: editing is allowed ONLY before group assignment.
  // A diver is considered "locked" if getCurrentGroupOfDiver(diver.name) returns a group.
  // ==========================

  // Selected diver id for edit workflow (datalist -> form -> save)
  let editDiverSelectedId = null;

  function setEditDiverStatus(msg) {
    const el = document.getElementById("edit-diver-status");
    if (el) el.textContent = msg || "";
  }

  function toggleEditDiverManualFields() {
    const certSel = document.getElementById("edit_diver_cert_select");
    const certWrap = document.getElementById("edit_diver_cert_manual_wrap");
    const certManual = document.getElementById("edit_diver_cert_manual");
    if (certSel && certWrap && certManual) {
      const show = (certSel.value === "Autre");
      certWrap.style.display = show ? "block" : "none";
      if (!show) certManual.value = "";
    }

    const aptSel = document.getElementById("edit_diver_aptitude_select");
    const aptWrap = document.getElementById("edit_diver_aptitude_manual_wrap");
    const aptManual = document.getElementById("edit_diver_aptitude_manual");
    if (aptSel && aptWrap && aptManual) {
      const show = (aptSel.value === "Autre");
      aptWrap.style.display = show ? "block" : "none";
      if (!show) aptManual.value = "";
    }
  }

  function isDiverLockedForEdit(diverName) {
    // Uses existing function in this file.
    return !!getCurrentGroupOfDiver(diverName);
  }

  function populateEditDiverCertSelect() {
    const sel = document.getElementById("edit_diver_cert_select");
    if (!sel) return;

    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Sélectionner une certification";
    sel.appendChild(opt0);

    // Uses existing certLibrary + loadCertLibrary()
    if (!Array.isArray(certLibrary) || certLibrary.length === 0) loadCertLibrary();
    if (Array.isArray(certLibrary)) {
      certLibrary.forEach(c => {
        if (!c) return;
        const opt = document.createElement("option");
        opt.value = c;
        opt.textContent = c;
        sel.appendChild(opt);
      });
    }

    const optOther = document.createElement("option");
    optOther.value = "Autre";
    optOther.textContent = "Autre (manuel)";
    sel.appendChild(optOther);
  }

  
  // DATALIST autocomplete for edit diver (same UX as DP)
  function refreshEditDiverDatalist(filterText) {
    const dl = document.getElementById("diver_list");
    if (!dl) return;

    const q = String(filterText || "").trim().toLowerCase();
    dl.innerHTML = "";

    const list = Array.isArray(diverLibrary) ? diverLibrary : [];
    list
      .filter(d => d && d.id && d.name)
      .filter(d => {
        if (!q) return true;
        const name = String(d.name || "").toLowerCase();
        const lic  = String(d.licence || "").toLowerCase();
        return name.includes(q) || lic.includes(q);
      })
      .sort((a,b)=> String(a.name||"").localeCompare(String(b.name||"")))
      .forEach(d => {
        const opt = document.createElement("option");
        // Value shown in the autocomplete list (unique-ish)
        const val = (d.name || "—") + (d.licence ? (" — " + d.licence) : "");
        opt.value = val;
        opt.dataset.id = d.id;
        dl.appendChild(opt);
      });
  }

  function resolveEditDiverAutocompleteValue(val) {
    const v = String(val || "").trim();
    if (!v) return null;

    // 1) exact match on datalist option -> dataset.id
    const dl = document.getElementById("diver_list");
    if (dl) {
      const opt = Array.from(dl.querySelectorAll("option")).find(o => String(o.value || "") === v);
      const id = opt && opt.dataset ? opt.dataset.id : "";
      if (id) return getDiverById(id);
    }

    // 2) fallback: parse "Name — licence"
    const parts = v.split("—").map(s => String(s || "").trim()).filter(Boolean);
    const nameGuess = parts.length ? parts[0] : v;
    const licGuess = (parts.length >= 2) ? parts[1] : "";

    const list = Array.isArray(diverLibrary) ? diverLibrary : [];
    let hit = list.find(d => d && String(d.name||"").trim() === nameGuess && (!licGuess || String(d.licence||"").trim() === licGuess));
    if (!hit) hit = list.find(d => d && String(d.name||"").toLowerCase() === nameGuess.toLowerCase());
    return hit || null;
  }

function getDiverById(diverId) {
    const list = Array.isArray(diverLibrary) ? diverLibrary : [];
    return list.find(d => d && d.id === diverId) || null;
  }

  function fillEditFormFromDiver(diver) {
    if (!diver) return;

    // remember current selection for save
    editDiverSelectedId = diver.id || null;

    if (isDiverLockedForEdit(diver.name)) {
      setEditDiverStatus("Plongeur déjà affecté à un groupe : modification verrouillée.");
      return;
    }

    const nameEl = document.getElementById("edit_diver_name");
    const licEl  = document.getElementById("edit_diver_licence");
    const aptSel = document.getElementById("edit_diver_aptitude_select");
    const aptMan = document.getElementById("edit_diver_aptitude_manual");
    const certSel= document.getElementById("edit_diver_cert_select");
    const certMan= document.getElementById("edit_diver_cert_manual");

    if (nameEl) nameEl.value = diver.name || "";
    if (licEl)  licEl.value  = diver.licence || "";

    const apt = String(diver.aptitudes || "").trim();
    if (aptSel) {
      const hasOpt = Array.from(aptSel.options).some(o => o.value === apt);
      if (apt && hasOpt) {
        aptSel.value = apt;
        if (aptMan) aptMan.value = "";
      } else if (apt) {
        aptSel.value = "Autre";
        if (aptMan) aptMan.value = apt;
      } else {
        aptSel.value = "";
        if (aptMan) aptMan.value = "";
      }
    }

    const cert = String(diver.cert || "").trim();
    if (certSel) {
      const hasOpt = Array.from(certSel.options).some(o => o.value === cert);
      if (cert && hasOpt) {
        certSel.value = cert;
        if (certMan) certMan.value = "";
      } else if (cert) {
        certSel.value = "Autre";
        if (certMan) certMan.value = cert;
      } else {
        certSel.value = "";
        if (certMan) certMan.value = "";
      }
    }

    toggleEditDiverManualFields();
    setEditDiverStatus("");
  }

  function editDiverInLibraryFromForm() {
    // The UI uses an <input list="diver_list"> (autocomplete), so we keep the selected diver id in memory.
    if (!editDiverSelectedId) {
      setEditDiverStatus("Sélectionne un plongeur (via la recherche/autocomplete)." );
      return;
    }

    const diver = getDiverById(editDiverSelectedId);
    if (!diver) {
      setEditDiverStatus("Plongeur introuvable.");
      return;
    }

    // Re-check lock at save time
    if (isDiverLockedForEdit(diver.name)) {
      setEditDiverStatus("Plongeur déjà affecté à un groupe : modification verrouillée.");
      return;
    }

    const nameEl = document.getElementById("edit_diver_name");
    const licEl  = document.getElementById("edit_diver_licence");
    const aptSel = document.getElementById("edit_diver_aptitude_select");
    const aptMan = document.getElementById("edit_diver_aptitude_manual");
    const certSel= document.getElementById("edit_diver_cert_select");
    const certMan= document.getElementById("edit_diver_cert_manual");

    const newName = nameEl ? String(nameEl.value || "").trim() : "";
    if (!newName) {
      setEditDiverStatus("Nom obligatoire.");
      return;
    }

    // avoid name collisions (same rule as add)
    const newKey = normalizeName(newName);
    const list = Array.isArray(diverLibrary) ? diverLibrary : [];
    const collision = list.some(d => d && d.id !== diver.id && normalizeName(d.name) === newKey);
    if (collision) {
      setEditDiverStatus("Un autre plongeur a déjà ce nom.");
      return;
    }

    const newLicence = licEl ? String(licEl.value || "").trim() : "";

    let newApt = "";
    if (aptSel) {
      if (aptSel.value === "Autre") newApt = aptMan ? String(aptMan.value || "").trim() : "";
      else newApt = String(aptSel.value || "").trim();
    }

    let newCert = "";
    if (certSel) {
      if (certSel.value === "Autre") newCert = certMan ? String(certMan.value || "").trim() : "";
      else newCert = String(certSel.value || "").trim();
    }

    // If manual cert: enrich library using existing saveCertLibrary()
    if (newCert && Array.isArray(certLibrary)) {
      const has = certLibrary.some(c => String(c).trim() === newCert);
      if (!has) {
        certLibrary.push(newCert);
        saveCertLibrary();
        populateAddDiverCertSelect();
        populateEditDiverCertSelect();
      }
    }

    // Apply
    diver.name = newName;
    diver.licence = newLicence;
    diver.aptitudes = newApt;
    diver.cert = newCert;

    normalizeDiverRecord(diver);

    pdjAfterDiverLibraryMutation();
    saveDiverLibrary();

    // UI refresh (existing functions)
    renderPlongeursDuJourSelector();
    renderGroupAssignments();

    setEditDiverStatus("Plongeur modifié.");
  }

  function loadDiversDuJour() {
    diversDuJour = [];
    try {
      const raw = localStorage.getItem(DIVERS_DU_JOUR_KEY);
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          diversDuJour = arr;
        }
      }
    } catch (e) {
      console.warn("loadDiversDuJour error:", e);
      diversDuJour = [];
    }
  }

  function saveDiversDuJour() {
  try {
    localStorage.setItem(DIVERS_DU_JOUR_KEY, JSON.stringify(diversDuJour));
  } catch (e) {
    console.warn("saveDiversDuJour error:", e);
  }
}

// --- PDJ Units (Bateau 1..N) : day-level mapping (NOT in diverLibrary) ---
const DIVERS_DU_JOUR_UNITS_KEY = "seaAngel_diversDuJourUnits_v1";
let diversDuJourUnits = {}; // { "<diverName>": "B1" | "B2" | ... }

function getCenterBoatsN() {
  const cfg = loadCenterCfg && loadCenterCfg();
  const n = cfg && Number(cfg.boatsN);
  return Math.max(1, Math.min(8, n || 1));
}

function normalizeUnitId(unitId) {
  if (!unitId) return "";
  const s = String(unitId).trim().toUpperCase();
  if (!/^B\d+$/.test(s)) return "";
  const k = Number(s.slice(1));
  if (!Number.isFinite(k)) return "";
  const n = getCenterBoatsN();
  if (k < 1 || k > n) return "";
  return "B" + k;
}

function loadDiversDuJourUnits() {
  try {
    const raw = localStorage.getItem(DIVERS_DU_JOUR_UNITS_KEY);
    const o = raw ? JSON.parse(raw) : null;
    if (o && typeof o === "object" && !Array.isArray(o)) {
      diversDuJourUnits = o;
    } else {
      diversDuJourUnits = {};
    }
  } catch (e) {
    diversDuJourUnits = {};
  }
}

function saveDiversDuJourUnits() {
  try {
    localStorage.setItem(
      DIVERS_DU_JOUR_UNITS_KEY,
      JSON.stringify(diversDuJourUnits || {})
    );
  } catch (e) {
    console.warn("saveDiversDuJourUnits error:", e);
  }
}

function applyUnitToAllPDJ(unitId) {
  const u = normalizeUnitId(unitId);
  if (!Array.isArray(diversDuJour)) return;

  diversDuJour.forEach(name => {
    if (!name) return;
    if (u) diversDuJourUnits[name] = u;
    else delete diversDuJourUnits[name];
  });

  saveDiversDuJourUnits();
}

function clearUnitsForAllPDJ() {
  if (!Array.isArray(diversDuJour)) return;
  diversDuJour.forEach(name => {
    if (!name) return;
    delete diversDuJourUnits[name];
  });
  saveDiversDuJourUnits();
}

// ==========================
// G4 — Export QR par bateau (PDJ filtré par unité)
// ==========================
const MAX_DIVERS_PER_QR = 25;
// Hard cap on QR payload size (helps scan reliability on phones)
const MAX_QR_CHARS = 1500;
// Rendered QR image size (bigger = easier to scan)
const QR_IMG_SIZE = 480;

function buildBoatManifest(boatId) {
  const b = normalizeUnitId(boatId);
  if (!b) return [];
  const names = Array.isArray(diversDuJour) ? diversDuJour : [];
  const out = [];
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (!name) continue;
    if (normalizeUnitId(diversDuJourUnits && diversDuJourUnits[name]) !== b) continue;

    // Prefer library fields if present, but always include name
    const d = (Array.isArray(diverLibrary) ? diverLibrary.find(x => x && x.name === name) : null) || {};
    out.push({
      name: name,
      aptitudes: String(d.aptitudes || "").trim(),
      cert: String(d.cert || "").trim(),
      licence: String(d.licence || "").trim()
    });
  }
  return out;
}

function buildQrPayloadForBoat(boatId) {
  const cfg = (typeof loadCenterCfg === "function") ? loadCenterCfg() : {};
  const centerName = cfg && (cfg.name || cfg.centerName) ? String(cfg.name || cfg.centerName) : "";
  const centerId   = cfg && (cfg.id || cfg.centerId) ? String(cfg.id || cfg.centerId) : "";

  return {
    v: 1,
    type: "pdj_boat_manifest",
    center: { name: centerName, id: centerId },
    boat: normalizeUnitId(boatId),
    exportedAt: new Date().toISOString(),
    divers: buildBoatManifest(boatId)
  };
}

function splitPayloadForQr(payload) {
  const arr = (payload && Array.isArray(payload.divers)) ? payload.divers : [];
  if (!arr.length) return [payload];

  // Split by *string length* (QR density) and also keep a sane max per page.
  const pages = [];
  let chunk = [];
  let startIdx = 0;

  const makePage = (divers, partLabel) => {
    const o = { ...payload, divers: divers.slice() };
    if (partLabel) o.part = partLabel;
    return o;
  };

  const fits = (divers) => {
    try {
      const probe = makePage(divers, "");
      const s = JSON.stringify(probe);
      return s.length <= MAX_QR_CHARS;
    } catch (e) {
      return false;
    }
  };

  for (let i = 0; i < arr.length; i++) {
    const d = arr[i];
    const test = chunk.concat([d]);

    // also cap by count to avoid absurd pages even if small
    const overCount = test.length > MAX_DIVERS_PER_QR;
    const overChars = !fits(test);

    if (chunk.length && (overCount || overChars)) {
      pages.push(makePage(chunk, "")); // part filled later
      chunk = [d];
      startIdx = i;
    } else {
      chunk = test;
    }
  }
  if (chunk.length) pages.push(makePage(chunk, ""));

  if (pages.length <= 1) return pages;

  // Fill part labels
  const total = pages.length;
  for (let i = 0; i < pages.length; i++) {
    pages[i].part = (i + 1) + "/" + total;
  }
  return pages;
}

let gaQrPages = [];
let gaQrIndex = 0;
let gaExportWired = false;

// =====================================================
// A1 LOCK: Export QR must be URL-only (camera native friendly).
// Any attempt to render JSON in a QR is a hard error.
// =====================================================
function gaAssertQrUrlOnly(u){
  if (typeof u !== "string") throw new Error("SECURITY: QR export must be a URL string");
  const s = u.trim();
  if (!s) throw new Error("SECURITY: QR export URL empty");
  if (s[0] === "{" || s[0] === "[") throw new Error("SECURITY: QR export must not embed JSON");
  if (!/^https?:\/\//i.test(s)) throw new Error("SECURITY: QR export must be an absolute URL");
  if (!/[?#&]import=([^&]+)/.test(s)) throw new Error("SECURITY: QR export URL missing import= token");
  return s;
}

function renderCurrentGaQr() {
  const status = document.getElementById("ga_export_qr_status");
  const img = document.getElementById("ga_export_qr_img");
  const label = document.getElementById("ga_qr_page_label");
  if (!img || !label) return;

  if (!gaQrPages.length) {
    label.textContent = "";
    img.removeAttribute("src");
    return;
  }

  label.textContent = (gaQrPages.length > 1)
    ? ("QR " + (gaQrIndex + 1) + " / " + gaQrPages.length)
    : "";

  try {
    const page = gaQrPages[gaQrIndex];
    const url = gaAssertQrUrlOnly(page);
    // Use remote image QR generator: no CDN JS, works in file:// and https
    img.src = "https://api.qrserver.com/v1/create-qr-code/?size="+QR_IMG_SIZE+"x"+QR_IMG_SIZE+"&data=" + encodeURIComponent(url);
    if (status) status.textContent = "QR URL généré.";
  } catch (e) {
    console.warn("QR render error:", e);
    if (status) status.textContent = "Erreur génération QR (URL only).";
  }
}



function ensureGaExportQrWiring() {
  if (gaExportWired) return;

  const sel = document.getElementById("ga_export_boat_sel");
  const btn = document.getElementById("btn_ga_export_qr");
  const wrap = document.getElementById("ga_export_qr_wrap");
  const status = document.getElementById("ga_export_qr_status");
  const btnPrev = document.getElementById("btn_ga_qr_prev");
  const btnNext = document.getElementById("btn_ga_qr_next");

  if (!sel || !btn || !wrap || !status || !btnPrev || !btnNext) return;

  // Populate boats options once
  const n = (typeof getCenterBoatsN === "function") ? getCenterBoatsN() : 1;
  sel.innerHTML = '<option value="">—</option>';
  for (let i = 1; i <= n; i++) {
    const o = document.createElement("option");
    o.value = "B" + i;
    o.textContent = "B" + i;
    sel.appendChild(o);
  }
// Sync default selection with "Bateau (masse)" if present
const selMass = document.getElementById("ga_bulk_boat");
try {
  const massVal = selMass && selMass.value ? String(selMass.value) : "";
  if (massVal && !sel.value) sel.value = massVal;
} catch(e) {}
if (selMass) {
  selMass.addEventListener("change", () => {
    try {
      const massVal = selMass.value ? String(selMass.value) : "";
      if (massVal) sel.value = massVal;
    } catch(e) {}
  });
}


  btn.addEventListener("click", async (ev) => {
    if (ev) ev.stopPropagation();
    const selMass2 = document.getElementById("ga_bulk_boat");
    const boatId = (sel.value || (selMass2 && selMass2.value) || "");
    const payload = buildQrPayloadForBoat(boatId);

    if (!boatId) {
      status.textContent = "Choisir un bateau.";
      wrap.style.display = "none";
      return;
    }
    if (!payload.divers || payload.divers.length === 0) {
      status.textContent = "Aucun plongeur du jour sur " + boatId + ".";
      wrap.style.display = "none";
      return;
    }

    try {
      // 1) Split payload for size safety (kept), then upload each page
      const pages = splitPayloadForQr(payload);
      status.textContent = "⏳ Préparation QR (upload)...";
      wrap.style.display = "none";

      const urls = [];
      for (let i = 0; i < pages.length; i++) {
        const u = await gaUploadQrPageAndMakeUrl(pages[i]);
        gaAssertQrUrlOnly(u);
        urls.push(u);
      }

      gaQrPages = urls;      // now pages are URL strings
      gaQrIndex = 0;

      status.textContent = (gaQrPages.length > 1)
        ? ("QR URL générés : " + gaQrPages.length + " (découpé).")
        : "QR URL généré.";

      wrap.style.display = "block";
      renderCurrentGaQr();
    } catch (e) {
      console.warn("QR URL export error:", e);
      status.textContent = "Erreur export QR (upload).";
      wrap.style.display = "none";
    }
  });

  btnPrev.addEventListener("click", (ev) => {
    if (ev) ev.stopPropagation();
    if (gaQrIndex > 0) {
      gaQrIndex--;
      renderCurrentGaQr();
    }
  });

  btnNext.addEventListener("click", (ev) => {
    if (ev) ev.stopPropagation();
    if (gaQrIndex < gaQrPages.length - 1) {
      gaQrIndex++;
      renderCurrentGaQr();
    }
  });

  gaExportWired = true;
}

function getDiverUnit(diverName) {
  const nm = String(diverName || "").trim();
  if (!nm) return "";
  return normalizeUnitId(diversDuJourUnits && diversDuJourUnits[nm]);
}

function setDiverUnit(diverName, unitId) {
  const nm = String(diverName || "").trim();
  if (!nm) return;
  const u = normalizeUnitId(unitId);
  if (!u) {
    if (diversDuJourUnits && nm in diversDuJourUnits) delete diversDuJourUnits[nm];
  } else {
    if (!diversDuJourUnits || typeof diversDuJourUnits !== "object") diversDuJourUnits = {};
    diversDuJourUnits[nm] = u;
  }
  saveDiversDuJourUnits();
}

// Init day-level units mapping once (safe even if never used)
loadDiversDuJourUnits();



function loadRecentDivers() {
  recentDivers = [];
  try {
    const raw = localStorage.getItem(RECENT_DIVERS_KEY);
    if (raw) {
      const arr = JSON.parse(raw);
      if (Array.isArray(arr)) recentDivers = arr;
    }
  } catch (e) {
    console.warn("loadRecentDivers error:", e);
    recentDivers = [];
  }
}

function saveRecentDivers() {
  try {
    localStorage.setItem(RECENT_DIVERS_KEY, JSON.stringify(recentDivers));
  } catch (e) {
    console.warn("saveRecentDivers error:", e);
  }
}

function loadFavoriteDivers() {
  favoriteDivers = [];
  try {
    const raw = localStorage.getItem(FAVORITE_DIVERS_KEY);
    if (raw) {
      const arr = JSON.parse(raw);
      if (Array.isArray(arr)) favoriteDivers = arr;
    }
  } catch (e) {
    console.warn("loadFavoriteDivers error:", e);
    favoriteDivers = [];
  }
}

function saveFavoriteDivers() {
  try {
    localStorage.setItem(FAVORITE_DIVERS_KEY, JSON.stringify(favoriteDivers));
  } catch (e) {
    console.warn("saveFavoriteDivers error:", e);
  }
}

function isFavoriteDiver(name) {
  return Array.isArray(favoriteDivers) && favoriteDivers.includes(name);
}

function toggleFavoriteDiver(name) {
  if (!name) return;
  if (!Array.isArray(favoriteDivers)) favoriteDivers = [];
  const i = favoriteDivers.indexOf(name);
  if (i >= 0) favoriteDivers.splice(i, 1);
  else favoriteDivers.push(name);
  saveFavoriteDivers();
  renderPlongeursDuJourSelector();
}

function updateRecentFromSelection(selectedNames) {
  if (!Array.isArray(selectedNames)) return;
  if (!Array.isArray(recentDivers)) recentDivers = [];

  const out = [];
  selectedNames.forEach(n => { if (n && !out.includes(n)) out.push(n); });
  recentDivers.forEach(n => { if (n && !out.includes(n)) out.push(n); });

  recentDivers = out.slice(0, 30);
  saveRecentDivers();
}

function initPDJTools() {
  const btnAll = document.getElementById("pdj_view_all");
  const btnRec = document.getElementById("pdj_view_recent");
  const btnFav = document.getElementById("pdj_view_fav");
  const selApt = document.getElementById("pdj_filter_apt");

  const selBoat = document.getElementById("pdj_filter_boat");
  // filtre bateau actif ("" = tous, "__UNASSIGNED__" = non affecté, "B1"..)
  let pdjBoatFilter = "";

  function refreshBoatOptions() {
    if (!selBoat) return;
    const keep = selBoat.value;
    const n = (typeof getCenterBoatsN === "function") ? getCenterBoatsN() : 1;
    // Rebuild options (keep the first two)
    const first0 = selBoat.options[0];
    const first1 = selBoat.options[1];
    selBoat.innerHTML = "";
    selBoat.appendChild(first0);
    selBoat.appendChild(first1);
    for (let i = 1; i <= n; i++) {
      const opt = document.createElement("option");
      opt.value = "B" + i;
      opt.textContent = "Bateau " + i;
      selBoat.appendChild(opt);
    }
    if (keep) selBoat.value = keep;
  }

  if (selBoat) {
    refreshBoatOptions();
    selBoat.addEventListener("change", () => {
      pdjBoatFilter = selBoat.value || "";
      persistPDJSelectionFromDOM();
      renderPlongeursDuJourSelector();
      refreshActive();
    });
  }

  const btnAdd = document.getElementById("pdj_bulk_add");
  const btnRem = document.getElementById("pdj_bulk_remove");
  const inpSearch = document.getElementById("pdj_search");

  // iOS/Safari: datalist updates can freeze UI during fast backspace.
  // We disable datalist for PDJ search (filtering still works).
  try {
    if (inpSearch) inpSearch.removeAttribute('list');
  } catch(_) {}



  // Preserve current checkbox selections when switching view/filter (so "Tous" doesn't drop current picks)
  function persistPDJSelectionFromDOM() {
    const container = document.getElementById("plongeurs-jour-list");
    if (!container) return;

    const set = new Set(Array.isArray(diversDuJour) ? diversDuJour : []);
    container.querySelectorAll("input[type='checkbox']").forEach(cb => {
      const name = cb.dataset.diverName;
      if (!name) return;
      if (cb.checked) set.add(name);
      else set.delete(name);
    });

    diversDuJour = Array.from(set);
    saveDiversDuJour();
  }
  // --- Recherche (datalist) pour Plongeurs du jour (même pattern que DP)
  
  function refreshPDJSearchDatalist(filterText) {
    const dl = document.getElementById("pdj_search_list");
    if (!dl) return;
    const q = String(filterText || "").trim().toLowerCase();
    dl.innerHTML = "";
    const list = Array.isArray(diverLibrary) ? diverLibrary : [];
    list
      .filter(d => d && d.name)
      .filter(d => {
        if (!q) return true;
        const name = String(d.name).toLowerCase();
        const lic = d.licence ? String(d.licence).toLowerCase() : "";
        return name.includes(q) || lic.includes(q);
      })
      .slice(0, 30)
      .forEach(d => {
        const opt = document.createElement("option");
        opt.value = d.name + (d.licence ? (" — " + d.licence) : "");
        dl.appendChild(opt);
      });
  }

  function setView(v) {
    // Keep selections when changing view (ALL/RECENT/FAV)
    persistPDJSelectionFromDOM();
    pdjView = v;


    // Reset recherche quand on repasse sur Tous
    if (v === "ALL") {
      pdjSearchQuery = "";
      if (inpSearch) inpSearch.value = "";
      /*datalist disabled*/;
    }
    // "Tous" = reset des filtres d’affichage (vue + aptitude)
    if (v === "ALL") {
      pdjAptFilter = "";
      if (selApt) selApt.value = ""; // remet le dropdown sur "Aptitude : toutes"
    }

    renderPlongeursDuJourSelector();
    refreshActive();
  }



  function refreshActive() {
    [btnAll, btnRec, btnFav].forEach(b => b && b.classList.remove("is-active"));
    if (pdjView === "ALL" && btnAll) btnAll.classList.add("is-active");
    if (pdjView === "RECENT" && btnRec) btnRec.classList.add("is-active");
    if (pdjView === "FAV" && btnFav) btnFav.classList.add("is-active");
  }

  if (btnAll) btnAll.onclick = () => setView("ALL");
  if (btnRec) btnRec.onclick = () => setView("RECENT");
  if (btnFav) btnFav.onclick = () => setView("FAV");

  if (selApt) {
    selApt.onchange = () => {
      // Keep selections when changing aptitude filter
      persistPDJSelectionFromDOM();
      pdjAptFilter = selApt.value || "";
      renderPlongeursDuJourSelector();
    };
  }
  if (inpSearch) {
    let __pdjSearchTimer = 0;

    inpSearch.addEventListener("input", function () {
      // IMPORTANT: ne pas persister la sélection ici (risque de re-render/lag sur iPhone)
      const raw = String(inpSearch.value || "");
      const q = raw.trim();
      pdjSearchQuery = q;

      if (__pdjSearchTimer) clearTimeout(__pdjSearchTimer);

      // Si l’utilisateur efface tout : reset SANS persistPDJSelectionFromDOM (sinon freeze iPhone)
      if (!pdjSearchQuery) {
        pdjView = "ALL";
        pdjAptFilter = "";
        if (selApt) selApt.value = "";
        /*datalist disabled*/
        __pdjSearchTimer = setTimeout(() => {
          renderPlongeursDuJourSelector();
          refreshActive();
        }, 0);
        return;
      }

      // Datalist: limiter les updates (Safari/iOS peut freezer si on reconstruit à chaque frappe)
      if (pdjSearchQuery.length >= 2) refreshPDJSearchDatalist(pdjSearchQuery);
      else /*datalist disabled*/;

      // Debounce (120ms) pour éviter de rerender à chaque backspace / frappe rapide
      __pdjSearchTimer = setTimeout(() => {
        renderPlongeursDuJourSelector();
      }, 200);
    });
  }



  function bulkSet(checked) {
    const container = document.getElementById("plongeurs-jour-list");
    if (!container) return;
    container.querySelectorAll("input[type='checkbox']").forEach(cb => { cb.checked = checked; });
    handleValidationPlongeursDuJour(); // source de vérité existante
  }

  if (btnAdd) btnAdd.onclick = () => bulkSet(true);
  if (btnRem) btnRem.onclick = () => bulkSet(false);

  initPDJTools._refreshActive = refreshActive;

  // QR Scan button + modal events (safe if elements absent)
  
  // Library Export/Import (safe if elements absent)
  // Library menu ⋯ (safe if elements absent)
  const btnLibMenu = document.getElementById("btn_library_menu");
  const libMenu = document.getElementById("library_menu");
  function closeLibMenu() {
    if (libMenu) libMenu.style.display = "none";
  }
  function toggleLibMenu() {
    if (!libMenu) return;
    libMenu.style.display = (libMenu.style.display === "none" || !libMenu.style.display) ? "block" : "none";
  }
  if (btnLibMenu && libMenu) {
    btnLibMenu.onclick = (ev) => { if (ev) ev.stopPropagation(); toggleLibMenu(); };
    libMenu.addEventListener("click", (ev) => { if (ev) ev.stopPropagation(); });
    document.addEventListener("click", closeLibMenu);
    document.addEventListener("keydown", (ev) => { if (ev && ev.key === "Escape") closeLibMenu(); });
  }

  const btnExpLib = document.getElementById("btn_export_library");
  if (btnExpLib) btnExpLib.onclick = () => { try{ closeLibMenu(); }catch(_){} exportDivinglogLibrary(); };

  const btnImpLib = document.getElementById("btn_import_library");
  const fileImpLib = document.getElementById("file_import_library");
  if (btnImpLib && fileImpLib) {
    btnImpLib.onclick = () => { try{ closeLibMenu(); }catch(_){} try { fileImpLib.value = ""; } catch(_){} fileImpLib.click(); };
    fileImpLib.onchange = () => {
      const f = fileImpLib.files && fileImpLib.files[0];
      if (f) importDivinglogLibraryFromFile(f);
    };
  }


  const btnImpCsv = document.getElementById("btn_import_csv");
  const fileImpCsv = document.getElementById("file_import_csv");
  if (btnImpCsv && fileImpCsv) {
    btnImpCsv.onclick = () => { try{ closeLibMenu(); }catch(_){} try { fileImpCsv.value = ""; } catch(_){} fileImpCsv.click(); };
    fileImpCsv.onchange = () => {
      const f = fileImpCsv.files && fileImpCsv.files[0];
      if (f) importDivinglogCsvFromFile(f);
    };
  }

const btnQr = document.getElementById("btn_qr_scan_diver");
  if (btnQr) btnQr.onclick = openQrScannerScreen;

  const btnClose = document.getElementById("btn_qr_scan_close");
  if (btnClose) btnClose.onclick = closeQrScanModal;

  const btnStart = document.getElementById("btn_qr_scan_start");
  if (btnStart) btnStart.onclick = startQrScanCamera;

  const btnStop = document.getElementById("btn_qr_scan_stop");
  if (btnStop) btnStop.onclick = stopQrScanCamera;
  const btnPhoto = document.getElementById("btn_qr_scan_photo");
  const filePhoto = document.getElementById("qr_scan_file");
  if (btnPhoto && filePhoto) {
    btnPhoto.onclick = () => {
      // iOS: make sure selecting the same file twice still triggers an event
      try { filePhoto.value = ""; } catch(_) {}
      setQrScanStatus("📷 Choisis une image contenant le QR…");
      try { filePhoto.click(); } catch(e) {
        setQrScanStatus("Erreur ouverture Photos (iOS). Essaie Safari plein écran.");
        console.error("qr photo click error", e);
      }
    };

    const handlePickedPhoto = () => {
      const f = filePhoto.files && filePhoto.files[0];
      if (!f) { setQrScanStatus(""); return; }
      setQrScanStatus("⏳ Lecture de la photo…");
      try { decodeQrFromImageFile(f); }
      catch(e) {
        setQrScanStatus("Erreur lecture photo (voir console).");
        console.error("decodeQrFromImageFile error", e);
      }
    };

    // Some iOS builds fire 'input' more reliably than 'change'
    filePhoto.onchange = handlePickedPhoto;
    filePhoto.oninput = handlePickedPhoto;
  }


  const btnImport = document.getElementById("btn_qr_scan_import");
  if (btnImport) btnImport.onclick = () => {
    const t = document.getElementById("qr_scan_text");
    importDiverFromQrText(t ? t.value : "");
  };

  const btnClear = document.getElementById("btn_qr_scan_clear");
  if (btnClear) btnClear.onclick = clearQrScanText;

  const overlay = document.getElementById("qr_scan_overlay");
  if (overlay) {
    overlay.addEventListener("click", (ev) => {
      if (ev && ev.target === overlay) closeQrScanModal();
    });
  }
}




// ==========================
// QR CODE (DIVERS) – Import + Scan
// Objectif: scanner avant bateau → ajouter en bibliothèque + plongeurs du jour
// ==========================
function setQrScanStatus(msg) {
  const el1 = document.getElementById("qr-scan-status");
  if (el1) el1.textContent = msg || "";
  const el2 = document.getElementById("qr_scan_modal_status");
  if (el2) el2.textContent = msg || "";
}

function openQrScanModal() {
  const overlay = document.getElementById("qr_scan_overlay");
  if (!overlay) return;
  overlay.style.display = "flex";
  setQrScanStatus("");

  // Always show the scan UI so the Photo fallback remains available even when getUserMedia is absent
  const camWrap = document.getElementById("qr_scan_cam_wrap");
  if (camWrap) camWrap.style.display = "block";

  const btnStart = document.getElementById("btn_qr_scan_start");
  const btnStop  = document.getElementById("btn_qr_scan_stop");

  const hasCameraApi = (typeof navigator !== "undefined") &&
    !!navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === "function";

  // If camera API is unavailable (common in in-app browsers), keep Photo available and guide the user
  if (!hasCameraApi) {
    if (btnStart) btnStart.disabled = true;
    if (btnStop) btnStop.disabled = true;
    setQrScanStatus("Caméra indisponible dans ce navigateur. Utilise « Photo » ou ouvre le lien dans Safari/Chrome.");
    return;
  }

  if (btnStart) btnStart.disabled = false;
  if (btnStop) btnStop.disabled = false;

  // Auto-start camera (best effort)
  setTimeout(() => {
    try {
      const p = startQrScanCamera();
      if (p && typeof p.catch === "function") {
        p.catch(e => setQrScanStatus("Erreur caméra: " + (e && e.message ? e.message : String(e))));
      }
    } catch (e) {
      setQrScanStatus("Erreur caméra: " + (e && e.message ? e.message : String(e)));
    }
  }, 60);
}


function closeQrScanModal() {
  stopQrScanCamera();
  const overlay = document.getElementById("qr_scan_overlay");
  if (overlay) overlay.style.display = "none";
}

function clearQrScanText() {
  const t = document.getElementById("qr_scan_text");
  if (t) t.value = "";
  setQrScanStatus("");
}


// Decode QR from an image file (fallback when camera is unreliable / for testing)
function decodeQrFromImageFile(file) {
  setQrScanStatus("⏳ Analyse QR depuis la photo…");
  if (typeof jsQR !== "function") {
    setQrScanStatus("Erreur: librairie jsQR absente (scan QR impossible).");
    return;
  }
  if (!file) return;

  // Helper: multi-pass decode (full frame at different scales, then centered ROI).
  function tryDecodeFromCtx(ctx, w, h) {
    try {
      // 1) Full frame
      try {
        const full = ctx.getImageData(0, 0, w, h);
        const c1 = jsQR(full.data, full.width, full.height, { inversionAttempts: "attemptBoth" });
        if (c1 && c1.data) return c1;
      } catch(_) {}

      // 1b) Full frame at half-resolution (sometimes helps noisy photos)
      try {
        const w2 = Math.max(1, Math.floor(w / 2));
        const h2 = Math.max(1, Math.floor(h / 2));
        const tmp = document.createElement("canvas");
        tmp.width = w2; tmp.height = h2;
        const tctx = tmp.getContext("2d", { willReadFrequently: true });
        tctx.drawImage(ctx.canvas, 0, 0, w, h, 0, 0, w2, h2);
        const half = tctx.getImageData(0, 0, w2, h2);
        const c1b = jsQR(half.data, half.width, half.height, { inversionAttempts: "attemptBoth" });
        if (c1b && c1b.data) return c1b;
      } catch(_) {}

      // 2) Center ROI (faster on large images)
      const side = Math.max(1, Math.floor(Math.min(w, h) * 0.90));
      const sx = Math.floor((w - side) / 2);
      const sy = Math.floor((h - side) / 2);
      const roi = ctx.getImageData(sx, sy, side, side);
      const c2 = jsQR(roi.data, roi.width, roi.height, { inversionAttempts: "attemptBoth" });
      if (c2 && c2.data) return c2;
    } catch(_) {}
    return null;
  }

  // Prefer createImageBitmap when available (better orientation handling on iOS).
  (async () => {
    try {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      // Try createImageBitmap first (handles EXIF orientation in many browsers)
      if (typeof createImageBitmap === "function") {
        let bmp = null;
        try {
          // imageOrientation option is supported in modern browsers; safe to ignore if unsupported.
          bmp = await createImageBitmap(file, { imageOrientation: "from-image" });
        } catch (_) {
          // fallback without options
          bmp = await createImageBitmap(file);
        }

        const iw = bmp.width || 0;
        const ih = bmp.height || 0;
        if (!iw || !ih) { setQrScanStatus("Photo invalide."); return; }

        // Keep enough pixels for dense QRs (manifest JSON can be large)
        const maxW = 2400;
        const scale = Math.min(1, maxW / iw);
        const cw = Math.max(1, Math.round(iw * scale));
        const ch = Math.max(1, Math.round(ih * scale));
        canvas.width = cw;
        canvas.height = ch;
        ctx.drawImage(bmp, 0, 0, iw, ih, 0, 0, cw, ch);

        const code = tryDecodeFromCtx(ctx, cw, ch);
        if (code && code.data) {
          // code.data peut être un JSON *ou* une URL #import=ID
          (async () => {
            try {
              const payload = await resolveScannedQrText(code.data);
              if (!payload) { setQrScanStatus("❌ QR invalide (lien non reconnu ou import expiré)."); return; }
              importDiverFromQrText(payload);
              setQrScanStatus("✅ Import terminé.");
            } catch (e) {
              setQrScanStatus("Erreur import: " + (e && e.message ? e.message : String(e)));
            }
          })();
          return;
        }

        setQrScanStatus("QR non détecté sur la photo. Conseil iPhone: utilise un *screenshot* du QR (pas une photo d'un écran), ou rapproche/zoome pour que le QR remplisse l'image.");
        return;
      }

      // Fallback: <img> via objectURL (more robust than dataURL for some formats)
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        try {
          const iw = img.naturalWidth || img.width || 0;
          const ih = img.naturalHeight || img.height || 0;
          if (!iw || !ih) { setQrScanStatus("Photo invalide."); return; }

          const maxW = 2400;
          const scale = Math.min(1, maxW / iw);
          const cw = Math.max(1, Math.round(iw * scale));
          const ch = Math.max(1, Math.round(ih * scale));
          canvas.width = cw;
          canvas.height = ch;
          ctx.drawImage(img, 0, 0, iw, ih, 0, 0, cw, ch);

          const code = tryDecodeFromCtx(ctx, cw, ch);
          if (code && code.data) {
            // code.data peut être un JSON *ou* une URL #import=ID
            setQrScanStatus("✅ QR détecté. Import…");
            (async () => {
              try {
                const payload = await resolveScannedQrText(code.data);
                if (!payload) { setQrScanStatus("❌ QR invalide (lien non reconnu ou import expiré)."); return; }
                importDiverFromQrText(payload);
                setQrScanStatus("✅ Import terminé.");
              } catch (e) {
                setQrScanStatus("Erreur import: " + (e && e.message ? e.message : String(e)));
              }
            })();
          } else {
            setQrScanStatus("QR non détecté sur la photo. Conseil iPhone: utilise un *screenshot* du QR (pas une photo d'un écran), ou rapproche/zoome pour que le QR remplisse l'image.");
          }
        } catch (e) {
          setQrScanStatus("Erreur photo: " + (e && e.message ? e.message : String(e)));
        } finally {
          try { URL.revokeObjectURL(url); } catch(_) {}
        }
      };
      img.onerror = () => {
        try { URL.revokeObjectURL(url); } catch(_) {}
        setQrScanStatus("Erreur: image illisible (format non supporté ?).");
      };
      img.src = url;
    } catch (e) {
      setQrScanStatus("Erreur photo: " + (e && e.message ? e.message : String(e)));
    }
  })();
}


function coalesceStr() {
  for (let i = 0; i < arguments.length; i++) {
    const v = arguments[i];
    if (v == null) continue;
    const s = String(v).trim();
    if (s) return s;
  }
  return "";
}

function parseQrDiverPayload(rawText) {
  const txt = String(rawText || "").trim();
  if (!txt) return { ok:false, err:"QR vide." };

  // 1) JSON (preferred)
  if (txt[0] === "{" || txt[0] === "[") {
    try {
      const obj = JSON.parse(txt);
      const o = (Array.isArray(obj) ? obj[0] : obj) || {};
      const first = coalesceStr(o.firstName, o.prenom, o.first, o.givenName);
      const last  = coalesceStr(o.lastName,  o.nom,    o.last,  o.familyName);
      const name  = coalesceStr(o.name, o.fullName, (first || last) ? (first + " " + last).trim() : "");
      const aptitude = coalesceStr(o.aptitude, o.aptitudes, o.level, o.apt);
      const cert     = coalesceStr(o.certification, o.cert, o.certif);
      const licence  = coalesceStr(o.licence, o.license, o.numeroLicence, o.numLicence, o.lic);
      if (!name) return { ok:false, err:"Nom/prénom manquant dans le QR." };
      return { ok:true, diver:{ name, aptitudes: aptitude, cert, licence } };
    } catch(e) {
      return { ok:false, err:"QR JSON invalide." };
    }
  }

  // 2) Simple format "Nom;Aptitude;Cert;Licence"
  //    (utile pour tests rapides sans générateur)
  const parts = txt.split(";").map(s => String(s || "").trim());
  if (parts.length >= 1) {
    const name = parts[0] || "";
    if (!name) return { ok:false, err:"Nom manquant." };
    const aptitude = parts[1] || "";
    const cert = parts[2] || "";
    const licence = parts[3] || "";
    return { ok:true, diver:{ name, aptitudes: aptitude, cert, licence } };
  }

  return { ok:false, err:"Format QR non reconnu." };
}

function parseQrBoatManifestPayload(rawText) {
  const txt = String(rawText || "").trim();
  if (!txt) return { ok:false, err:"QR vide." };

  if (!(txt[0] === "{" || txt[0] === "[")) {
    return { ok:false, err:"QR non-JSON (manifest attendu)." };
  }

  try {
    const obj = JSON.parse(txt);
    const o = (Array.isArray(obj) ? obj[0] : obj) || {};

    if (String(o.type || "") !== "pdj_boat_manifest") {
      return { ok:false, err:"Pas un manifest PDJ." };
    }
    if (!Array.isArray(o.divers)) {
      return { ok:false, err:"Manifest invalide: divers[] manquant." };
    }

    return {
      ok:true,
      manifest:{
        v: o.v,
        type: o.type,
        center: o.center || {},
        boat: o.boat || "",
        part: o.part || "",
        exportedAt: o.exportedAt || "",
        divers: o.divers
      }
    };
  } catch (e) {
    return { ok:false, err:"QR JSON invalide (manifest)." };
  }
}

function extractRankedToken(s, prefix) {
  // returns number for tokens like "PA60", "PE40", "PTH100", "CCR100"
  const txt = String(s || "").toUpperCase();
  const re = new RegExp("\\b" + prefix + "\\s*(\\d{1,3})\\b");
  const m = txt.match(re);
  if (!m) return null;
  const n = parseInt(m[1], 10);
  return isFinite(n) ? n : null;
}

function upgradeOnlyAptitude(existing, incoming) {
  const a0 = String(existing || "").trim();
  const a1 = String(incoming || "").trim();
  if (!a0) return a1;
  if (!a1) return a0;
  if (normalizeName(a0) === normalizeName(a1)) return a0;

  const prefixes = ["PA","PE","PTH","CCR"];
  for (const p of prefixes) {
    const n0 = extractRankedToken(a0, p);
    const n1 = extractRankedToken(a1, p);
    if (n0 != null && n1 != null) {
      return (n1 >= n0) ? a1 : a0; // upgrade-only
    }
  }

  // fallback conservative: never overwrite (avoid downgrade / garbage)
  return a0;
}

function findDiverByLicenceOrName(licence, name) {
  const lib = Array.isArray(diverLibrary) ? diverLibrary : [];
  const licKey = String(licence || "").trim().toLowerCase();
  if (licKey) {
    const hit = lib.find(d => d && String(d.licence || "").trim().toLowerCase() === licKey);
    if (hit) return hit;
  }
  const nkey = normalizeName(name || "");
  if (!nkey) return null;
  return lib.find(d => d && normalizeName(d.name) === nkey) || null;
}

function upsertDiverFromQR(diverIn) {
  const name = String(diverIn?.name || "").trim();
  if (!name) return { ok:false, msg:"Nom obligatoire." };

  const incoming = {
    name,
    licence: String(diverIn?.licence || "").trim(),
    cert: String(diverIn?.cert || "").trim(),
    aptitudes: String(diverIn?.aptitudes || "").trim()
  };

  if (!Array.isArray(diverLibrary)) diverLibrary = [];

  // Find existing by licence first, else by normalize(name)
  const existing = findDiverByLicenceOrName(incoming.licence, incoming.name);

  if (!existing) {
    const diver = {
      id: "d_" + Date.now() + "_" + Math.random().toString(36).slice(2),
      name: incoming.name,
      licence: incoming.licence,
      cert: incoming.cert,
      aptitudes: incoming.aptitudes
    };
    while (diverLibrary.some(x => x && x.id === diver.id)) {
      diver.id = "d_" + Date.now() + "_" + Math.random().toString(36).slice(2);
    }
    normalizeDiverRecord(diver);
    diverLibrary.push(diver);

    pdjAfterDiverLibraryMutation();
    saveDiverLibrary();
    return { ok:true, diver, created:true, msg:"Nouveau plongeur ajouté à la bibliothèque." };
  }

  // Merge upgrade-only
  let changed = false;

  if (!String(existing.licence || "").trim() && incoming.licence) { existing.licence = incoming.licence; changed = true; }
  if (!String(existing.cert || "").trim() && incoming.cert) { existing.cert = incoming.cert; changed = true; }

  const prevApt = existing.aptitudes || "";
  const nextApt = upgradeOnlyAptitude(prevApt, incoming.aptitudes);
  if (normalizeName(prevApt) !== normalizeName(nextApt)) { existing.aptitudes = nextApt; changed = true; }

  if (changed) saveDiverLibrary();
  return { ok:true, diver:existing, created:false, msg: changed ? "Plongeur mis à jour (upgrade-only)." : "Plongeur déjà présent (aucune modification)." };
}

function addDiverToDiversDuJour(name) {
  const nm = String(name || "").trim();
  if (!nm) return;
  if (!Array.isArray(diversDuJour)) diversDuJour = [];
  if (!diversDuJour.includes(nm)) diversDuJour.push(nm);
  saveDiversDuJour();
}

function importBoatManifestToPDJ(manifest, forcedBoatId) {
  const cfg = (typeof loadCenterCfg === "function") ? loadCenterCfg() : {};
  const localCenterId = cfg && (cfg.id || cfg.centerId) ? String(cfg.id || cfg.centerId) : "";
  const incomingCenterId = manifest && manifest.center && manifest.center.id ? String(manifest.center.id) : "";

  // Safety: refuse cross-center if both are set and mismatch
  if (localCenterId && incomingCenterId && localCenterId !== incomingCenterId) {
    return { ok:false, msg:"Centre différent: import refusé (" + incomingCenterId + " ≠ " + localCenterId + ")." };
  }

  const boat = normalizeUnitId(forcedBoatId) || normalizeUnitId(manifest.boat);
  if (!boat) return { ok:false, msg:"Aucun bateau valide (B1..BN)." };

  let created = 0, updated = 0, unchanged = 0, addedToPDJ = 0;

  const arr = Array.isArray(manifest.divers) ? manifest.divers : [];
  for (let i = 0; i < arr.length; i++) {
    const d = arr[i] || {};
    const r = upsertDiverFromQR(d);
    if (!r.ok) continue;

    if (r.created) created++;
    else {
      // upsertDiverFromQR renvoie msg "mis à jour" ou "aucune modif"
      if ((r.msg || "").toLowerCase().includes("mis à jour")) updated++;
      else unchanged++;
    }

    // PDJ + tag
    const name = r.diver && r.diver.name ? r.diver.name : "";
    const beforeLen = Array.isArray(diversDuJour) ? diversDuJour.length : 0;
    addDiverToDiversDuJour(name);
    const afterLen = Array.isArray(diversDuJour) ? diversDuJour.length : 0;
    if (afterLen > beforeLen) addedToPDJ++;

    if (!diversDuJourUnits || typeof diversDuJourUnits !== "object") diversDuJourUnits = {};
    diversDuJourUnits[name] = boat;
  }

  saveDiversDuJour();
  saveDiversDuJourUnits();

  return {
    ok:true,
    msg:
      "Manifest PDJ importé → " + boat +
      " | PDJ +" + addedToPDJ +
      " | nouveaux " + created +
      " | maj " + updated +
      " | inchangés " + unchanged +
      (manifest.part ? (" | part " + manifest.part) : "")
  };
}

function importDiverFromQrText(rawText) {
  // SAFETY: never treat a URL as a diver/manifest payload in the in-app importer
  if (typeof rawText === "string" && /^https?:\/\//i.test(rawText.trim())) {
    throw new Error("QR URL non résolu");
  }

  // 1) Try manifest first (bulk PDJ by boat)
  const pm = parseQrBoatManifestPayload(rawText);
  if (pm.ok) {
    // tag selection: use current activeBoatId if present, else fallback to QR payload boat
    const forced = (typeof activeBoatId !== "undefined") ? activeBoatId : "";
    const r = importBoatManifestToPDJ(pm.manifest, forced);
    if (!r.ok) { setQrScanStatus("QR: " + r.msg); return; }

    renderPlongeursDuJourSelector();
    try { updatePlongeursJourStatus(); } catch(e) {}
    setQrScanStatus("✅ " + r.msg);
    return;
  }

  // 2) Fallback: single diver QR (existing behavior)
  const parsed = parseQrDiverPayload(rawText);
  if (!parsed.ok) {
    setQrScanStatus("QR: " + parsed.err);
    return;
  }
  const r = upsertDiverFromQR(parsed.diver);
  if (!r.ok) {
    setQrScanStatus("QR: " + (r.msg || "Erreur"));
    return;
  }
  addDiverToDiversDuJour(r.diver.name);

  // optional: apply current boat selection to that diver too
  try {
    const forced = (typeof activeBoatId !== "undefined") ? normalizeUnitId(activeBoatId) : "";
    if (forced) {
      diversDuJourUnits[r.diver.name] = forced;
      saveDiversDuJourUnits();
    }
  } catch(e) {}

  renderPlongeursDuJourSelector();
  try { updatePlongeursJourStatus(); } catch(e) {}
  setQrScanStatus("✅ " + r.msg + " Ajouté aux plongeurs du jour: " + r.diver.name);
}


// --- Camera scan (jsQR via canvas) ---
// Note: we keep these globals so Stop can really stop the RAF loop on iPhone/Safari.
let qrScanStream = null;
let qrScanRafId = null;
let qrScanActive = false;
let qrScanCanvas = null;
let qrScanCtx = null;
let qrScanFrame = 0;

async function startQrScanCamera() {
  const video = document.getElementById("qr_scan_video");
  if (!video) return;

  // hard stop any previous session
  stopQrScanCamera();

  // Safety: jsQR must be present (otherwise the scan loop silently fails)
  if (typeof jsQR !== "function") {
    setQrScanStatus("Erreur: librairie jsQR absente (scan QR impossible).");
    return;
  }


  if (!(navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === "function")) {
    setQrScanStatus("Caméra non supportée sur ce navigateur.");
    return;
  }
  if (typeof jsQR !== "function") {
    setQrScanStatus("jsQR non chargé (librairie manquante).");
    return;
  }

  try {
    // iOS/Safari can be picky with constraints. Try "best" then fallback to minimal.
    const constraintsBest = { video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
    const constraintsMin  = { video: { facingMode: "environment" }, audio: false };
    try {
      qrScanStream = await navigator.mediaDevices.getUserMedia(constraintsBest);
    } catch (err1) {
      // fallback for OverconstrainedError / NotReadableError etc.
      qrScanStream = await navigator.mediaDevices.getUserMedia(constraintsMin);
    }
    video.srcObject = qrScanStream;
    // Autoplay policies (Chrome/Android): muted+autoplay improves reliability
    try { video.muted = true; video.setAttribute("muted","true"); video.autoplay = true; } catch(_) {}
    video.setAttribute("playsinline", true);
    await video.play();
    // Best-effort continuous focus when supported
    try {
      const track = qrScanStream && qrScanStream.getVideoTracks ? qrScanStream.getVideoTracks()[0] : null;
      if (track && typeof track.applyConstraints === "function") {
        track.applyConstraints({ advanced: [{ focusMode: "continuous" }] }).catch(function(){});
      }
    } catch(_) {}
    // Safari/WebKit: wait for video dimensions to be available (loadedmetadata)
    await new Promise(resolve => {
      if (video.videoWidth && video.videoHeight) return resolve();
      let done = false;
      const finish = () => { if (done) return; done = true; try { video.onloadedmetadata = null; } catch(_) {} resolve(); };
      try { video.onloadedmetadata = finish; } catch(_) {}
      // hard fallback: do not block forever
      setTimeout(finish, 1500);
    });

    if (!video.videoWidth || !video.videoHeight) {
      setQrScanStatus("Caméra active, mais dimensions vidéo indisponibles (Safari).");
    }


    if (!qrScanCanvas) qrScanCanvas = document.createElement("canvas");
    if (!qrScanCtx) qrScanCtx = qrScanCanvas.getContext("2d", { willReadFrequently: true });

    qrScanActive = true;
    setQrScanStatus("Caméra active. Présente le QR code.");

    let qrScanLastScanTs = 0;
    const tick = () => {
      qrScanFrame = (qrScanFrame || 0) + 1;
      if (qrScanFrame % 30 === 0) {
        try {
          const vw = video.videoWidth || 0;
          const vh = video.videoHeight || 0;
          setQrScanStatus(`Caméra active. Présente le QR code. (${vw}×${vh})`);
        } catch(_) {}
      }
      if (!qrScanActive) return;
      try {
        if (video.readyState >= 2) {
          qrScanCanvas.width = video.videoWidth || 0;
          qrScanCanvas.height = video.videoHeight || 0;
          if (!qrScanCanvas.width || !qrScanCanvas.height) { setQrScanStatus("Caméra active, attente image..."); }
          if (qrScanCanvas.width && qrScanCanvas.height) {
            // Throttle decoding (jsQR is CPU heavy). ~8 fps is enough and improves stability.
            const now = Date.now();
            if (now - (qrScanLastScanTs || 0) >= 120) {
              qrScanLastScanTs = now;

              // Downscale for speed + better detection (avoid huge frames)
              const vw = video.videoWidth || 0;
              const vh = video.videoHeight || 0;
              if (vw > 0 && vh > 0) {
                const targetW = 720; // mobile-friendly
                const cw = Math.min(targetW, vw);
                const ch = Math.max(1, Math.round(vh * (cw / vw)));

                qrScanCanvas.width = cw;
                qrScanCanvas.height = ch;

                qrScanCtx.drawImage(video, 0, 0, vw, vh, 0, 0, cw, ch);

                // Center ROI: faster + more reliable (user usually presents QR near center)
                const side = Math.max(1, Math.floor(Math.min(cw, ch) * 0.75));
                const sx = Math.floor((cw - side) / 2);
                const sy = Math.floor((ch - side) / 2);

                const imageData = qrScanCtx.getImageData(sx, sy, side, side);
                const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "attemptBoth" });
                if (code && code.data) {
                  // stop first (avoid double imports)
                  stopQrScanCamera();
                  setQrScanStatus("✅ QR détecté. Import…");
                  (async () => {
                    try {
                      const payload = await resolveScannedQrText(code.data);
                      if (!payload) { setQrScanStatus("❌ QR invalide (lien non reconnu ou import expiré)."); return; }
                      importDiverFromQrText(payload);
                      setQrScanStatus("✅ Import terminé.");
                    } catch (e) {
                      setQrScanStatus("Erreur import: " + (e && e.message ? e.message : String(e)));
                    }
                  })();
                  return;
                }
              }
            }
          }
        }
      } catch (e) {
        // ignore frame errors
      }
      qrScanRafId = requestAnimationFrame(tick);
    };

    qrScanRafId = requestAnimationFrame(tick);
  } catch (e) {
    stopQrScanCamera();
    const name = (e && (e.name || e.code)) ? String(e.name || e.code) : "";
    if (name === "NotAllowedError" || name === "SecurityError") {
      setQrScanStatus("Caméra refusée. Autorise l’accès caméra dans Safari (AA) puis réessaie.");
    } else if (name === "NotFoundError" || name === "DevicesNotFoundError") {
      setQrScanStatus("Aucune caméra détectée sur cet appareil.");
    } else if (name === "NotReadableError") {
      setQrScanStatus("Caméra indisponible (déjà utilisée par une autre app ?). Ferme les autres apps caméra puis réessaie.");
    } else {
      setQrScanStatus("Erreur caméra: " + (e && e.message ? e.message : String(e)));
    }
  }
}

function stopQrScanCamera() {
  qrScanActive = false;
  if (qrScanRafId) {
    try { cancelAnimationFrame(qrScanRafId); } catch(_) {}
    qrScanRafId = null;
  }

  const video = document.getElementById("qr_scan_video");
  if (video) {
    try { video.pause(); } catch(_) {}
    try { video.srcObject = null; } catch(_) {}
  }

  if (qrScanStream) {
    try { qrScanStream.getTracks().forEach(t => t.stop()); } catch(_) {}
    qrScanStream = null;
  }
}

/* =======================
   A1 REFONTE – LOGIQUE SCANNER QR (plein écran)
   ======================= */
let __qrss_stream = null;
let __qrss_raf = null;
let __qrss_lastTs = 0;

function qrss_setStatus(msg){
  const el = document.getElementById("qrss_status");
  if (el) el.textContent = msg;
}

function qrss_setDebug(msg){
  const el = document.getElementById("qrss_debug");
  if (el) el.textContent = msg || "";
}

function openQrScannerScreen(){
  const scr = document.getElementById("qr_scanner_screen");
  if (!scr) return;
  scr.style.display = "block";
  scr.setAttribute("aria-hidden","false");
  qrss_setStatus("Prêt. Choisis Caméra ou Photo.");
  qrss_setDebug("");
  // ensure old modal closed if user opened it somehow
  try { closeQrScanModal(); } catch(_){}
}

function closeQrScannerScreen(){
  stopQrScannerCamera();
  const btnSnap = document.getElementById("qrss_btn_snap");
  if (btnSnap) btnSnap.style.display = "none";
  const scr = document.getElementById("qr_scanner_screen");
  if (!scr) return;
  scr.style.display = "none";
  scr.setAttribute("aria-hidden","true");
}

async function startQrScannerCamera(){
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    qrss_setStatus("Caméra indisponible ici. Ouvre dans Safari/Chrome ou utilise Photo.");
    return;
  }

  stopQrScannerCamera();

  const v = document.getElementById("qrss_video");
  const wrap = document.getElementById("qrss_video_wrap");
  if (wrap) wrap.style.display = "block";
  if (!v) return;

  v.muted = true;
  v.playsInline = true;

  try{
    __qrss_stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" } },
      audio: false
    });

    v.srcObject = __qrss_stream;
    await v.play();

    // best-effort focus continuous
    try{
      const track = __qrss_stream.getVideoTracks && __qrss_stream.getVideoTracks()[0];
      if (track && track.applyConstraints){
        await track.applyConstraints({ advanced: [{ focusMode: "continuous" }] });
      }
    }catch(_){}

    qrss_setStatus("Caméra active… présente le QR bien net.");
    try{
      const btnSnap = document.getElementById("qrss_btn_snap");
      if (btnSnap) btnSnap.style.display = "";
      qrss_setDebug("jsQR=" + (typeof jsQR) + " | readyState=" + v.readyState + " | video=" + v.videoWidth + "×" + v.videoHeight);
    }catch(_){ }
    __qrss_lastTs = 0;
    __qrss_raf = requestAnimationFrame(qrss_tick);

  }catch(err){
    qrss_setStatus("Erreur caméra: " + (err && err.name ? err.name : "inconnue"));
    stopQrScannerCamera();
  }
}

function stopQrScannerCamera(){
  if (__qrss_raf){
    try{ cancelAnimationFrame(__qrss_raf); }catch(_){}
    __qrss_raf = null;
  }
  if (__qrss_stream){
    try{
      (__qrss_stream.getTracks()||[]).forEach(t=>{ try{ t.stop(); }catch(_){} });
    }catch(_){}
    __qrss_stream = null;
  }
  const v = document.getElementById("qrss_video");
  if (v){
    try{ v.pause(); }catch(_){}
    try{ v.srcObject = null; }catch(_){}
  }

}

function qrss_decodeCurrentFrame(highRes){
  try{
    const v = document.getElementById("qrss_video");
    if (!v || !v.videoWidth || !v.videoHeight){ qrss_setStatus("Frame indisponible (video pas prêt)."); return; }
    if (typeof jsQR !== "function"){ qrss_setStatus("jsQR non chargé."); return; }

    if (!window.__qrss_canvas) window.__qrss_canvas = document.createElement("canvas");
    if (!window.__qrss_ctx) window.__qrss_ctx = window.__qrss_canvas.getContext("2d", { willReadFrequently: true });

    const maxW = highRes ? 1920 : (window.__qrss_maxW || 1280);
    const vw = v.videoWidth, vh = v.videoHeight;
    const scale = Math.min(1, maxW / vw);
    const w = Math.max(1, Math.floor(vw * scale));
    const h = Math.max(1, Math.floor(vh * scale));

    const c = window.__qrss_canvas; const ctx = window.__qrss_ctx;
    if (c.width !== w) c.width = w;
    if (c.height !== h) c.height = h;
    ctx.drawImage(v, 0, 0, w, h);

    // multi-pass same as tick
    let img = ctx.getImageData(0,0,w,h);
    let res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    const rx = Math.floor(w*0.05), ry = Math.floor(h*0.05), rw = Math.max(1, Math.floor(w*0.90)), rh = Math.max(1, Math.floor(h*0.90));
    img = ctx.getImageData(rx, ry, rw, rh);
    res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    const rx2 = Math.floor(w*0.15), ry2 = Math.floor(h*0.15), rw2 = Math.max(1, Math.floor(w*0.70)), rh2 = Math.max(1, Math.floor(h*0.70));
    img = ctx.getImageData(rx2, ry2, rw2, rh2);
    res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    qrss_setStatus("Aucun QR détecté sur cette frame. Essaie de rapprocher/augmenter la netteté.");
  }catch(e){
    qrss_setStatus("Erreur analyse frame: " + (e && e.message ? e.message : String(e)));
  }
}



function qrss_tick(ts){
  __qrss_raf = requestAnimationFrame(qrss_tick);

  // throttle ~10 fps
  if (__qrss_lastTs && (ts - __qrss_lastTs) < 95) return;
  __qrss_lastTs = ts;

  const v = document.getElementById("qrss_video");
  if (!v || !v.videoWidth || !v.videoHeight){
    try{ qrss_setDebug("jsQR=" + (typeof jsQR) + " | readyState=" + (v ? v.readyState : "-") + " | video=" + (v ? (v.videoWidth+"×"+v.videoHeight) : "-") ); }catch(_){}
    return;
  }

  // Keep a persistent canvas (critical on iPhone: avoid creating canvases every frame)
  if (!window.__qrss_canvas) window.__qrss_canvas = document.createElement("canvas");
  if (!window.__qrss_ctx) window.__qrss_ctx = window.__qrss_canvas.getContext("2d", { willReadFrequently: true });

  const ctx = window.__qrss_ctx;
  const c = window.__qrss_canvas;
  if (!ctx || !c) return;

  // Adaptive resolution: dense QRs (JSON) often need more pixels than 720px.
  // Start at 720, then bump to 960/1280 if we fail for a while.
  if (!window.__qrss_maxW) window.__qrss_maxW = 720;
  if (window.__qrss_maxW < 720) window.__qrss_maxW = 720;
  if (!window.__qrss_fail) window.__qrss_fail = 0;

  const maxW = window.__qrss_maxW;
  const scale = Math.min(1, maxW / v.videoWidth);
  const w = Math.max(1, Math.round(v.videoWidth * scale));
  const h = Math.max(1, Math.round(v.videoHeight * scale));

  c.width = w; c.height = h;

  try{
    ctx.drawImage(v, 0, 0, w, h);

    // Pass 1: full frame
    let img = ctx.getImageData(0, 0, w, h);
    let res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    // Pass 2: centered ROI 90% (helps when QR is near center and reduces noise)
    const rx = Math.floor(w * 0.05), ry = Math.floor(h * 0.05);
    const rw = Math.max(1, Math.floor(w * 0.90));
    const rh = Math.max(1, Math.floor(h * 0.90));
    img = ctx.getImageData(rx, ry, rw, rh);
    res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    // Pass 3: centered ROI 70% (when QR is large and we want less background)
    const rx2 = Math.floor(w * 0.15), ry2 = Math.floor(h * 0.15);
    const rw2 = Math.max(1, Math.floor(w * 0.70));
    const rh2 = Math.max(1, Math.floor(h * 0.70));
    img = ctx.getImageData(rx2, ry2, rw2, rh2);
    res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    // No decode this frame
    window.__qrss_fail = (window.__qrss_fail || 0) + 1;
    try{ qrss_setDebug("fails=" + window.__qrss_fail + " | draw=" + w + "×" + h + " | maxW=" + window.__qrss_maxW + " | video=" + v.videoWidth + "×" + v.videoHeight); }catch(_){}

    // Every ~1.5s, bump resolution (720 -> 960 -> 1280) then keep 1280
    if (window.__qrss_fail % 15 === 0){
      if (window.__qrss_maxW === 720) window.__qrss_maxW = 960;
      else if (window.__qrss_maxW === 960) window.__qrss_maxW = 1280;
      // status hint for user / debug
      try{
        qrss_setStatus("Caméra active… présente le QR bien net. (" + w + "×" + h + ", maxW=" + window.__qrss_maxW + ")");
      }catch(_){}
    }
  }catch(_){}
}

async function qrss_decodeFromFile(file){
  if (!file) return;
  qrss_setStatus("⏳ Analyse de la photo…");
  try{
    // orientation-safe on iOS
    let bmp = null;
    try{
      bmp = await createImageBitmap(file, { imageOrientation: "from-image" });
    }catch(_){
      bmp = await createImageBitmap(file);
    }

    const maxW = 2400;
    const scale = Math.min(1, maxW / bmp.width);
    const w = Math.max(1, Math.round(bmp.width * scale));
    const h = Math.max(1, Math.round(bmp.height * scale));

    const c = document.createElement("canvas");
    c.width = w; c.height = h;
    const ctx = c.getContext("2d", { willReadFrequently: true });
    ctx.drawImage(bmp, 0, 0, w, h);

    // pass 1: full frame
    let img = ctx.getImageData(0, 0, w, h);
    let res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    // pass 2: centered ROI (90%)
    const rx = Math.floor(w*0.05), ry = Math.floor(h*0.05);
    const rw = Math.floor(w*0.90), rh = Math.floor(h*0.90);
    img = ctx.getImageData(rx, ry, rw, rh);
    res = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
    if (res && res.data){ qrss_onDecoded(res.data); return; }

    qrss_setStatus("QR non détecté sur cette image. Essaie une capture d’écran du QR.");
  }catch(err){
    qrss_setStatus("Erreur lecture photo: " + (err && err.message ? err.message : "inconnue"));
  }
}


// =====================================================
// QR scan resolver: URL (#import=ID) -> payload string
// Ensures a URL is never treated as a diver payload.
// =====================================================
async function resolveScannedQrText(rawText){
  if (typeof rawText !== "string") return null;
  const s = rawText.trim();

  // URL with #import=ID (or ?import= / &import=)
  const m = s.match(/[?#&]import=([^&]+)/);
  if (m && m[1]){
    const id = decodeURIComponent(m[1] || "");
    if (!id) return null;
    try{
      const r = await fetch(`/.netlify/functions/qr_get?id=${encodeURIComponent(id)}`, { method: "GET" });
      const j = await r.json().catch(()=>null);
      if (j && j.ok && j.body) return j.body;
      return null;
    }catch(e){
      console.error("resolveScannedQrText: fetch failed", e);
      return null;
    }
  }

  // If it's any other URL, do NOT pass it to import (prevents URL->diver pollution)
  if (/^https?:\/\//i.test(s)) return null;

  // Non-URL text: direct payload (manifest JSON or single diver JSON)
  return s;
}


async function qrss_onDecoded(text){
  // stop camera ASAP to avoid double triggers
  stopQrScannerCamera();

  qrss_setStatus("✅ QR détecté. Import…");
  try{
    const payload = await resolveScannedQrText(text);
    if (!payload){
      qrss_setStatus("❌ QR invalide (lien non reconnu ou import expiré).");
      return;
    }
    importDiverFromQrText(payload);
    qrss_setStatus("✅ Import terminé.");
    setTimeout(closeQrScannerScreen, 450);
  }catch(err){
    qrss_setStatus("Erreur import: " + (err && err.message ? err.message : "inconnue"));
  }
}


function initQrScannerScreen(){
  const btnClose = document.getElementById("qrss_btn_close");
  if (btnClose) btnClose.onclick = closeQrScannerScreen;

  const btnCam = document.getElementById("qrss_btn_camera");
  if (btnCam) btnCam.onclick = startQrScannerCamera;
  if (btnSnap) btnSnap.onclick = () => { qrss_decodeCurrentFrame(true); };

  const btnPhoto = document.getElementById("qrss_btn_photo");
  const btnSnap = document.getElementById("qrss_btn_snap");
  const file = document.getElementById("qrss_file");
  if (btnPhoto && file){
    btnPhoto.onclick = () => { try{ file.value = ""; }catch(_){} file.click(); };
    const handler = () => {
      const f = file.files && file.files[0];
      if (f) qrss_decodeFromFile(f);
    };
    file.onchange = handler;
    file.oninput = handler;
  }

  // close on background click (but not inside card)
  const scr = document.getElementById("qr_scanner_screen");
  if (scr){
    scr.addEventListener("click", (ev)=>{
      if (ev && ev.target === scr) closeQrScannerScreen();
    });
  }
}


function buildAptitudeFilterOptions() {
  const sel = document.getElementById("pdj_filter_apt");
  if (!sel || !Array.isArray(diverLibrary)) return;

  const values = Array.from(
    new Set(
      diverLibrary
        .map(d => (d.aptitudes || "").trim())
        .filter(v => v !== "")
    )
  ).sort();

  sel.innerHTML = '<option value="">Aptitude : toutes</option>';
  values.forEach(v => {
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    sel.appendChild(opt);
  });
}


function safeUpdateRecentFromSelection(names) {
  if (!Array.isArray(names)) return;
  updateRecentFromSelection(names);
}
// ===========================
// GROUP DETAILS (AVANT / APRÈS)
// ===========================
function loadGroupDetails() {
  groupDetails = {};
  try {
    const raw = localStorage.getItem(GROUP_DETAILS_KEY);
    if (!raw) return;
    const obj = JSON.parse(raw);
    if (obj && typeof obj === "object") {
      groupDetails = obj;
    }
  } catch (e) {
    console.warn("loadGroupDetails error:", e);
    groupDetails = {};
  }
}

function saveGroupDetails() {
  try {
    localStorage.setItem(GROUP_DETAILS_KEY, JSON.stringify(groupDetails));
  } catch (e) {
    console.warn("saveGroupDetails error:", e);
  }
}


function loadGroupPractice() {
  try { return JSON.parse(localStorage.getItem(GROUP_PRACTICE_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function saveGroupPractice() {
  localStorage.setItem(GROUP_PRACTICE_KEY, JSON.stringify(groupPractice || {}));
}
function loadGroupSupervisors() {
  try { return JSON.parse(localStorage.getItem(GROUP_SUPERVISOR_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function saveGroupSupervisors() {
  localStorage.setItem(GROUP_SUPERVISOR_KEY, JSON.stringify(groupSupervisors || {}));
}

function normalizeInstructorLibrary(arr) {
  const out = Array.isArray(arr) ? arr.slice() : [];
  let changed = false;
  for (let i = 0; i < out.length; i++) {
    const inst = out[i];
    if (!inst || typeof inst !== "object") continue;
    if (!inst.id) { inst.id = makeInstructorId(); changed = true; }
    if (inst.aptitude == null) { inst.aptitude = ""; changed = true; }
    if (inst.certification == null) { inst.certification = ""; changed = true; }
    if (inst.licence == null) { inst.licence = ""; changed = true; }
    if (inst.name == null) { inst.name = ""; changed = true; }
    if (inst.roles == null) { inst.roles = []; changed = true; }
  }
  return { out, changed };
}

function loadInstructorLibrary() {
  try {
    const arr = JSON.parse(localStorage.getItem(INSTRUCTOR_LIBRARY_KEY) || "[]");
    const norm = normalizeInstructorLibrary(Array.isArray(arr) ? arr : []);
    // If we fixed missing ids/fields, persist once so future loads are clean
    if (norm.changed) {
      try { localStorage.setItem(INSTRUCTOR_LIBRARY_KEY, JSON.stringify(norm.out)); } catch(_) {}
    }
    return norm.out;
  } catch(e) { return []; }
}
function saveInstructorLibrary() {
  const norm = normalizeInstructorLibrary(Array.isArray(instructorLibrary) ? instructorLibrary : []);
  instructorLibrary = norm.out;
  localStorage.setItem(INSTRUCTOR_LIBRARY_KEY, JSON.stringify(norm.out));
  if (typeof refreshContextInstructorDatalists === "function") {
    try { refreshContextInstructorDatalists(); } catch(e) {}
  }
}


// ==========================
// LIBRARY TRANSFER (Export / Import) — non destructif
// Objectif: migrer bibliothèques entre origins (local ↔ Netlify) sans console
// Export: diverLibrary + instructorLibrary
// Import: merge add-only + upgrade-only (aucun écrasement)
// ==========================
function exportDivinglogLibrary() {
  try {
    const payload = {
      schema: "divinglog_library_export_v1",
      exportedAt: (new Date()).toISOString(),
      diverLibrary: Array.isArray(diverLibrary) ? diverLibrary : [],
      instructorLibrary: Array.isArray(instructorLibrary) ? instructorLibrary : []
    };

    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "divinglog_library_export.json";
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => { try { URL.revokeObjectURL(url); } catch(_){} }, 500);
    toast && toast("✅ Bibliothèque exportée (JSON).");
  } catch (e) {
    console.error(e);
    toast && toast("❌ Export impossible.");
  }
}

function mergeDiverRecord(existing, incoming) {
  // existing is an object in diverLibrary, incoming is from import file
  // Rules: add-only + upgrade-only aptitude; never overwrite existing non-empty strings
  let changed = false;

  const pick = (key) => String(incoming && incoming[key] != null ? incoming[key] : "").trim();
  const setIfEmpty = (key, val) => {
    const cur = String(existing && existing[key] != null ? existing[key] : "").trim();
    if (!cur && val) { existing[key] = val; changed = true; }
  };

  // Name: never change (identity)
  // Licence: fill if missing
  setIfEmpty("licence", pick("licence"));
  // Cert: fill if missing
  setIfEmpty("cert", pick("cert"));

  // Aptitudes: upgrade-only (never downgrade)
  const incApt = pick("aptitudes");
  if (incApt) {
    const curApt = String(existing.aptitudes || "").trim();
    const next = upgradeOnlyAptitude(curApt, incApt);
    if (next !== curApt) { existing.aptitudes = next; changed = true; }
  }

  return changed;
}

function importDivinglogLibraryPayload(payload) {
  // Payload can be {diverLibrary:[], instructorLibrary:[]} or legacy array of divers
  try {
    const p = payload || {};
    const incomingDivers = Array.isArray(p.diverLibrary) ? p.diverLibrary
                         : (Array.isArray(p) ? p : []);
    const incomingInstr = Array.isArray(p.instructorLibrary) ? p.instructorLibrary : [];

    if (!Array.isArray(diverLibrary)) diverLibrary = [];
    if (!Array.isArray(instructorLibrary)) instructorLibrary = loadInstructorLibrary();

    // --- Merge divers (by licence first, else by normalized name)
    let addedDivers = 0, changedDivers = 0;

    for (const d of incomingDivers) {
      normalizeDiverRecord(d);
      const name = String(d && d.name ? d.name : "").trim();
      if (!name) continue;

      // find existing by licence/name using existing helper (upgrade-only logic already used elsewhere)
      const existing = findDiverByLicenceOrName(String(d.licence || ""), name);

      if (!existing) {
        // create new diver, keep incoming fields
        const diver = {
          id: "d_" + Date.now() + "_" + Math.random().toString(36).slice(2),
          name,
          licence: String(d.licence || "").trim(),
          cert: String(d.cert || "").trim(),
          aptitudes: String(d.aptitudes || "").trim()
        };

        normalizeDiverRecord(diver);

        while (diverLibrary.some(x => x && x.id === diver.id)) {
          diver.id = "d_" + Date.now() + "_" + Math.random().toString(36).slice(2);
        }
        diverLibrary.push(diver);
        addedDivers++;
      } else {
        if (mergeDiverRecord(existing, d)) {
          normalizeDiverRecord(existing);
          changedDivers++;
        }
      }
    }

    // Persist divers (uses existing stable helper)
    try { saveDiverLibrary(); } catch(e) { console.error(e); }

    pdjAfterDiverLibraryMutation();

    // --- Merge instructors: add-only by name
    let addedInstr = 0;
    for (const inst of incomingInstr) {
      const nm = String(inst && inst.name ? inst.name : "").trim();
      if (!nm) continue;
      // Ensure into instructorLibrary (existing helper already persists)
      const beforeLen = instructorLibrary.length;
      ensureInstructorByName(nm);
      if (instructorLibrary.length > beforeLen) addedInstr++;
    }

    // Refresh lists/UI
    try { refreshContextInstructorDatalists(); } catch(_) {}
    try { renderPlongeursDuJourSelector && renderPlongeursDuJourSelector(); } catch(_) {}

    toast && toast(`✅ Import OK — +${addedDivers} plongeurs, ${changedDivers} complétés, +${addedInstr} DP/instructeurs.`);
  } catch (e) {
    console.error(e);
    toast && toast("❌ Import impossible (JSON invalide).");
  }
}

function importDivinglogLibraryFromFile(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const raw = String(reader.result || "");
      const payload = JSON.parse(raw);
      importDivinglogLibraryPayload(payload);
    } catch (e) {
      console.error(e);
      toast && toast("❌ Import impossible (JSON invalide).");
    }
  };
  reader.onerror = () => { toast && toast("❌ Import impossible (lecture)."); };
  reader.readAsText(file);
}

// ==========================
// CSV IMPORT (centre) — conversion automatique vers payload JSON DivingLog
// Règle: le CSV déclare explicitement les instructeurs via colonnes role/level (pas d'inférence)
// Colonnes reconnues (synonymes):
//  - name | nom
//  - aptitudes | aptitude
//  - cert | certification
//  - licence | license
//  - role
//  - level
// Séparateur: auto-detect ',' ou ';' sur la première ligne non vide
// Gère les guillemets CSV standards.
// ==========================
function detectCsvDelimiter(line) {
  const s = String(line || "");
  const c1 = (s.match(/;/g) || []).length;
  const c2 = (s.match(/,/g) || []).length;
  if (c1 === 0 && c2 === 0) return ";";
  return (c1 >= c2) ? ";" : ",";
}
function csvParseLine(line, delim) {
  const out = [];
  let cur = "";
  let inQuotes = false;
  const s = String(line || "");
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (inQuotes) {
      if (ch === '"') {
        const next = s[i + 1];
        if (next === '"') { cur += '"'; i++; }
        else { inQuotes = false; }
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"') inQuotes = true;
      else if (ch === delim) { out.push(cur); cur = ""; }
      else { cur += ch; }
    }
  }
  out.push(cur);
  return out.map(x => String(x).trim());
}
function csvTextToRows(csvText) {
  const raw = String(csvText || "").replace(/^\uFEFF/, ""); // strip BOM
  const lines = raw.split(/\r\n|\n|\r/).filter(l => String(l).trim().length > 0);
  if (!lines.length) return { headers: [], rows: [] };
  const delim = detectCsvDelimiter(lines[0]);
  const headers = csvParseLine(lines[0], delim).map(h => String(h || "").trim());
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = csvParseLine(lines[i], delim);
    // normalize to headers length
    const row = {};
    for (let j = 0; j < headers.length; j++) {
      row[headers[j]] = (cols[j] != null) ? cols[j] : "";
    }
    rows.push(row);
  }
  return { headers, rows };
}
function normalizeCsvKey(k) {
  return String(k || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "")
    .replace(/[-_]/g, "");
}
function csvRowsToDivinglogPayload(rowsObj) {
  const rows = rowsObj && Array.isArray(rowsObj.rows) ? rowsObj.rows : [];

  // --- Helpers: deterministic FFESSM cert merge (no change to aptitudes) ---
  const CERT_RANK = {
    "FFESSM N1": 1,
    "FFESSM N2": 2,
    "FFESSM N3": 3,
    "FFESSM N4": 4,
    "FFESSM E1": 5,
    "FFESSM E2": 6,
    "FFESSM E3": 7,
    "FFESSM E4": 8
  };

  function canonCertLabel(s) {
    const t = String(s || "").trim().replace(/\s+/g, " ");
    if (!t) return "";
    // normalize common patterns
    let u = t.toUpperCase();

    // Main levels (accept "N3", "FFESSM N3", "FFESSM N 3", etc.)
    const n = u.match(/\bN\s*([1-4])\b/);
    const e = u.match(/\bE\s*([1-4])\b/);
    if (n && u.includes("FFESSM")) return `FFESSM N${n[1]}`;
    if (e && u.includes("FFESSM")) return `FFESSM E${e[1]}`;

    // If FFESSM missing but token clearly looks like N3/E2, still accept
    if (n) return `FFESSM N${n[1]}`;
    if (e) return `FFESSM E${e[1]}`;

    return t; // fallback (non-ranked)
  }

  function extractMainCert(certStr) {
    const label = canonCertLabel(certStr);
    if (label in CERT_RANK) return label;
    return "";
  }

  function extractNitrox(certStr) {
    const u = String(certStr || "").toUpperCase();
    if (!u.includes("NITROX")) return "";
    // confirmed if "CONF" appears (Confirmé / Confirmed)
    if (u.includes("CONF")) return "FFESSM Nitrox Confirmé";
    return "FFESSM Nitrox";
  }

  function bestMainCert(a, b) {
    if (!a) return b || "";
    if (!b) return a || "";
    const ra = CERT_RANK[a] || 0;
    const rb = CERT_RANK[b] || 0;
    return (rb > ra) ? b : a;
  }

  const pick = (row, keys) => {
    for (const k of keys) {
      // exact header
      if (row[k] != null && String(row[k]).trim()) return String(row[k]).trim();
      // normalized match
      const nk = normalizeCsvKey(k);
      for (const hk in row) {
        if (normalizeCsvKey(hk) === nk) {
          const v = String(row[hk] || "").trim();
          if (v) return v;
        }
      }
    }
    return "";
  };

  // Aggregate by diver name (key = normalizeName(name))
  const agg = new Map();
  const isInstructorRow = (role, level) => !!(String(role || "").trim() || String(level || "").trim());

  for (const r of rows) {
    const name = pick(r, ["name", "nom"]);
    if (!name) continue;

    const licence = pick(r, ["licence", "license"]);
    const cert = pick(r, ["cert", "certification"]);
    const aptitudes = pick(r, ["aptitudes", "aptitude"]);
    const role = pick(r, ["role"]);
    const level = pick(r, ["level"]);

    const key = (typeof normalizeName === "function" ? normalizeName(name) : name.toLowerCase().trim());
    if (!key) continue;

    if (!agg.has(key)) {
      agg.set(key, {
        name,
        licence: "",
        aptitudes: "",
        mainCert: "",
        nitrox: "",
        isInstructor: false
      });
    }

    const item = agg.get(key);

    // add-only fields (no overwrite)
    if (!item.licence && licence) item.licence = licence;
    if (!item.aptitudes && aptitudes) item.aptitudes = aptitudes;

    // cert merge:
    // - main FFESSM level uses ranking table (upgrade-only)
    // - nitrox is additive (keep best: Confirmé > Nitrox)
    const main = extractMainCert(cert);
    if (main) item.mainCert = bestMainCert(item.mainCert, main);

    const nx = extractNitrox(cert);
    if (nx) {
      if (!item.nitrox) item.nitrox = nx;
      else if (item.nitrox === "FFESSM Nitrox" && nx === "FFESSM Nitrox Confirmé") item.nitrox = nx;
    }

    if (isInstructorRow(role, level)) item.isInstructor = true;
  }

  const divers = [];
  const instr = [];

  for (const [k, item] of agg.entries()) {
    // Build cert string (main + nitrox additive)
    let certOut = "";
    if (item.mainCert) certOut = item.mainCert;
    if (item.nitrox) certOut = certOut ? (certOut + " | " + item.nitrox) : item.nitrox;

    divers.push({
      name: item.name,
      licence: item.licence,
      cert: certOut,
      aptitudes: item.aptitudes
    });

    if (item.isInstructor) instr.push({ name: item.name });
  }

  return { diverLibrary: divers, instructorLibrary: instr };
}
function importDivinglogCsvFromFile(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const raw = String(reader.result || "");
      const rowsObj = csvTextToRows(raw);
      const payload = csvRowsToDivinglogPayload(rowsObj);
      const dCount = Array.isArray(payload.diverLibrary) ? payload.diverLibrary.length : 0;
      const iCount = Array.isArray(payload.instructorLibrary) ? payload.instructorLibrary.length : 0;
      // Reuse existing non-destructive import
      importDivinglogLibraryPayload(payload);
      toast && toast(`✅ CSV importé — ${dCount} plongeurs, ${iCount} instructeurs.`);
    } catch (e) {
      console.error(e);
      toast && toast("❌ Import CSV impossible (format).");
    }
  };
  reader.onerror = () => { toast && toast("❌ Import CSV impossible (lecture)."); };
  reader.readAsText(file);
}

function getInstructorById(id) {
  return (Array.isArray(instructorLibrary) ? instructorLibrary : []).find(x => x && x.id === id) || null;
}
function makeInstructorId() {
  return "inst_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,7);
}
// ===== Instructor lookup helpers (name-based) =====
function getInstructorByName(name) {
  const key = normalizeName(name);
  if (!key) return null;
  return (Array.isArray(instructorLibrary) ? instructorLibrary : []).find(inst => {
    const n = inst && inst.name ? inst.name : "";
    return normalizeName(n) === key;
  }) || null;
}

// Ensure an instructor exists in instructorLibrary (used for DP / safety surface to guarantee PDF fields)

// Seed instructor library on first run / after purge (non-destructive):
// - only runs when INSTRUCTOR_LIBRARY_KEY is missing/empty
// - sources candidates from BASE_DIVERS and diverLibrary when aptitudes mention DP / encadrant (E1..E4)
function seedInstructorLibraryIfEmpty() {
  let existing = [];
  try {
    existing = JSON.parse(localStorage.getItem(INSTRUCTOR_LIBRARY_KEY) || "[]");
  } catch(e) { existing = []; }

  if (Array.isArray(existing) && existing.length > 0) return false;

  const names = [];

  function isInstructorApt(apt) {
    const s = String(apt || "").toUpperCase();
    if (!s) return false;
    if (s.includes("DP")) return true;
    // FFESSM encadrant markers (E1..E4), allow "E4" or "E4," etc.
    if (/\bE[1-4]\b/.test(s)) return true;
    if (s.includes("ENCADR")) return true;
    if (s.includes("FORMATEUR")) return true;
    if (s.includes("INSTRUCT")) return true;
    return false;
  }

  function pushName(n) {
    const nm = String(n || "").trim();
    if (!nm) return;
    if (!names.includes(nm)) names.push(nm);
  }

  try {
    (Array.isArray(BASE_DIVERS) ? BASE_DIVERS : []).forEach(d => {
      if (!d) return;
      if (isInstructorApt(d.aptitudes)) pushName(d.name);
    });
  } catch(_) {}

  try {
    (Array.isArray(diverLibrary) ? diverLibrary : []).forEach(d => {
      if (!d) return;
      if (isInstructorApt(d.aptitudes)) pushName(d.name);
    });
  } catch(_) {}

  if (names.length === 0) return false;

  // Ensure these names exist in instructorLibrary, without overwriting anything else
  names.forEach(nm => { try { ensureInstructorByName(nm); } catch(e) {} });

  return true;
}

// Sync instructors from diverLibrary / BASE_DIVERS into instructorLibrary (non-destructive)
// - adds only (never removes / never overwrites existing instructor entries)
// - useful after Netlify origin change (localStorage is per-domain) or after storage purge
function syncInstructorsFromDiverLibrary(opts) {
  const onlyIfEmpty = !!(opts && opts.onlyIfEmpty);
  let current = [];
  try { current = JSON.parse(localStorage.getItem(INSTRUCTOR_LIBRARY_KEY) || "[]"); } catch(e) { current = []; }
  if (onlyIfEmpty && Array.isArray(current) && current.length > 0) return 0;

  // Ensure diver library is present (source of truth for names)
  if (!Array.isArray(diverLibrary) || diverLibrary.length === 0) {
    try { loadDiverLibrary(); } catch(e) {}
  }

  const pool = [];
  try {
    if (Array.isArray(BASE_DIVERS)) pool.push.apply(pool, BASE_DIVERS);
  } catch(e) {}
  if (Array.isArray(diverLibrary)) pool.push.apply(pool, diverLibrary);

  const added = new Set();
  const before = new Set((Array.isArray(current) ? current : []).map(x => normalizeName(x && x.name)));

  function isInstructorCandidate(d) {
    if (!d || !d.name) return false;
    const apt = String(d.aptitudes || d.aptitude || "").toUpperCase();
    const cert = String(d.cert || "").toUpperCase();
    const s = (apt + " " + cert).trim();
    if (!s) return false;
    if (s.includes("DP")) return true;
    if (/\bE[1-4]\b/.test(s)) return true;
    if (s.includes("ENCADR")) return true;
    if (s.includes("FORMATEUR")) return true;
    if (s.includes("INSTRUCT")) return true;
    return false;
  }

  pool.forEach(d => {
    if (!isInstructorCandidate(d)) return;
    const nm = String(d.name || "").trim();
    if (!nm) return;
    const key = normalizeName(nm);
    if (!key || before.has(key) || added.has(key)) return;
    // Reuse existing plumbing (adds + persists)
    if (typeof ensureInstructorByName === "function") {
      ensureInstructorByName(nm);
      added.add(key);
    }
  });

  return added.size;
}


function ensureInstructorByName(name) {
  const nm = (name || "").trim();
  if (!nm) return null;
  let inst = getInstructorByName(nm);
  if (inst) return inst;

  const newInst = { id: makeInstructorId(), name: nm, speciality: "", active: true, roles: [], aptitude: "", certification: "", licence: "" };
  instructorLibrary = Array.isArray(instructorLibrary) ? instructorLibrary : [];
  instructorLibrary.push(newInst);
  saveInstructorLibrary();
  return newInst;
}

// Refresh Contexte du jour datalists (DP / surface) from instructorLibrary
function refreshContextInstructorDatalists() {
  // DP datalist
  const dpList = document.getElementById("dp_list");
  if (dpList) {
    dpList.innerHTML = "";
    (Array.isArray(instructorLibrary) ? instructorLibrary : [])
      .filter(x => x && x.active !== false && x.name)
      .sort((a,b)=> String(a.name).localeCompare(String(b.name)))
      .forEach(inst => {
        const opt = document.createElement("option");
        opt.value = String(inst.name).trim();
        dpList.appendChild(opt);
      });
  }
}

// Lightweight picker overlay (used for DP now; can be reused later for encadrant/formateur)
function openSimpleNamePickerOverlay(opts) {
  const title = (opts && opts.title) ? String(opts.title) : "Sélection";
  const initialValue = (opts && opts.initialValue) ? String(opts.initialValue) : "";
  const placeholder = (opts && opts.placeholder) ? String(opts.placeholder) : "Nom et prénom";
  const onConfirm = (opts && typeof opts.onConfirm === "function") ? opts.onConfirm : function(){};
  const onClose = (opts && typeof opts.onClose === "function") ? opts.onClose : function(){};

  // Remove existing overlay if any
  const prev = document.getElementById("simpleNamePickerOverlay");
  if (prev && prev.parentNode) prev.parentNode.removeChild(prev);

  function closeOverlay(){
    const el = document.getElementById("simpleNamePickerOverlay");
    if (el && el.parentNode) el.parentNode.removeChild(el);
    try { onClose(); } catch(_) {}
  }

  const overlay = document.createElement("div");
  overlay.id = "simpleNamePickerOverlay";
  overlay.className = "modal-overlay";

  const card = document.createElement("div");
  card.className = "modal-card";
  card.style.maxWidth = "420px";
  card.style.width = "100%";
  card.style.padding = "14px 14px 12px";

  const h = document.createElement("div");
  h.style.fontWeight = "800";
  h.style.fontSize = "16px";
  h.style.marginBottom = "10px";
  h.textContent = title;

  const input = document.createElement("input");
  input.type = "text";
  input.value = initialValue;
  input.placeholder = placeholder;
  input.style.width = "100%";
  input.style.padding = "10px 12px";
  input.style.borderRadius = "10px";
  input.style.border = "1px solid rgba(0,0,0,0.2)";
  // attach to a datalist when present (enables autocomplete while typing)
  const _listId = (opts && opts.listId) ? String(opts.listId) : ((document.getElementById("dp_list")) ? "dp_list" : "");
  if (_listId) input.setAttribute("list", _listId);

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "10px";
  actions.style.justifyContent = "flex-end";
  actions.style.marginTop = "12px";

  const btnCancel = document.createElement("button");
  btnCancel.type = "button";
  btnCancel.className = "btn";
  btnCancel.textContent = "Annuler";

  const btnOk = document.createElement("button");
  btnOk.type = "button";
  btnOk.className = "btn btn-primary";
  btnOk.textContent = "OK";

  function close(){
    try { document.body.classList.remove("modal-open"); } catch(_) {}
    closeOverlay();
  }
  function confirm(){
    const v = String(input.value || "").trim();
    if (!v) { close(); return; }
    try { onConfirm(v); } catch(e) { console.warn("picker confirm error", e); }
    close();
  }

  btnCancel.addEventListener("click", close);
  btnOk.addEventListener("click", confirm);
  overlay.addEventListener("click", function(e){ if (e.target === overlay) close(); });
  input.addEventListener("keydown", function(e){
    if (e.key === "Enter") { e.preventDefault(); confirm(); }
    if (e.key === "Escape") { e.preventDefault(); close(); }
  });

  actions.appendChild(btnCancel);
  actions.appendChild(btnOk);
  card.appendChild(h);
  card.appendChild(input);
  card.appendChild(actions);
  overlay.appendChild(card);
  document.body.appendChild(overlay);
  try { document.body.classList.add("modal-open"); } catch(_) {}
  setTimeout(function(){ try { input.focus(); input.select(); } catch(_) {} }, 0);
}




// ===== Group pickers (Type + Encadrant/Formateur/Référent) =====

// PATCH57: Group header "book" action-only menu (replaces duplicated Type + Encadrant controls)
function openGroupHeaderBookMenuOverlay(opts){
  const gid = opts && opts.gid ? String(opts.gid) : "";
  if (!gid) return;

  const practice = (groupPractice && groupPractice[gid]) ? groupPractice[gid] : "AUTONOME";

  const overlay = document.createElement("div");
  overlay.className = "group-select-overlay";
  overlay.addEventListener("click", (ev) => {
    if (ev.target === overlay) {
      try { overlay.remove(); } catch(_) {}
    }
  });

  const dialog = document.createElement("div");
  dialog.className = "group-select-dialog";

  const title = document.createElement("div");
  title.className = "group-select-title";
  title.textContent = "Modifier " + gid;

  const sub = document.createElement("div");
  sub.className = "group-select-sub";
  sub.textContent = "Type & " + ((practice === "AUTONOME") ? "référent" : (practice === "FORMATION" ? "formateur" : "encadrant"));

  const buttons = document.createElement("div");
  buttons.className = "group-select-buttons";

  const btnType = document.createElement("button");
  btnType.type = "button";
  btnType.className = "btn";
  btnType.textContent = "Type (" + practice + ")";
  btnType.addEventListener("click", (ev) => {
    ev.stopPropagation();
    try { overlay.remove(); } catch(_) {}
    openGroupTypePickerOverlay({
      gid,
      current: (groupPractice && groupPractice[gid]) ? groupPractice[gid] : practice,
      onSelect: (val) => {
        groupPractice[gid] = val;
        saveGroupPractice();

        // If switching to AUTONOME, clear instructor supervisor if any
        if (groupPractice[gid] === "AUTONOME") {
          const s = groupSupervisors ? groupSupervisors[gid] : null;
          if (s && s.type === "INSTRUCTOR_LIB") {
            delete groupSupervisors[gid];
            saveGroupSupervisors();
          }
        }
        updateGroupHeadersWithLeaders();
        renderValidationBanner();
      }
    });
  });

  const btnSup = document.createElement("button");
  btnSup.type = "button";
  btnSup.className = "btn";
  btnSup.textContent = (practice === "AUTONOME") ? "Référent (membre du groupe)" : (practice === "FORMATION" ? "Formateur (base)" : "Encadrant (base)");
  btnSup.addEventListener("click", (ev) => {
    ev.stopPropagation();
    try { overlay.remove(); } catch(_) {}
    openGroupSupervisorPickerOverlay({ gid });
  });

  buttons.appendChild(btnType);
  buttons.appendChild(btnSup);

  const footer = document.createElement("div");
  footer.className = "group-select-footer";

  const cancel = document.createElement("span");
  cancel.className = "group-select-cancel";
  cancel.textContent = "Fermer";
  cancel.addEventListener("click", (ev) => {
    ev.stopPropagation();
    try { overlay.remove(); } catch(_) {}
  });

  footer.appendChild(cancel);

  dialog.appendChild(title);
  dialog.appendChild(sub);
  dialog.appendChild(buttons);
  dialog.appendChild(footer);

  overlay.appendChild(dialog);
  document.body.appendChild(overlay);
}
function openGroupTypePickerOverlay(opts){
  const gid = opts && opts.gid ? String(opts.gid) : "";
  const current = (opts && opts.current) ? String(opts.current) : "AUTONOME";
  const onSelect = (opts && typeof opts.onSelect === "function") ? opts.onSelect : function(){};

  const prev = document.getElementById("groupTypePickerOverlay");
  if (prev && prev.parentNode) prev.parentNode.removeChild(prev);

  const overlay = document.createElement("div");
  overlay.id = "groupTypePickerOverlay";
  overlay.className = "modal-overlay";

  const card = document.createElement("div");
  card.className = "modal-card";
  card.style.maxWidth = "420px";
  card.style.width = "100%";
  card.style.padding = "14px 14px 12px";

  const h = document.createElement("div");
  h.style.fontWeight = "800";
  h.style.fontSize = "16px";
  h.style.marginBottom = "10px";
  h.textContent = "Choisir le type (" + gid + ")";

  const list = document.createElement("div");
  list.style.display = "flex";
  list.style.flexDirection = "column";
  list.style.gap = "10px";

  function close(){
    try { document.body.classList.remove("modal-open"); } catch(_) {}
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
  }

  ["AUTONOME","ENCADREE","FORMATION"].forEach(val => {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "btn " + (val === current ? "btn-primary" : "");
    b.textContent = val;
    b.addEventListener("click", () => {
      try { onSelect(val); } catch(e) {}
      close();
    });
    list.appendChild(b);
  });

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.justifyContent = "flex-end";
  actions.style.marginTop = "12px";

  const btnCancel = document.createElement("button");
  btnCancel.type = "button";
  btnCancel.className = "btn";
  btnCancel.textContent = "Annuler";
  btnCancel.addEventListener("click", close);

  actions.appendChild(btnCancel);

  overlay.addEventListener("click", function(e){ if (e.target === overlay) close(); });

  card.appendChild(h);
  card.appendChild(list);
  card.appendChild(actions);
  overlay.appendChild(card);
  document.body.appendChild(overlay);
  try { document.body.classList.add("modal-open"); } catch(_) {}
}

function openGroupSupervisorPickerOverlay(opts){
  const gid = opts && opts.gid ? String(opts.gid) : "";
  const practice = (groupPractice && groupPractice[gid]) ? groupPractice[gid] : "AUTONOME";
  const sup = groupSupervisors ? groupSupervisors[gid] : null;

  if (practice === "AUTONOME") {
    const members = Array.isArray(groupAssignments?.[gid]) ? groupAssignments[gid] : [];
    const cur = (sup && sup.type === "IN_GROUP") ? (sup.value || "") : "";

    // build a datalist for members (overlay-local)
    const listId = "tmp_member_list_" + gid;
    let dl = document.getElementById(listId);
    if (dl && dl.parentNode) dl.parentNode.removeChild(dl);
    dl = document.createElement("datalist");
    dl.id = listId;
    members.forEach(n => {
      const opt = document.createElement("option");
      opt.value = String(n || "");
      dl.appendChild(opt);
    });
    document.body.appendChild(dl);

    openSimpleNamePickerOverlay({
      title: "Choisir un référent (" + gid + ")",
      initialValue: cur,
      placeholder: "Nom dans le groupe",
      // override list to members list
      listId: listId,
      onClose: () => { try { const x = document.getElementById(listId); if (x && x.parentNode) x.parentNode.removeChild(x); } catch(_) {} },
      onConfirm: (name) => {
        const v = String(name || "").trim();
        if (!v) {
          delete groupSupervisors[gid];
        } else {
          groupSupervisors[gid] = { type: "IN_GROUP", value: v };
        }
        saveGroupSupervisors();
        updateGroupHeadersWithLeaders();
        renderValidationBanner();
      }
    });

    return;
  }

  // ENCADREE / FORMATION: choose from instructorLibrary by name (autocomplete via dp_list)
  let curName = "";
  if (sup && sup.type === "INSTRUCTOR_LIB" && sup.value) {
    const inst = getInstructorById(sup.value);
    if (inst && inst.name) curName = inst.name;
  }

  openSimpleNamePickerOverlay({
    title: (practice === "FORMATION") ? ("Choisir un formateur (" + gid + ")") : ("Choisir un encadrant (" + gid + ")"),
    initialValue: curName,
    placeholder: "Nom et prénom (tape pour rechercher)",
    onConfirm: (name) => {
      const nm = String(name || "").trim();
      if (!nm) {
        delete groupSupervisors[gid];
        saveGroupSupervisors();
        updateGroupHeadersWithLeaders();
        renderValidationBanner();
        return;
      }
      const inst = ensureInstructorByName(nm);
      if (!inst || !inst.id) return;
      groupSupervisors[gid] = { type: "INSTRUCTOR_LIB", value: inst.id };
      saveGroupSupervisors();
      refreshContextInstructorDatalists(); // keep lists fresh
      updateGroupHeadersWithLeaders();
      renderValidationBanner();
    }
  });
}


function getGroupRecord(groupId) {
  if (!groupId) return null;
  if (!groupDetails[groupId]) {
    groupDetails[groupId] = {
      before: {},
      after: {}
    };
  }
  return groupDetails[groupId];
}

function ensureBeforeDiversStore(groupId) {
  const rec = getGroupRecord(groupId);
  if (!rec.before) rec.before = {};
  if (!rec.before.divers || typeof rec.before.divers !== "object") rec.before.divers = {};
  return rec.before.divers;
}


function ensureAfterDiversStore(groupId) {
  const rec = getGroupRecord(groupId);
  if (!rec.after) rec.after = {};
  if (!rec.after.divers || typeof rec.after.divers !== "object") rec.after.divers = {};
  return rec.after.divers;
}

function loadPaliersGeneric(scope, groupId, diverName) {
  const rec = getGroupRecord(groupId);
  if (!rec) return [];

  // PATCH16: allow "after_group" storage for FORMATION group paliers
  if (scope === "after_group") {
    const after = rec.after || {};
    return Array.isArray(after.groupPaliersDone) ? after.groupPaliersDone : [];
  }

  const key = normalizeName(diverName);
  if (scope === "after") {
    const divers = rec.after && rec.after.divers ? rec.after.divers : {};
    const entry = divers[key] || {};
    return Array.isArray(entry.paliersDone) ? entry.paliersDone : [];
  } else {
    const divers = rec.before && rec.before.divers ? rec.before.divers : {};
    const entry = divers[key] || {};
    return Array.isArray(entry.paliers) ? entry.paliers : [];
  }
}

function savePaliersGeneric(scope, groupId, diverName, paliers) {
  const key = normalizeName(diverName);

  // PATCH16: allow "after_group" storage for FORMATION group paliers
  if (scope === "after_group") {
    const rec = getGroupRecord(groupId);
    if (!rec) return;
    if (!rec.after) rec.after = {};
    rec.after.groupPaliersDone = Array.isArray(paliers) ? paliers : [];
    saveGroupDetails();
    return;
  }

  if (scope === "after" || scope === "after_group") {
    const diversStore = ensureAfterDiversStore(groupId);
    if (!diversStore[key]) diversStore[key] = {};
    diversStore[key].paliersDone = Array.isArray(paliers) ? paliers : [];
  } else {
    const diversStore = ensureBeforeDiversStore(groupId);
    if (!diversStore[key]) diversStore[key] = {};
    diversStore[key].paliers = Array.isArray(paliers) ? paliers : [];
    diversStore[key].source = "manual";
  }
  saveGroupDetails();
}



// PATCH16: FORMATION – paliers groupe (APRÈS)
// Visible only when groupPractice[groupId] === "FORMATION".
function isFormationGroup(groupId){
  try { return (groupPractice && groupPractice[groupId] === "FORMATION"); } catch(e){ return false; }
}

function getAfterGroupPaliers(groupId){
  const rec = getGroupRecord(groupId);
  const after = rec && rec.after ? rec.after : null;
  const gp = after && Array.isArray(after.groupPaliersDone) ? after.groupPaliersDone : [];
  return gp;
}

function applyAfterGroupPaliersToDivers(groupId){
  const rec = getGroupRecord(groupId);
  if (!rec) return;
  if (!rec.after) rec.after = {};
  if (!rec.after.divers || typeof rec.after.divers !== "object") rec.after.divers = {};
  const gp = getAfterGroupPaliers(groupId);
  if (!gp.length) return;

  // One-shot propagation: only fill divers with no paliersDone yet.
  const names = getAfterDiverNames(groupId);
  names.forEach((diverName) => {
    const key = normalizeName(diverName);
    const entry = rec.after.divers[key] || (rec.after.divers[key] = {});
    if (!Array.isArray(entry.paliersDone) || entry.paliersDone.length === 0) {
      entry.paliersDone = gp.map(p => ({ depth: p.depth, time: p.time }));
    }
  });

  saveGroupDetails();
  try { renderAfterDivers(groupId); } catch(e) {}
}

function updateAfterFormationBlockVisibility(groupId){
  const box = document.getElementById("after_formation_group_paliers");
  if (!box) return;
  box.style.display = isFormationGroup(groupId) ? "" : "none";
}

// Hook visibility when entering AFTER view
(function(){
  const _openAfterView = window.openAfterView;
  if (typeof _openAfterView === "function") {
    window.openAfterView = function(groupId){
      const r = _openAfterView.apply(this, arguments);
      try { updateAfterFormationBlockVisibility(groupId); } catch(e) {}
      return r;
    };
  }
})();

// Button handlers (delegated)
document.addEventListener("click", function(ev){
  const t = ev.target;
  if (!t) return;

  if (t.id === "btn_after_group_paliers_edit") {
    if (!currentGroupId) return;
    // Open modal in AFTER_GROUP scope (stored at rec.after.groupPaliersDone)
    openPalierModal(currentGroupId, "__GROUP__", "after_group");
  }

  if (t.id === "btn_after_group_paliers_apply") {
    if (!currentGroupId) return;
    applyAfterGroupPaliersToDivers(currentGroupId);
  }
});

let palierModalEl = null;
let palierModalCtx = null;

function ensurePalierModal() {
  if (palierModalEl) return palierModalEl;

  const overlay = document.createElement("div");
  overlay.className = "palier-modal";
  overlay.style.display = "none";

  const dialog = document.createElement("div");
  dialog.className = "palier-modal-dialog";

  const title = document.createElement("div");
  title.className = "palier-modal-title";
  title.id = "palier_modal_title";

  const quick = document.createElement("div");
  quick.className = "palier-quick";
  quick.id = "palier_quick";

  const list = document.createElement("div");
  list.className = "palier-list";
  list.id = "palier_list";

  const footer = document.createElement("div");
  footer.className = "palier-modal-footer";

  const btnCancel = document.createElement("button");
  btnCancel.type = "button";
  btnCancel.className = "btn";
  btnCancel.textContent = "Annuler";
  btnCancel.addEventListener("click", closePalierModal);

  const btnSave = document.createElement("button");
  btnSave.type = "button";
  btnSave.className = "btn btn-primary";
  btnSave.textContent = "Sauvegarder";
  btnSave.addEventListener("click", function () {
    if (!palierModalCtx) return;

    // read current rows
    const rows = Array.from(document.querySelectorAll("#palier_list .palier-row"));
    const paliers = [];
    rows.forEach(r => {
      const depth = Number(r.getAttribute("data-depth"));
      const input = r.querySelector("input[type='number']");
      const time = input && input.value !== "" ? Number(input.value) : 0;
      if (!isNaN(depth) && depth > 0) {
        paliers.push({ depth, time });
      }
    });

    // store
    const { groupId, diverName, scope } = palierModalCtx;
    savePaliersGeneric(scope || "before", groupId, diverName, paliers);
    // Refresh AFTER screen immediately so the per-diver table updates
    if ((scope || "before") === "after" || (scope || "before") === "after_group") {
  // CRITICAL: persist "valeurs réalisées" (DOM -> state) before rerender, otherwise they get wiped
      try { saveGroupDetails(); } catch(e) {}
      try { renderAfterDivers(groupId); } catch(e) {}
    }
    closePalierModal();
    renderPlongeursDuJourSelector(); // refresh status color
    renderGroupAssignments();        // keep UI consistent
  });

  footer.appendChild(btnCancel);
  footer.appendChild(btnSave);

  dialog.appendChild(title);
  dialog.appendChild(quick);
  dialog.appendChild(list);
  dialog.appendChild(footer);

  overlay.appendChild(dialog);
  document.body.appendChild(overlay);

  overlay.addEventListener("click", function (ev) {
    if (ev.target === overlay) closePalierModal();
  });

  palierModalEl = overlay;
  return palierModalEl;
}

function closePalierModal() {
  const el = ensurePalierModal();
  el.style.display = "none";
  palierModalCtx = null;
}

function mountPalierRows(paliers) {
  const list = document.getElementById("palier_list");
  if (!list) return;
  list.innerHTML = "";

  const addRow = (depth, time) => {
    const row = document.createElement("div");
    row.className = "palier-row";
    row.setAttribute("data-depth", String(depth));

    const d = document.createElement("div");
    d.className = "pal-depth";
    d.textContent = depth + " m";

    const t = document.createElement("input");
    t.type = "number";
    t.min = "0";
    t.step = "1";
    t.value = (time != null ? String(time) : "");

    const del = document.createElement("div");
    del.className = "palier-del";
    del.textContent = "✕";
    del.addEventListener("click", function () {
      row.remove();
    });

    row.appendChild(d);
    row.appendChild(t);
    row.appendChild(del);
    list.appendChild(row);
  };

  (paliers || []).forEach(p => addRow(p.depth, p.time));
}

function openPalierModal(groupId, diverName, scope = "before") {
  const overlay = ensurePalierModal();
  palierModalCtx = { groupId, diverName, scope };

  const title = document.getElementById("palier_modal_title");
  if (title) title.textContent = (scope === "after" ? "Paliers effectués — " : "Paliers — ") + diverName + " (" + groupId + ")";

  const quick = document.getElementById("palier_quick");
  if (quick) {
    quick.innerHTML = "";

    const mkBtn = (label, onClick) => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "btn group-mini-btn";
      b.textContent = label;
      b.addEventListener("click", onClick);
      return b;
    };

    [3, 6, 9, 12].forEach(depth => {
      quick.appendChild(mkBtn(depth + " m", function () {
        // add row if not existing
        const exists = document.querySelector('#palier_list .palier-row[data-depth="' + depth + '"]');
        if (!exists) {
          const list = document.getElementById("palier_list");
          if (!list) return;
          const row = document.createElement("div");
          row.className = "palier-row";
          row.setAttribute("data-depth", String(depth));

          const d = document.createElement("div");
          d.className = "pal-depth";
          d.textContent = depth + " m";

          const t = document.createElement("input");
          t.type = "number";
          t.min = "0";
          t.step = "1";
          t.value = "";

          const del = document.createElement("div");
          del.className = "palier-del";
          del.textContent = "✕";
          del.addEventListener("click", function () { row.remove(); });

          row.appendChild(d);
          row.appendChild(t);
          row.appendChild(del);
          list.appendChild(row);
        }
      }));
    });

    quick.appendChild(mkBtn("+ Ajouter", function () {
  // 1) récupérer les profondeurs déjà présentes dans la liste
  const rows = Array.from(document.querySelectorAll('#palier_list .palier-row[data-depth]'));
  const depths = rows
    .map(r => Number(r.getAttribute("data-depth")))
    .filter(n => !isNaN(n) && n > 0);

  // 2) dernier palier = max existant ; si vide -> start 15m
  let depth = (depths.length ? Math.max(...depths) : 12) + 3;

  // 3) éviter doublons : +3 jusqu’à profondeur libre
  while (document.querySelector('#palier_list .palier-row[data-depth="' + depth + '"]')) {
    depth += 3;
    if (depth > 300) return; // garde-fou
  }

  const list = document.getElementById("palier_list");
  if (!list) return;

  // 4) créer la ligne (copie conforme de ton code existant)
  const row = document.createElement("div");
  row.className = "palier-row";
  row.setAttribute("data-depth", String(depth));

  const d = document.createElement("div");
  d.className = "pal-depth";
  d.textContent = depth + " m";

  const t = document.createElement("input");
  t.type = "number";
  t.min = "0";
  t.step = "1";
  t.value = "";

  const del = document.createElement("div");
  del.className = "palier-del";
  del.textContent = "✕";
  del.addEventListener("click", function () { row.remove(); });

  row.appendChild(d);
  row.appendChild(t);
  row.appendChild(del);
  list.appendChild(row);
}));
  }

  // load current stored paliers for this diver in this group
  const paliers = loadPaliersGeneric(scope, groupId, diverName);
  mountPalierRows(paliers);

  overlay.style.display = "flex";
}

function openPalierEditorFromPlongeursDuJour(diverName) {
  const gid = getCurrentGroupOfDiver(diverName);
  if (!gid) {
    alert("Ce plongeur n’est affecté à aucun groupe. Affecte-le d’abord à un groupe.");
    return;
  }
  // Routing direct vers APRÈS: la couleur/état PALIERS dépend uniquement des paliers réalisés
  openPalierModal(gid, diverName, "after");
}

function diverHasAnyPaliers(diverName) {
  const key = normalizeName(diverName);
  if (!key) return false;

  // ✅ Statut PALIERS = UNIQUEMENT basé sur les paliers RÉALISÉS (APRÈS)
  // (le "prévu" Trimix via RT1 reste dans before.paliers mais ne pilote pas cet indicateur)
  const allGroupIds = Object.keys(groupDetails || {});
  for (const gid of allGroupIds) {
    const rec = groupDetails[gid];
    if (!rec || !rec.after) continue;

    const divers = rec.after.divers;
    if (!divers || typeof divers !== "object") continue;

    const entry = divers[key];
    const p = entry && Array.isArray(entry.paliersDone) ? entry.paliersDone : [];
    if (p.length > 0) return true;
  }
  return false;
}


function getDiverByName(name) {
  if (!name) return null;
  const lib = Array.isArray(diverLibrary) ? diverLibrary : [];
  return lib.find(d => d && d.name === name) || null;
}

function getAptitudeTextForDiver(name) {
  const d = getDiverByName(name);
  if (!d) return "—";
  // ton fichier utilise aptitudes (pluriel) dans BASE_DIVERS
  const a = (d.aptitudes && String(d.aptitudes).trim())
    ? String(d.aptitudes).trim()
    : ((d.aptitude && String(d.aptitude).trim()) ? String(d.aptitude).trim() : "—");
  return a;
}


// Step 3.4.3: decide if a diver should receive RT1-derived paliers (Trimix/CCR divers only)
function diverNeedsRT1(diverName) {
  const d = getDiverByName(diverName);
  if (!d) return false;
  const cert = (d.cert != null) ? String(d.cert) : "";
  const apt = (d.aptitudes != null) ? String(d.aptitudes) : "";
  const s = (cert + " " + apt).toUpperCase();
  // Minimal rule: require RT1 only for CCR or Trimix profiles (OC trimix or CCR).
  return (s.includes("CCR") || s.includes("TRIMIX"));
}

  function updatePlongeursJourStatus() {
    const statusEl = document.getElementById("plongeurs-jour-status");
    if (!statusEl) return;
    const count = Array.isArray(diversDuJour) ? diversDuJour.length : 0;
    if (count === 0) {
      statusEl.textContent = "Aucun plongeur sélectionné pour l'instant.";
    } else if (count === 1) {
      statusEl.textContent = "1 plongeur sélectionné pour aujourd'hui.";
    } else {
      statusEl.textContent = count + " plongeurs sélectionnés pour aujourd'hui.";
    }
  }

 function renderPlongeursDuJourSelector() {
  const container = document.getElementById("plongeurs-jour-list");
  if (!container) return;
  // Init PDJ tools + storages once (safe even if diverLibrary already loaded)
  if (!pdjToolsInitDone) {
    loadRecentDivers();
    loadFavoriteDivers();
    initPDJTools();
    pdjToolsInitDone = true;
  }
// Build / refresh aptitude filter options when library changed
  if (Array.isArray(diverLibrary) && diverLibrary.length > 0 && pdjAptOptionsDirty) {
    buildAptitudeFilterOptions();
    pdjAptOptionsDirty = false;
  }

  // Si pour une raison quelconque la bibliothèque est vide,
  // on la recharge à partir de BASE_DIVERS + localStorage.
  if (!diverLibrary || diverLibrary.length === 0) {
    loadDiverLibrary();
  }

  // Ensure PDJ tools are bound to current DOM
  initPDJTools();
  if (typeof initPDJTools._refreshActive === "function") initPDJTools._refreshActive();

  container.innerHTML = "";

  // --- PDJ visible list (view + aptitude filter)
  const lib = Array.isArray(diverLibrary) ? diverLibrary.slice() : [];
  const byName = new Map();
  lib.forEach(d => { if (d && d.name) byName.set(d.name, d); });

  let visible = lib;

  if (pdjView === "RECENT") {
    visible = (Array.isArray(recentDivers) ? recentDivers : [])
      .map(n => byName.get(n))
      .filter(Boolean);
  } else if (pdjView === "FAV") {
    visible = (Array.isArray(favoriteDivers) ? favoriteDivers : [])
      .map(n => byName.get(n))
      .filter(Boolean);
  }

  if (pdjAptFilter) {
    visible = visible.filter(d => (d && d.aptitudes === pdjAptFilter));
  }

  // Filtre bateau (day-level)
  if (typeof pdjBoatFilter !== "undefined" && pdjBoatFilter) {
    const bf = pdjBoatFilter;
    visible = visible.filter(d => {
      const nm = d && d.name ? String(d.name).trim() : "";
      if (!nm) return false;
      const u = (typeof getDiverUnit === "function") ? getDiverUnit(nm) : "";
      if (bf === "__UNASSIGNED__") return !u;
      return u === bf;
    });
  }


  if (pdjSearchQuery) {
    const q = String(pdjSearchQuery).toLowerCase();
    visible = visible.filter(d => {
      const name = (d && d.name) ? String(d.name).toLowerCase() : "";
      const lic = (d && d.licence) ? String(d.licence).toLowerCase() : "";
      return name.includes(q) || lic.includes(q);
    });
  }

  if (typeof initPDJTools === "function" && initPDJTools._refreshActive) initPDJTools._refreshActive();

  visible.forEach((d, index) => {
    if (!d || !d.name) return;

    const card = document.createElement("div");
    card.className = "diver-card";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.id = "pj_chk_" + index;
    cb.dataset.diverName = d.name;
    if (Array.isArray(diversDuJour) && diversDuJour.includes(d.name)) {
      cb.checked = true;
    }

    const main = document.createElement("div");
    main.className = "diver-card-main";

    // --- 3 colonnes: Nom | Aptitude | Paliers ---
    const grid = document.createElement("div");
    grid.className = "diver-card-grid";

    const nameEl = document.createElement("div");
    nameEl.className = "diver-card-name";
    nameEl.textContent = d.name || "(Nom inconnu)";

    // Favori (⭐) — PDJ tools
    const star = document.createElement("button");
    star.type = "button";
    star.className = "fav-star" + (isFavoriteDiver(d.name) ? " is-on" : "");
    star.textContent = isFavoriteDiver(d.name) ? "★" : "☆";
    star.title = "Favori";
    star.addEventListener("click", function (ev) {
      ev.stopPropagation();
      toggleFavoriteDiver(d.name);
    });
    nameEl.appendChild(star);


    // IMPORTANT: ton fichier utilise aptitudes (pluriel) dans BASE_DIVERS  [oai_citation:6‡DIVINGLOG.txt](sediment://file_00000000ab1071f49224a0a2bf2a591e)
    let aptText = "—";

    if (d.aptitudes) {
      const sel = document.getElementById("add_diver_aptitude_select");
      if (sel) {
        const opt = Array.from(sel.options).find(o => o.value === d.aptitudes);
        aptText = opt ? opt.textContent : d.aptitudes;
      } else {
        aptText = d.aptitudes;
      }
    }

    const aptBox = document.createElement("span");
    aptBox.className = "mini-box mini-apt";
    aptBox.textContent = "APTITUDE: " + aptText;

    const palBox = document.createElement("span");
    const hasP = diverHasAnyPaliers(d.name);
    const isSelected = (Array.isArray(diversDuJour) && diversDuJour.includes(d.name));
    // Vert si paliers présents. Rouge uniquement si le plongeur est sélectionné ET après validation.
    const palState = hasP ? "is-ok" : ((showMissingPalierWarnings && isSelected) ? "is-empty" : "");
    palBox.className = "mini-box mini-palier" + (palState ? (" " + palState) : "");
    palBox.textContent = hasP ? "✔ PALIERS" : (palState ? "⛔ PALIERS" : "PALIERS");
    palBox.style.cursor = "pointer";

    palBox.addEventListener("click", function (ev) {
      ev.stopPropagation();
      openPalierEditorFromPlongeursDuJour(d.name);
    });

    grid.appendChild(nameEl);
    grid.appendChild(aptBox);
    grid.appendChild(palBox);

    const certEl = document.createElement("div");
    certEl.className = "diver-card-cert";
    const certTxt = (d.cert && d.cert.trim()) ? d.cert : "(aucune certification saisie)";
    certEl.textContent = certTxt;

    main.appendChild(grid);
    main.appendChild(certEl);

    card.appendChild(cb);
    card.appendChild(main);
    container.appendChild(card);
  });
    updatePlongeursJourStatus();
  }

  function handleValidationPlongeursDuJour() {
    const container = document.getElementById("plongeurs-jour-list");
    if (!container) return;

    // IMPORTANT: do NOT drop previously selected divers that are currently hidden by filters.
    // We start from current diversDuJour, then only update the ones that are visible in the DOM.
    const set = new Set(Array.isArray(diversDuJour) ? diversDuJour : []);

    container.querySelectorAll("input[type='checkbox']").forEach(cb => {
      const nm = cb.dataset && cb.dataset.diverName ? String(cb.dataset.diverName) : "";
      if (!nm) return;
      if (cb.checked) set.add(nm);
      else set.delete(nm);
    });

    // Keep a stable order based on diverLibrary (then extras)
    const ordered = [];
    const libNames = Array.isArray(diverLibrary) ? diverLibrary.map(d => d && d.name).filter(Boolean) : [];
    libNames.forEach(nm => { if (set.has(nm)) ordered.push(nm); });
    Array.from(set).forEach(nm => { if (!ordered.includes(nm)) ordered.push(nm); });

    diversDuJour = ordered;
    saveDiversDuJour();
    showMissingPalierWarnings = true;
    updatePlongeursJourStatus();

    syncGroupsWithDiversDuJour();
    renderGroupAssignments();
  }

   function resetGroupAssignments() {
    groupAssignments = {};
    GROUP_IDS.forEach(id => {
      groupAssignments[id] = [];
    });
  }

  function loadGroupAssignments() {
    resetGroupAssignments();
    try {
      const raw = localStorage.getItem(GROUP_ASSIGN_KEY);
      if (raw) {
        const obj = JSON.parse(raw);
        if (obj && typeof obj === "object") {
          GROUP_IDS.forEach(id => {
            const arr = obj[id];
            groupAssignments[id] = Array.isArray(arr) ? arr : [];
          });
        }
      }
    } catch (e) {
      console.warn("loadGroupAssignments error:", e);
      resetGroupAssignments();
    }
  }

  function saveGroupAssignments() {
    try {
      localStorage.setItem(GROUP_ASSIGN_KEY, JSON.stringify(groupAssignments));
    } catch (e) {
      console.warn("saveGroupAssignments error:", e);
    }
  }

  function loadGroupLeaders() {
    groupLeaders = {};
    try {
      const raw = localStorage.getItem(GROUP_LEADER_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === "object") {
        GROUP_IDS.forEach(id => {
          const name = obj[id];
          if (typeof name === "string" && name.trim()) {
            groupLeaders[id] = name.trim();
          }
        });
      }
    } catch (e) {
      console.warn("loadGroupLeaders error:", e);
      groupLeaders = {};
    }
  }

  function saveGroupLeaders() {
    try {
      localStorage.setItem(GROUP_LEADER_KEY, JSON.stringify(groupLeaders));
    } catch (e) {
      console.warn("saveGroupLeaders error:", e);
    }
  }

  function getLeaderForGroup(groupId) {
    if (!groupId) return null;
    const name = groupLeaders[groupId];
    if (typeof name === "string" && name.trim()) {
      return name.trim();
    }
    return null;
  }

  // Helper: returns the "responsable" name for a group based on its practice type.
  // AUTONOME -> Leader (prefer Référent in-group selection, fallback to stored group leader)
  // FORMATION / ENCADREE -> Instructeur (from instructor library selection)
  function getGroupResponsibleInfo(gid) {
    const practice = (groupPractice && groupPractice[gid]) ? groupPractice[gid] : "AUTONOME";
    const sup = groupSupervisors ? groupSupervisors[gid] : null;

    if (practice === "AUTONOME") {
      // Prefer explicit "Référent" (IN_GROUP). Fallback to group leader.
      if (sup && sup.type === "IN_GROUP" && sup.value) {
        return { role: "leader", label: String(sup.value).trim() };
      }
      const leader = getLeaderForGroup(gid);
      return { role: "leader", label: leader || "" };
    }

    // ENCADREE / FORMATION -> instructor library
    if (sup && sup.type === "INSTRUCTOR_LIB" && sup.value) {
      const inst = (Array.isArray(instructorLibrary) ? instructorLibrary : []).find(x => x && x.id === sup.value);
      if (inst && inst.name) {
        return { role: "instructeur", label: String(inst.name).trim() };
      }
    }
    return { role: "instructeur", label: "" };
  }


  // Helper: for APRÈS plongée, include the Encadrant as a "virtual diver" when practice is ENCADREE.
  // This does NOT touch groupAssignments (source of truth for groups), only the APRÈS rendering/saving list.
  function getEncadrantAfterDisplayName(gid) {
    const practice = (groupPractice && groupPractice[gid]) ? groupPractice[gid] : "AUTONOME";
    if (practice !== "ENCADREE" && practice !== "FORMATION") return null;

    const sup = groupSupervisors ? groupSupervisors[gid] : null;
    if (!sup) return null;

    let name = "";
    if (sup.type === "INSTRUCTOR_LIB" && sup.value) {
      const inst = (Array.isArray(instructorLibrary) ? instructorLibrary : []).find(x => x && x.id === sup.value);
      if (inst && inst.name) name = String(inst.name).trim();
    } else if (sup.type === "IN_GROUP" && sup.value) {
      name = String(sup.value).trim();
    }

    if (!name) return null;
    const role = (practice === "FORMATION") ? "Formateur" : "Encadrant";
    return `${role} – ${name}`;
  }

  function getAfterDiverNames(gid) {
    const base = Array.isArray(groupAssignments[gid]) ? groupAssignments[gid].filter(Boolean) : [];
    const enc = getEncadrantAfterDisplayName(gid);
    if (enc && !base.includes(enc)) return base.concat([enc]);
    return base;
  }


  function setGroupLeader(groupId, diverName) {
    if (!groupId || !diverName) return;
    const arr = groupAssignments[groupId];
    if (!Array.isArray(arr) || !arr.includes(diverName)) {
      // on ne peut définir comme leader qu'un plongeur déjà dans le groupe
      return;
    }
    groupLeaders[groupId] = diverName;
    saveGroupLeaders();
    updateGroupHeadersWithLeaders();
  }

function deleteGroup(gid) {
  if (!gid) return;

  // Cannot delete if it is the only group left
  if (GROUP_IDS.length <= 1) {
    alert("Vous devez garder au moins un groupe.");
    return;
  }

  // Must be empty
  const arr = groupAssignments[gid];
  if (Array.isArray(arr) && arr.length > 0) {
    alert("Ce groupe contient encore des plongeurs.");
    return;
  }

  // Remove leader if any
  if (groupLeaders[gid]) {
    delete groupLeaders[gid];
  }

  // Remove from GROUP_IDS
  const index = GROUP_IDS.indexOf(gid);
  if (index >= 0) GROUP_IDS.splice(index, 1);

  // Remove its DOM card
  const card = document.querySelector('.group-column[data-group="' + gid + '"]');
  if (card && card.parentNode) {
    card.parentNode.removeChild(card);
  }

  saveGroupAssignments();
  saveGroupLeaders();

  // Refresh layout + dropzones + headers
  renderGroupAssignments();
  setupGroupDropZones();
  updateGroupHeadersWithLeaders();
}

  function clearLeaderIfNotInGroup(groupId) {
    if (!groupId) return;
    const leader = groupLeaders[groupId];
    if (!leader) return;
    const arr = groupAssignments[groupId];
    if (!Array.isArray(arr) || !arr.includes(leader)) {
      delete groupLeaders[groupId];
    }
  }

 
function ensureDefaultGroupPractice(gid){
  if (!groupPractice || typeof groupPractice !== "object") groupPractice = {};
  if (!groupPractice[gid]) groupPractice[gid] = "AUTONOME";
}

function validateGroupsAndRoles(){
  const errors = [];
  const warnings = [];

  // DP warning (DP already exists in Contexte du jour)
  const dpEl = document.getElementById("dive_const_dp");
  const dpVal = dpEl ? (dpEl.value || "").trim() : "";
  if (!dpVal) {
    warnings.push({ code:"W-S1", scope:"session", message:"Aucun DP défini (Contexte du jour)." });
  }

  (Array.isArray(GROUP_IDS) ? GROUP_IDS : []).forEach(gid => {
    const members = Array.isArray(groupAssignments?.[gid]) ? groupAssignments[gid] : [];
    if (members.length === 0) return;

    ensureDefaultGroupPractice(gid);
    const practice = groupPractice[gid] || "AUTONOME";
    const leader = groupLeaders?.[gid] || "";
    const sup = groupSupervisors?.[gid];

    if (practice === "AUTONOME") {
      const hasLeaderOrReferent = !!leader || (sup && sup.type === "IN_GROUP" && !!sup.value);
      if (!hasLeaderOrReferent) warnings.push({ code:"W-A1", scope:"group", groupId: gid, message: gid + " AUTONOME : leader non défini (recommandé)." });
      if (sup && sup.type === "INSTRUCTOR_LIB") warnings.push({ code:"W-A2", scope:"group", groupId: gid, message: gid + " AUTONOME : encadrant instructeur défini (inhabituel)." });
    } else if (practice === "ENCADREE") {
      if (!sup || sup.type !== "INSTRUCTOR_LIB" || !sup.value) errors.push({ code:"E-G1", scope:"group", groupId: gid, message: gid + " ENCADRÉE : encadrant obligatoire." });
    } else if (practice === "FORMATION") {
      if (!sup || sup.type !== "INSTRUCTOR_LIB" || !sup.value) errors.push({ code:"E-G1", scope:"group", groupId: gid, message: gid + " FORMATION : encadrant obligatoire." });
    }

    if (sup && sup.type === "INSTRUCTOR_LIB" && sup.value) {
      const inst = getInstructorById(sup.value);
      if (!inst) errors.push({ code:"E-I1", scope:"group", groupId: gid, message: gid + " : encadrant introuvable dans la bibliothèque instructeurs." });
    }

    // Autonome supervisor in-group but not member (should never happen)
    if (sup && sup.type === "IN_GROUP" && sup.value) {
      if (!members.includes(sup.value)) {
        warnings.push({ code:"W-A3", scope:"group", groupId: gid, message: gid + " : référent n'est pas membre du groupe." });
      }
    }
  });

  return { errors, warnings };
}

function renderValidationBanner(){
  const el = document.getElementById("group-validation-banner");
  if (!el) return;
  const res = validateGroupsAndRoles();
  const errors = Array.isArray(res.errors) ? res.errors : [];
  const warnings = Array.isArray(res.warnings) ? res.warnings : [];

  if (errors.length === 0 && warnings.length === 0) {
    el.style.display = "none";
    el.classList.remove("error","warning");
    el.innerHTML = "";
    return;
  }

  el.style.display = "";
  el.classList.remove("error","warning");
  el.classList.add(errors.length ? "error" : "warning");

  const title = errors.length ? ("❌ Erreurs (" + errors.length + ")") : ("⚠️ Avertissements (" + warnings.length + ")");
  const items = (errors.length ? errors : warnings).slice(0, 6);

  const lis = items.map(x => "<li>" + (x.message || "") + "</li>").join("");
  const extra = (errors.length ? errors.length : warnings.length) > items.length
    ? "<li>…</li>" : "";

  el.innerHTML = `<div class="vb-title">${title}</div><ul>${lis}${extra}</ul>`;
}
function updateGroupHeadersWithLeaders() {
  GROUP_IDS.forEach(gid => {
    const listEl = document.getElementById("group-" + gid + "-list");
    if (!listEl) return;

    let col = listEl.closest(".group-column");
    if (!col) return;

    const header = col.querySelector(".group-header");
    if (!header) return;

    // Reset header base label once
    let base = header.getAttribute("data-base-label");
    if (!base) {
      base = header.textContent.split("—")[0].trim();
      header.setAttribute("data-base-label", base);
    }

    // Rebuild header content deterministically
    header.innerHTML = "";

    const left = document.createElement("span");
    left.className = "group-header-left";

    const titleSpan = document.createElement("span");
    titleSpan.className = "group-header-title";
    titleSpan.textContent = base;
    left.appendChild(titleSpan);

    const badgesWrap = document.createElement("span");
    badgesWrap.className = "group-badges";

    const practice = (groupPractice && groupPractice[gid]) ? groupPractice[gid] : "AUTONOME";
    const typeBadge = document.createElement("span");
    typeBadge.className = "group-type-badge group-type-" + practice;
    typeBadge.textContent = practice;
    badgesWrap.appendChild(typeBadge);

    // Role badge: show referent/encadrant when available (compact, immediate)
    let roleLabel = "";
    let roleEmoji = "";
    const sup = groupSupervisors ? groupSupervisors[gid] : null;

    if (practice === "AUTONOME") {
      // Prefer explicit "Référent" selection; fallback to existing group leader if any
      if (sup && sup.type === "IN_GROUP" && sup.value) {
        roleEmoji = "👤";
        roleLabel = sup.value;
      } else {
        const leader = getLeaderForGroup(gid);
        if (leader) {
          roleEmoji = "👤";
          roleLabel = leader;
        }
      }
    } else {
      // ENCADREE / FORMATION: show instructor library selection if any
      if (sup && sup.type === "INSTRUCTOR_LIB" && sup.value) {
        const inst = (Array.isArray(instructorLibrary) ? instructorLibrary : []).find(x => x && x.id === sup.value);
        if (inst && inst.name) {
          roleEmoji = "🎓";
          roleLabel = inst.name;
        }
      }
    }

    if (roleLabel) {
      const roleBadge = document.createElement("span");
      roleBadge.className = "group-role-badge";
      roleBadge.title = roleLabel;
      roleBadge.textContent = roleEmoji ? (roleEmoji + " " + roleLabel) : roleLabel;
      badgesWrap.appendChild(roleBadge);
    }

    left.appendChild(badgesWrap);
    header.appendChild(left);

    // Header controls (action-only): 📘 + Détails
    const controls = document.createElement("span");
    controls.className = "group-header-controls";

    const btnBook = document.createElement("button");
    btnBook.type = "button";
    btnBook.className = "btn small";
    btnBook.textContent = "📘";
    btnBook.title = "Modifier le groupe (type + encadrant/référent)";
    btnBook.addEventListener("click", (ev) => {
      ev.stopPropagation();
      openGroupHeaderBookMenuOverlay({ gid });
    });

    controls.appendChild(btnBook);

const toggle = document.createElement("span");
    toggle.className = "group-details-toggle";
    const isOpen = !!groupMetaOpen[gid];
    toggle.textContent = isOpen ? "Détails ▴" : "Détails ▾";
    toggle.addEventListener("click", (ev) => {
      ev.stopPropagation();
      groupMetaOpen[gid] = !groupMetaOpen[gid];
      const panel = col.querySelector(".group-meta-panel");
      if (panel) {
        panel.style.display = groupMetaOpen[gid] ? "" : "none";
      }
      toggle.textContent = groupMetaOpen[gid] ? "Détails ▴" : "Détails ▾";
    });
    controls.appendChild(toggle);

    header.appendChild(controls);

 
    // DELETE BUTTON CONDITIONS:
    // 1. group must be empty
    // 2. group must NOT be the only remaining group
      const isLastRemaining = (GROUP_IDS.length <= 1);
    const isEmpty = (groupAssignments[gid] && groupAssignments[gid].length === 0);
    const isBaseGroup = (gid === "G1");  // G1 jamais supprimable

    if (!isLastRemaining && !isBaseGroup && isEmpty) {
      const delBtn = document.createElement("span");
      delBtn.className = "group-delete-btn";
      delBtn.textContent = "Supprimer";

      delBtn.addEventListener("click", function (ev) {
        ev.stopPropagation();
        const ok = confirm("Supprimer le groupe " + gid + " ?");
        if (ok) deleteGroup(gid);
      });

      // place delete button UNDER the header (avoid same-line layout issues)
      // Remove any previous delete button injected in the header
      header.querySelectorAll(".group-delete-btn").forEach(n => n.remove());

      let actions = col.querySelector(".group-actions");
      if (!actions) {
        actions = document.createElement("div");
        actions.className = "group-actions";
        header.insertAdjacentElement("afterend", actions);
      }
      // Keep a single button
      actions.innerHTML = "";
      actions.appendChild(delBtn);
}

    // Always render the group meta panel (practice + supervisor)
    // Anchor it to this group's column so it stays with the group.
    renderGroupMetaPanel(gid, col, practice);
    
  });
}

    
function renderGroupMetaPanel(gid, col, practice) {
  if (!col || !gid) return;
  let panel = col.querySelector(".group-meta-panel");
  if (!panel) {
    panel = document.createElement("div");
    panel.className = "group-meta-panel";
    // insert right after header if possible, otherwise append
    const header = col.querySelector(".group-header");
    if (header && header.parentNode) {
      header.parentNode.insertBefore(panel, header.nextSibling);
    } else {
      col.appendChild(panel);
    }
  }

  // show/hide depending on toggle state
  panel.style.display = groupMetaOpen?.[gid] ? "" : "none";
  panel.innerHTML = "";

  // Only relevant for ENCADREE / FORMATION (instructor supervisor)
  if (practice === "AUTONOME") return;

  const roleWord = (practice === "FORMATION") ? "Formateur" : "Encadrant";

  const sup = groupSupervisors?.[gid];
  const instId = (sup && sup.type === "INSTRUCTOR_LIB") ? (sup.value || "") : "";
  const inst = instId ? getInstructorById(instId) : null;

  const title = document.createElement("div");
  title.className = "group-meta-title";
  title.textContent = "Encadrement";
  panel.appendChild(title);

  const row = document.createElement("div");
  row.style.display = "flex";
  row.style.flexDirection = "column";
  row.style.gap = "6px";

  if (!inst) {
    const p = document.createElement("div");
    p.innerHTML = '<span class="pdf-muted">' + roleWord + ' :</span> <strong>Aucun</strong>';
    row.appendChild(p);
    panel.appendChild(row);
    return;
  }

  // Name (read-only)
  const nameLine = document.createElement("div");
  nameLine.innerHTML = '<span class="pdf-muted">' + roleWord + ' :</span> <strong>' + escapeHtml(inst.name || inst.id) + '</strong>';
  row.appendChild(nameLine);

  // Actions: changer / supprimer l'encadrant-formateur
  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.gap = "8px";
  actions.style.flexWrap = "wrap";
  actions.style.marginTop = "4px";

  const btnChange = document.createElement("button");
  btnChange.type = "button";
  btnChange.className = "btn";
  btnChange.textContent = "Modifier " + roleWord;
  btnChange.addEventListener("click", function(ev){
    ev.stopPropagation();
    openGroupSupervisorPickerOverlay({ gid: gid });
  });

  const btnClear = document.createElement("button");
  btnClear.type = "button";
  btnClear.className = "btn";
  btnClear.textContent = "Supprimer " + roleWord;
  btnClear.addEventListener("click", function(ev){
    ev.stopPropagation();
    const ok = confirm("Supprimer " + roleWord + " du groupe " + gid + " ?");
    if (!ok) return;
    try { if (groupSupervisors && groupSupervisors[gid]) { delete groupSupervisors[gid]; saveGroupSupervisors(); } } catch(_) {}
    try { updateGroupHeadersWithLeaders(); } catch(_) {}
    try { renderValidationBanner(); } catch(_) {}
    // re-render whole groups to refresh panel + badges
    try { renderGroupAssignments(); } catch(_) {}
  });

  actions.appendChild(btnChange);
  actions.appendChild(btnClear);
  row.appendChild(actions);

  function mkField(label, key) {
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateColumns = "130px 1fr";
    wrap.style.gap = "8px";
    const lab = document.createElement("div");
    lab.className = "pdf-muted";
    lab.textContent = label;
    const input = document.createElement("input");
    input.type = "text";
    input.value = (inst[key] || "");
    input.addEventListener("change", () => {
      inst[key] = input.value || "";
      saveInstructorLibrary();
      // keep header badge updated immediately
      updateGroupHeadersWithLeaders();
    });
    wrap.appendChild(lab);
    wrap.appendChild(input);
    return wrap;
  }

  row.appendChild(mkField("Aptitude", "aptitude"));
  row.appendChild(mkField("Certification", "certification"));
  row.appendChild(mkField("Licence", "licence"));

  panel.appendChild(row);
}


function removeDiverFromAllGroups(diverName) {
    if (!diverName) return;
    GROUP_IDS.forEach(g => {
      const arr = groupAssignments[g];
      if (Array.isArray(arr)) {
        groupAssignments[g] = arr.filter(n => n !== diverName);
        if (groupLeaders[g] === diverName) {
          delete groupLeaders[g];
        }
      }
    });
  }

  function getCurrentGroupOfDiver(diverName) {
    if (!diverName) return null;
    for (const gid of GROUP_IDS) {
      const arr = groupAssignments[gid];
      if (Array.isArray(arr) && arr.includes(diverName)) {
        return gid;
      }
    }
    return null;
  }

    function closeGroupSelectOverlay() {
    const existing = document.getElementById("group-select-overlay");
    if (existing && existing.parentNode) {
      existing.parentNode.removeChild(existing);
    }
  }

  function handleGroupChoice(diverName, choice) {
    if (!diverName) return;

    if (choice === "DISPO") {
      removeDiverFromGroup(diverName);
    } else if (GROUP_IDS.includes(choice)) {
      assignDiverToGroup(diverName, choice);
    }
    closeGroupSelectOverlay();
  }


  function handleGroupChoice(diverName, choice) {
    if (!diverName) return;
    if (choice === "DISPO") {
      removeDiverFromGroup(diverName);
    } else if (GROUP_IDS.includes(choice)) {
      assignDiverToGroup(diverName, choice);
    }
    closeGroupSelectOverlay();
  }

  function handleLeaderChoice(diverName) {
    if (!diverName) return;
    const current = getCurrentGroupOfDiver(diverName);
    if (!current) return;
    setGroupLeader(current, diverName);
    closeGroupSelectOverlay();
  }

  function handleGroupCardClick(diverName) {
    if (!diverName) return;

    // S'il n'y a aucun groupe défini, on ne fait rien
    if (!Array.isArray(GROUP_IDS) || GROUP_IDS.length === 0) return;

    const current = getCurrentGroupOfDiver(diverName) || "DISPO";

    closeGroupSelectOverlay();

    const overlay = document.createElement("div");
    overlay.id = "group-select-overlay";
    overlay.className = "group-select-overlay";

    const dialog = document.createElement("div");
    dialog.className = "group-select-dialog";

    const title = document.createElement("div");
    title.className = "group-select-title";
    title.textContent = "Affecter « " + diverName + " »";

    const sub = document.createElement("div");
    sub.className = "group-select-sub";
    sub.textContent =
      "Choisir une action (groupe actuel : " +
      (current === "DISPO" ? "Disponible" : current) +
      ")";

    const btnContainer = document.createElement("div");
    btnContainer.className = "group-select-buttons";


    // Bouton DISPO
    const dispoBtn = document.createElement("button");
    dispoBtn.type = "button";
    dispoBtn.className = "btn";
    dispoBtn.textContent = "DISPO";
    dispoBtn.addEventListener("click", function () {
      handleGroupChoice(diverName, "DISPO");
    });
    btnContainer.appendChild(dispoBtn);

    // Boutons de groupes (G1, G2, ...)
    GROUP_IDS.forEach(gid => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn";
      const num = parseInt(gid.substring(1), 10);
      btn.textContent = num ? ("G" + num) : gid;
      btn.addEventListener("click", function () {
        handleGroupChoice(diverName, gid);
      });
      btnContainer.appendChild(btn);
    });

    const footer = document.createElement("div");
    footer.className = "group-select-footer";

    const cancel = document.createElement("span");
    cancel.className = "group-select-cancel";
    cancel.textContent = "Annuler";
    cancel.addEventListener("click", function () {
      closeGroupSelectOverlay();
    });

    footer.appendChild(cancel);

    dialog.appendChild(title);
    dialog.appendChild(sub);
    dialog.appendChild(btnContainer);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    document.body.appendChild(overlay);

    // Cliquer en dehors de la boîte ferme également l'overlay
    overlay.addEventListener("click", function (ev) {
      if (ev.target === overlay) {
        closeGroupSelectOverlay();
      }
    });
  }


    function assignDiverToGroup(diverName, groupId) {
    if (!diverName || !groupId) return;
    removeDiverFromAllGroups(diverName);

    if (!Array.isArray(groupAssignments[groupId])) {
      groupAssignments[groupId] = [];
    }

    const existing = groupAssignments[groupId].filter(n => n !== diverName);

    // Ajouter le plongeur en tête de liste (top du groupe)
    existing.unshift(diverName);

    groupAssignments[groupId] = existing;

    saveGroupAssignments();
    saveGroupLeaders();
    renderGroupAssignments();
  }

  function removeDiverFromGroup(diverName) {
    if (!diverName) return;
    removeDiverFromAllGroups(diverName);
    saveGroupAssignments();
    renderGroupAssignments();
  }

     function syncGroupsWithDiversDuJour() {
    const setDuJour = new Set(Array.isArray(diversDuJour) ? diversDuJour : []);
    GROUP_IDS.forEach(g => {
      const arr = groupAssignments[g];
      if (Array.isArray(arr)) {
        groupAssignments[g] = arr.filter(n => setDuJour.has(n));
      }
      clearLeaderIfNotInGroup(g);
    });
    saveGroupAssignments();
    saveGroupLeaders();
  }

    function updateGroupStatus() {
    const statusEl = document.getElementById("groupes-status");
    if (!statusEl) return;

    let total = 0;
    const parts = [];

    GROUP_IDS.forEach(gid => {
      const count = Array.isArray(groupAssignments[gid]) ? groupAssignments[gid].length : 0;
      total += count;
      parts.push(gid + ": " + count);
    });

    if (total === 0) {
      statusEl.textContent = "Aucun plongeur affecté à un groupe pour l'instant.";
    } else {
      statusEl.textContent =
        "Plongeurs affectés : " +
        total +
        " (" + parts.join(", ") + ").";
    }
  }

    function renderGroupAssignments() {
    const dispoEl = document.getElementById("group-disponibles-list");
    if (!dispoEl) return;

    // Récupérer les containers de chaque groupe existant dans le DOM
    const groupEls = {};
    GROUP_IDS.forEach(gid => {
      const el = document.getElementById("group-" + gid + "-list");
      if (el) {
        groupEls[gid] = el;
      }
    });

    dispoEl.innerHTML = "";
    Object.values(groupEls).forEach(el => {
      el.innerHTML = "";
    });

    const duJour = Array.isArray(diversDuJour) ? diversDuJour.slice() : [];

    // Plongeurs déjà affectés à au moins un groupe
    const inGroup = new Set();
    GROUP_IDS.forEach(gid => {
      const arr = groupAssignments[gid] || [];
      arr.forEach(n => inGroup.add(n));
    });

    const disponibles = duJour.filter(n => !inGroup.has(n));

    function createGroupCard(diverName) {
      const card = document.createElement("div");
      card.className = "group-diver-card";
      card.draggable = true;
      card.dataset.diverName = diverName;

      // Drag & drop desktop
      card.addEventListener("dragstart", ev => {
        currentDraggedDiver = diverName;
        if (ev.dataTransfer) {
          ev.dataTransfer.setData("text/plain", diverName);
          ev.dataTransfer.effectAllowed = "move";
        }
      });

      card.addEventListener("dragend", () => {
        currentDraggedDiver = null;
      });

      // Tap / clic pour affecter à un groupe (mobile friendly)
      card.addEventListener("click", () => {
        handleGroupCardClick(diverName);
      });

      const top = document.createElement("div");
top.className = "diver-card-grid"; // on réutilise le grid 3 colonnes que tu as déjà en CSS

const nameEl = document.createElement("div");
nameEl.className = "group-diver-name";
nameEl.textContent = diverName;

const aptBox = document.createElement("span");
aptBox.className = "mini-box mini-apt";
aptBox.textContent = "APTITUDE: " + getAptitudeTextForDiver(diverName);

const palBox = document.createElement("span");
const hasP = diverHasAnyPaliers(diverName);
palBox.className = "mini-box mini-palier " + (hasP ? "is-ok" : "is-empty");
palBox.textContent = hasP ? "✔ PALIERS" : "⛔ PALIERS";

palBox.style.cursor = "pointer";
palBox.addEventListener("click", function (ev) {
  ev.stopPropagation();                 // CRITICAL: don’t trigger the card click (move diver)
  openPalierEditorFromPlongeursDuJour(diverName);
});

top.appendChild(nameEl);
top.appendChild(aptBox);
top.appendChild(palBox);


const boatWrap = document.createElement("span");
boatWrap.className = "boat-wrap";
boatWrap.addEventListener("click", (ev) => { ev.stopPropagation(); });
boatWrap.addEventListener("mousedown", (ev) => { ev.stopPropagation(); });

const boatBadge = document.createElement("span");
let curUnit = (typeof getDiverUnit === "function") ? getDiverUnit(diverName) : "";
boatBadge.className = "mini-box mini-boat" + (curUnit ? "" : " is-empty");
boatBadge.textContent = curUnit ? curUnit : "B–";

const boatSel = document.createElement("select");
boatSel.className = "boat-select";
boatSel.title = "Unité / bateau (jour)";
const optEmpty = document.createElement("option");
optEmpty.value = "";
optEmpty.textContent = "—";
boatSel.appendChild(optEmpty);

const nBoats = (typeof getCenterBoatsN === "function") ? getCenterBoatsN() : 1;
for (let i = 1; i <= nBoats; i++) {
  const o = document.createElement("option");
  o.value = "B" + i;
  o.textContent = "B" + i;
  boatSel.appendChild(o);
}
boatSel.value = curUnit || "";

boatSel.addEventListener("change", (ev) => {
  ev.stopPropagation();
  const v = boatSel.value || "";
  if (typeof setDiverUnit === "function") setDiverUnit(diverName, v);
  curUnit = (typeof getDiverUnit === "function") ? getDiverUnit(diverName) : "";
  boatBadge.className = "mini-box mini-boat" + (curUnit ? "" : " is-empty");
  boatBadge.textContent = curUnit ? curUnit : "B–";
});
boatSel.addEventListener("click", (ev) => { ev.stopPropagation(); });

boatWrap.appendChild(boatBadge);
boatWrap.appendChild(boatSel);
top.appendChild(boatWrap);
card.appendChild(top);
const d = getDiverByName(diverName);

const certEl = document.createElement("div");
certEl.className = "diver-card-cert";
certEl.textContent = (d && d.cert && String(d.cert).trim())
  ? String(d.cert).trim()
  : "(aucune certification saisie)";

card.appendChild(certEl);
return card;
    }

    // Disponibles
    disponibles.forEach(name => {
      dispoEl.appendChild(createGroupCard(name));
    });

    // Groupes
    GROUP_IDS.forEach(gid => {
      const el = groupEls[gid];
      if (!el) return;
      (groupAssignments[gid] || []).forEach(name => {
        el.appendChild(createGroupCard(name));
      });
    });

    updateGroupStatus();
  }
   function setupGroupDropZones() {
    const dispoEl = document.getElementById("group-disponibles-list");

    function makeDropZone(el, target) {
      if (!el) return;

      el.addEventListener("dragover", ev => {
        ev.preventDefault();
        if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
        el.classList.add("drop-target-over");
      });

      el.addEventListener("dragleave", () => {
        el.classList.remove("drop-target-over");
      });

      el.addEventListener("drop", ev => {
        ev.preventDefault();
        el.classList.remove("drop-target-over");

        let diverName = "";
        if (ev.dataTransfer) {
          diverName =
            ev.dataTransfer.getData("text/plain") ||
            ev.dataTransfer.getData("text");
        }
        if (!diverName && currentDraggedDiver) {
          diverName = currentDraggedDiver;
        }
        if (!diverName) return;

        if (target === "DISPO") {
          removeDiverFromGroup(diverName);
        } else if (GROUP_IDS.includes(target)) {
          assignDiverToGroup(diverName, target);
        }
      });
    }

    // Zone "disponibles"
    makeDropZone(dispoEl, "DISPO");

    // Une drop-zone par groupe
    GROUP_IDS.forEach(gid => {
      const el = document.getElementById("group-" + gid + "-list");
      if (el) {
        makeDropZone(el, gid);
      }
    });
  }

  function updateGroupModeUI(prefix) {
    const modeEl = document.getElementById(prefix + "_mode");
    if (!modeEl) return;

    const mode = modeEl.value;
    const isRestricted = mode === "CCR" || mode === "OC_TRIMIX";

    const lockedSuffixes = [
      "_heure_mise_eau_prev",
      "_heure_sortie_prev",
      "_paliers_prev"
    ];

    lockedSuffixes.forEach(suffix => {
      const input = document.getElementById(prefix + suffix);
      if (!input) return;
      input.disabled = isRestricted;
      if (isRestricted) {
        input.classList.add("group-field-locked");
      } else {
        input.classList.remove("group-field-locked");
      }
    });

    const alwaysFreeSuffixes = [
      "_heure_mise_eau_reel",
      "_heure_sortie_reel",
      "_paliers_reels"
    ];

    alwaysFreeSuffixes.forEach(suffix => {
      const input = document.getElementById(prefix + suffix);
      if (!input) return;
      input.disabled = false;
      input.classList.remove("group-field-locked");
    });
  }

  function initGroupModeUI() {
    ["g1", "g2", "g3"].forEach(prefix => {
      updateGroupModeUI(prefix);
      const modeEl = document.getElementById(prefix + "_mode");
      if (modeEl) {
        modeEl.addEventListener("change", function () {
          updateGroupModeUI(prefix);
          saveFiche();
        });
      }
    });
  }

  function exportWhatsApp() {
    let txt = "";

    const cn = getCenterDisplayName ? getCenterDisplayName() : "CCR";
    txt += "📋 *Brief " + cn + "*\n\n";

    const pj = Array.isArray(diversDuJour) ? diversDuJour : [];
    if (pj.length) {
      txt += "🧍 *Plongeurs du jour*\n";
      pj.forEach(n => {
        txt += "- " + n + "\n";
      });
      txt += "\n";
    }

   

    const stored = JSON.parse(localStorage.getItem(STORAGE_KEY_FICHE) || "{}");
    const rt1 = stored["rt1_txt"] || "";
    const rt2 = stored["rt2_txt"] || "";
    const rt3 = stored["rt3_txt"] || "";

    if (exp1) {
      txt += "📘 *RT1*\n" + (rt1 || "-") + "\n\n";
    }
    if (exp2) {
      txt += "📙 *RT2*\n" + (rt2 || "-") + "\n\n";
    }
    if (exp3) {
      txt += "📕 *RT3 – CCR Break*\n" + (rt3 || "-") + "\n\n";
    }

    const url = "https://wa.me/?text=" + encodeURIComponent(txt);
    window.open(url, "_blank");
  }

  function escapeHtml(str) {
    if (!str) return "";
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function nl2br(str) {
  if (!str) return "";
  return escapeHtml(str).replace(/\r\n|\r|\n/g, "<br>");
  }

  
function buildPdfMock() {
  // ===== PDF v0 (rebuild from scratch) — Phase 2: PAGE 1 only =====
    const __centerCfg = loadCenterCfg ? loadCenterCfg() : null;
  const centerName = (__centerCfg && __centerCfg.name) ? __centerCfg.name : "—";
  const centerId = (__centerCfg && __centerCfg.id) ? __centerCfg.id : "";

  // ---- small helpers (local to PDF only) ----
  const esc = (v)=> escapeHtml(v == null ? "" : String(v));
  const clean = (v)=> (v == null ? "" : String(v)).trim();
  const dash = (v)=> {
    const s = clean(v);
    return s ? s : "—";
  };

  const formatGps = (v)=> {
    const s = clean(v);
    if (!s || s === "—") return "—";
    // Treat default placeholder as empty
    const low = s.toLowerCase();
    if (low.includes("n 00") && low.includes("e 000")) return "—";
    if (low.includes("n 0") && low.includes("e 0") && low.includes("00°")) return "—";
    return s;
  };
  const fmtNum = (v)=> {
    if (v == null || v === "") return "—";
    const n = Number(v);
    return isNaN(n) ? dash(v) : String(Math.round(n));
  };
  const uniq = (arr)=> {
    const seen = new Set();
    const out = [];
    (arr || []).forEach((x)=>{
      const s = clean(x);
      if (!s) return;
      const k = s.toLowerCase();
      if (seen.has(k)) return;
      seen.add(k);
      out.push(s);
    });
    return out;
  };

  const ctxDP   = clean(document.getElementById("dive_const_dp")?.value);
  const ctxBoat = clean(document.getElementById("dive_const_boat")?.value);
  const ctxSurf = clean(document.getElementById("dive_const_surface")?.value);
  const ctxSite = clean(document.getElementById("dive_site_name")?.value || document.getElementById("dive_site_select")?.value);
  const ctxGps  = clean(document.getElementById("dive_gps_nav")?.textContent);

  const now = new Date();
  const pad2 = (n)=> String(n).padStart(2,"0");
  const dateFR = `${pad2(now.getDate())}/${pad2(now.getMonth()+1)}/${now.getFullYear()}`;
  const timeFR = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;

  const headerHtml = (pageTitle)=> `
    <div class="pdf-header">
      <div class="pdf-header-line1">
        <div class="pdf-center">${esc(centerName)}${centerId ? (" — " + esc(centerId)) : ""}</div>
        <div class="pdf-site">${esc(dash(ctxSite))}</div>
        <div class="pdf-date">${esc(dateFR)}</div>
      </div>
      <div class="pdf-header-line2">
        <div class="pdf-title">${esc(pageTitle)}</div>
        <div class="pdf-generated">Généré à ${esc(timeFR)}</div>
      </div>
    </div>
  `;

  const pj = Array.isArray(diversDuJour) ? uniq(diversDuJour) : [];

  const getDiverInfo = (name)=> {
    const empty = { apt:"—", cert:"—", lic:"—" };
    const n = clean(name);
    if (!n) return empty;

    const pick = (d)=> ({
      // NOTE: base uses aptitudes (plural) and cert (short) in several places
      apt: dash(d?.aptitudes ?? d?.aptitude ?? d?.aptitudeBadge),
      cert: dash(d?.cert ?? d?.certif ?? d?.certification ?? d?.certificationLabel),
      lic: dash(d?.licence ?? d?.license ?? d?.numeroLicence ?? d?.numLicence ?? d?.lic)
    });

    // 1) Prefer canonical app lookup (exact match)
    if (typeof getDiverByName === "function") {
      const d = getDiverByName(n);
      if (d && typeof d === "object") return pick(d);
    }

    // 2) Robust fallback: case/space insensitive lookup in diverLibrary / instructorLibrary
    const key = n.toLowerCase().replace(/\s+/g, " ").trim();
    const scan = (arr)=> {
      const lib = Array.isArray(arr) ? arr : [];
      for (const d of lib) {
        const dn = clean(d?.name || d?.nom);
        if (!dn) continue;
        const dk = dn.toLowerCase().replace(/\s+/g, " ").trim();
        if (dk === key) return d;
      }
      return null;
    };

    const d1 = scan(typeof diverLibrary !== "undefined" ? diverLibrary : null);
    if (d1) return pick(d1);

    const d2 = scan(typeof instructorLibrary !== "undefined" ? instructorLibrary : null);
    if (d2) return pick(d2);

    // 3) Optional legacy helper
    if (typeof findDiverInLibraryByName === "function") {
      const d = findDiverInLibraryByName(n);
      if (d && typeof d === "object") return pick(d);
    }

    return empty;
  };

  // Encadrement lookup: prefer instructorLibrary (DP / Surface / Encadrant / Formateur), fallback diverLibrary
  const getEncadrementInfo = (name)=> {
    const empty = { apt:"—", cert:"—", lic:"—" };
    const n = clean(name);
    if (!n) return empty;

    const pick = (d)=> ({
      apt: dash(d?.aptitudes ?? d?.aptitude ?? d?.aptitudeBadge),
      cert: dash(d?.cert ?? d?.certif ?? d?.certification ?? d?.certificationLabel),
      lic: dash(d?.licence ?? d?.license ?? d?.numeroLicence ?? d?.numLicence ?? d?.lic)
    });

    const key = n.toLowerCase().replace(/\s+/g, " ").trim();
    const scan = (arr)=> {
      const lib = Array.isArray(arr) ? arr : [];
      for (const d of lib) {
        const dn = clean(d?.name || d?.nom);
        if (!dn) continue;
        const dk = dn.toLowerCase().replace(/\s+/g, " ").trim();
        if (dk === key) return d;
      }
      return null;
    };




    const i1 = scan(typeof instructorLibrary !== "undefined" ? instructorLibrary : null);
    if (i1) return pick(i1);

    const d1 = scan(typeof diverLibrary !== "undefined" ? diverLibrary : null);
    if (d1) return pick(d1);

    // Optional legacy helper
    if (typeof findDiverInLibraryByName === "function") {
      const d = findDiverInLibraryByName(n);
      if (d && typeof d === "object") return pick(d);
    }

    return empty;
  };


  // DP lookup strict (France): use instructorLibrary only (instructeurs / formateurs).
  // No fallback to diverLibrary to avoid mixing diver identities with staff roles.
  const getInstructorOnlyInfo = (name)=> {
    const empty = { apt:"—", cert:"—", lic:"—" };
    const n = clean(name);
    if (!n) return empty;

    const pick = (d)=> ({
      apt: dash(d?.aptitudes ?? d?.aptitude ?? d?.aptitudeBadge),
      cert: dash(d?.cert ?? d?.certif ?? d?.certification ?? d?.certificationLabel),
      lic: dash(d?.licence ?? d?.license ?? d?.numeroLicence ?? d?.numLicence ?? d?.lic)
    });

    const key = n.toLowerCase().replace(/\s+/g, " ").trim();
    const lib = Array.isArray(instructorLibrary) ? instructorLibrary : [];
    for (const d of lib) {
      const dn = clean(d?.name || d?.nom);
      if (!dn) continue;
      const dk = dn.toLowerCase().replace(/\s+/g, " ").trim();
      if (dk === key) return pick(d);
    }
    return empty;
  };

  const practiceLabel = (gid)=> {
    try {
      const p = (groupPractice && groupPractice[gid]) ? groupPractice[gid] : "";
      if (p === "FORMATION") return "FORMATION";
      if (p === "ENCADREE") return "ENCADREMENT";
      return "EXPLORATION";
    } catch(e) {
      return "EXPLORATION";
    }
  };

  const getGroupNames = (gid)=> {
    const arr = (groupAssignments && Array.isArray(groupAssignments[gid])) ? groupAssignments[gid] : [];
    return uniq(arr);
  };

  const safeBefore = (gid)=> {
    try {
      const rec = (groupDetails && groupDetails[gid]) ? groupDetails[gid] : null;
      const b = rec && rec.before && typeof rec.before === "object" ? rec.before : {};
      return b;
    } catch(e) {
      return {};
    }
  };

  const getResponsibleNameOrAucun = (gid)=> {
    // Only meaningful for FORMATION / ENCADREE groups.
    const p = practiceLabel(gid);
    if (p === "EXPLORATION") return null;

    if (typeof getGroupResponsibleInfo === "function") {
      const info = getGroupResponsibleInfo(gid);
      const label = info && typeof info === "object" ? clean(info.label) : "";
      return label ? label : "Aucun";
    }
    return "Aucun";
  };


  // ---- Build PAGE 1 HTML ----
  let html = "";
  html += '<div class="pdf-page">';
  html += headerHtml("Synthèse — Page 1");

  // 0) Contexte
  html += '<div class="pdf-section-title">Contexte</div>';
  html += '<table class="pdf-table"><tbody>';
  html += `<tr><th style="width:35%;">Centre</th><td>${esc(dash(centerName))}${centerId ? (" — " + esc(centerId)) : ""}</td></tr>`;
  html += `<tr><th style="width:35%;">DP</th><td>${esc(dash(ctxDP))}</td></tr>`;
  html += `<tr><th>Bateau</th><td>${esc(dash(ctxBoat))}</td></tr>`;
  html += `<tr><th>Sécurité surface</th><td>${esc(dash(ctxSurf))}</td></tr>`;
  html += `<tr><th>Site</th><td>${esc(dash(ctxSite))}</td></tr>`;
  html += `<tr><th>GPS</th><td>${esc(formatGps(ctxGps))}</td></tr>`;
  html += '</tbody></table>';

  // 1) Encadrement (DP + surface + instructeurs)
  html += '<div class="pdf-section-title">Encadrement</div>';
  html += '<table class="pdf-table"><thead><tr><th>Rôle</th><th>Nom</th><th>Aptitude</th><th>Certification</th><th>Licence</th><th>Groupe</th></tr></thead><tbody>';

  // DP
  const dpInfo = getInstructorOnlyInfo(ctxDP);
  html += `<tr><td>DP</td><td>${esc(dash(ctxDP))}</td><td>${esc(dpInfo.apt)}</td><td>${esc(dpInfo.cert)}</td><td>${esc(dpInfo.lic)}</td><td>—</td></tr>`;

  // Surface
  const surfInfo = getEncadrementInfo(ctxSurf);
  html += `<tr><td>Sécurité surface</td><td>${esc(dash(ctxSurf))}</td><td>${esc(surfInfo.apt)}</td><td>${esc(surfInfo.cert)}</td><td>${esc(surfInfo.lic)}</td><td>—</td></tr>`;

  // Instructeurs (FORMATION / ENCADREE)
  const gids = Array.isArray(GROUP_IDS) ? GROUP_IDS.slice() : [];
  let anyInstructorRow = false;
  gids.forEach((gid)=>{
    const p = practiceLabel(gid);
    if (p === "EXPLORATION") return;

    const name = getResponsibleNameOrAucun(gid);
    const info = (name && name !== "Aucun") ? getEncadrementInfo(name) : { apt:"—", cert:"—", lic:"—" };
    html += `<tr><td>${esc(p === "FORMATION" ? "Formateur" : "Encadrant")}</td><td>${esc(name || "Aucun")}</td><td>${esc(info.apt)}</td><td>${esc(info.cert)}</td><td>${esc(info.lic)}</td><td>${esc(gid)}</td></tr>`;
    anyInstructorRow = true;
  });

  if (!anyInstructorRow) {
    html += `<tr><td colspan="6" class="pdf-muted">Aucun groupe FORMATION / ENCADREMENT</td></tr>`;
  }

  html += '</tbody></table>';

  // 2) Plongeurs du jour
  html += '<div class="pdf-section-title">Plongeurs du jour</div>';
  html += '<table class="pdf-table"><thead><tr><th>Nom</th><th>Aptitude</th><th>Certification</th><th>Licence</th></tr></thead><tbody>';
  if (!pj.length) {
    html += `<tr><td colspan="4" class="pdf-muted">Aucun</td></tr>`;
  } else {
    pj.forEach((name)=>{
      const info = getDiverInfo(name);
      html += `<tr><td>${esc(name)}</td><td>${esc(info.apt)}</td><td>${esc(info.cert)}</td><td>${esc(info.lic)}</td></tr>`;
    });
  }
  html += '</tbody></table>';

  // ---- Page break: put groups on separate page to avoid overflow ----
  html += '</div>'; // pdf-page (PAGE 1)
  html += '<div class="pdf-page">';
  html += `<div class="pdf-title">Synthèse DP — Programme du jour</div>`;
  html += `<div class="pdf-meta">${esc(dateFR)} — Généré à ${esc(timeFR)}</div>`;

  // 3) Groupes du jour — 3 tableaux
  const bucket = { EXPLORATION: [], ENCADREMENT: [], FORMATION: [] };
  gids.forEach((gid)=>{
    const p = practiceLabel(gid);
    if (p === "EXPLORATION") bucket.EXPLORATION.push(gid);
    else if (p === "ENCADREMENT") bucket.ENCADREMENT.push(gid);
    else if (p === "FORMATION") bucket.FORMATION.push(gid);
  });

  const renderGroupTable = (title, list)=> {
    html += `<div class="pdf-section-title">Groupes — ${esc(title)}</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Groupe</th><th>Nb divers</th><th>DTR</th><th>Profondeur prévue</th><th>RT planifié</th><th>Sortie estimée</th></tr></thead><tbody>';
    if (!list.length) {
      html += `<tr><td colspan="6" class="pdf-muted">Aucun</td></tr>`;
    } else {
      list.forEach((gid)=>{
        const names = getGroupNames(gid);
        const b = safeBefore(gid);
        html += `<tr>
          <td>${esc(gid)}</td>
          <td style="text-align:center;">${esc(fmtNum(names.length))}</td>
          <td style="text-align:center;">${esc(fmtNum(b.dtrMaxMin))}</td>
          <td style="text-align:center;">${esc(fmtNum(b.depthPlanned))}</td>
          <td style="text-align:center;">${esc(fmtNum(b.runtimeGroupPlanned))}</td>
          <td style="text-align:center;">${esc(dash(b.exitPlanned))}</td>
        </tr>`;
      });
    }
    html += '</tbody></table>';
  };

  renderGroupTable("Exploration", bucket.EXPLORATION);
  renderGroupTable("Encadrement", bucket.ENCADREMENT);
  renderGroupTable("Formation", bucket.FORMATION);

  html += '</div>'; // pdf-page


  // ===== AFTER PDF — AUTONOME (1 groupe = 1 page, header répété avec site) =====
  // NOTE: PAGE 1 + "Programme du jour" (prévu) sont intouchés; on ajoute uniquement des pages APRÈS ici.

  const numOrNullPdf = (v)=> {
    if (v == null || v === "") return null;
    const n = Number(v);
    return isNaN(n) ? null : n;
  };

  const safeAfterPdf = (gid)=> {
    try {
      const rec = getGroupRecord(gid) || {};
      const a = (rec.after && typeof rec.after === "object") ? rec.after : {};
      if (!a.divers || typeof a.divers !== "object") a.divers = {};
      return a;
    } catch(e) { return { divers: {} }; }
  };

  const fmtHHMM = (v)=> {
    const s = clean(v);
    return s ? s : "—";
  };

  const getAfterEntryPdf = (gid, diverName)=> {
    const a = safeAfterPdf(gid);
    const k = normalizeName(diverName);
    return a.divers[k] || {};
  };

  const pickRuntimePdf = (entry)=> {
    const v = (entry.runtimeMin != null && entry.runtimeMin !== "") ? entry.runtimeMin
            : (entry.runtimeReal != null && entry.runtimeReal !== "") ? entry.runtimeReal
            : "";
    return (v === "" ? "—" : fmtNum(v));
  };

  const pickDepthPdf = (entry)=> {
    const v = (entry.depthRealM != null && entry.depthRealM !== "") ? entry.depthRealM : "";
    return (v === "" ? "—" : fmtNum(v));
  };

  const pickExitPdf = (gid, entry)=> {
    const a = safeAfterPdf(gid);
    const v = (entry.exitHHMM != null && entry.exitHHMM !== "") ? entry.exitHHMM
            : (entry.exitReal != null && entry.exitReal !== "") ? entry.exitReal
            : (a.exitReal != null && a.exitReal !== "") ? a.exitReal
            : "";
    return fmtHHMM(v);
  };

  const uniqDepthsDesc = (paliers)=> {
    const set = new Set();
    (paliers || []).forEach(p=>{
      const d = numOrNullPdf(p?.depth);
      if (d == null) return;
      set.add(d);
    });
    return Array.from(set).sort((a,b)=> b-a);
  };

  const palierDurationAt = (paliers, depth)=> {
    const hit = (paliers || []).find(p=> numOrNullPdf(p?.depth) === depth);
    if (!hit) return "—";
    const t = numOrNullPdf(hit?.time);
    return (t == null ? "—" : String(Math.round(t)));
  };

  const renderPaliersMatrix = (title, paliers)=> {
    html += `<div class="pdf-section-title">${esc(title)}</div>`;
    const depths = uniqDepthsDesc(paliers);
    if (!depths.length) {
      html += `<div class="pdf-muted">Aucun palier renseigné</div>`;
      return;
    }
    html += '<table class="pdf-table"><tbody>';
    html += '<tr><th style="width:22%;">Profondeur</th>';
    depths.forEach(d=> { html += `<td style="text-align:center;">${esc(String(d))}m</td>`; });
    html += '</tr>';
    html += '<tr><th>Durée (min)</th>';
    depths.forEach(d=> { html += `<td style="text-align:center;">${esc(palierDurationAt(paliers, d))}</td>`; });
    html += '</tr>';
    html += '</tbody></table>';
  };

  const renderIncidentsTable = (gid, names)=> {
    html += `<div class="pdf-section-title">Incidents</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Acteur</th><th>Incidents</th></tr></thead><tbody>';
    let any = false;

    (names || []).forEach(nm=>{
      const e = getAfterEntryPdf(gid, nm);
      const tags = Array.isArray(e.incidents) ? e.incidents : [];
      const note = clean(e.incident_note);
      const parts = [];
      if (tags.length) parts.push(tags.join(", "));
      if (note) parts.push("Note: " + note);
      const txt = parts.join(" — ");
      if (!txt) return;
      any = true;
      html += `<tr><td>${esc(nm)}</td><td>${esc(txt)}</td></tr>`;
    });

    if (!any) {
      html += `<tr><td colspan="2" class="pdf-muted">Aucun</td></tr>`;
    }
    html += '</tbody></table>';
  };

  const renderMultiDecoBlock = (gid)=> {
    const rec = getGroupRecord(gid) || {};
    const before = rec.before || {};
    const siteGroup = String(before.siteGroup || "").toUpperCase();
    const isAir = (siteGroup === "AIR");
    if (isAir) return;

    const rt1 = clean(before.rt1);
    const rt2 = clean(before.rt2);
    const rt3 = clean(before.rt3);
    if (!rt1 && !rt2 && !rt3) return;

    const boxStyle = 'style="white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:10px;border:1px solid #ddd;padding:6px;border-radius:6px;"';

    if (rt1) {
      html += `<div class="pdf-section-title">MultiDeco — ${esc(gid)} — RT1</div>`;
      html += `<div ${boxStyle}>${esc(rt1)}</div>`;
    }
    if (rt2) {
      html += `<div class="pdf-section-title">MultiDeco — ${esc(gid)} — RT2</div>`;
      html += `<div ${boxStyle}>${esc(rt2)}</div>`;
    }
    if (rt3) {
      html += `<div class="pdf-section-title">MultiDeco — ${esc(gid)} — RT3</div>`;
      html += `<div ${boxStyle}>${esc(rt3)}</div>`;
    }
  };

  const renderAutonomeGroupAfterPage = (gid)=> {
    // Page wrapper
    html += '<div class="pdf-page">';
    html += headerHtml(`Autonome — ${gid}`);

    const names = getGroupNames(gid) || [];

    // Leader = 1er plongeur (déterministe)
    const leaderName = names.length ? names[0] : "";
    const leaderInfo = leaderName ? getDiverInfo(leaderName) : { apt:"—", cert:"—", lic:"—" };

    html += `<div class="pdf-section-title">${esc(gid)} — Leader</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Nom</th><th>Rôle</th><th>Aptitude</th><th>Certification(s)</th><th>Licence</th></tr></thead><tbody>';
    if (!leaderName) {
      html += `<tr><td>Aucun</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>`;
    } else {
      html += `<tr><td>${esc(leaderName)}</td><td>Leader</td><td>${esc(leaderInfo.apt)}</td><td>${esc(leaderInfo.cert)}</td><td>${esc(leaderInfo.lic)}</td></tr>`;
    }
    html += '</tbody></table>';

    // Plongeurs
    html += `<div class="pdf-section-title">${esc(gid)} — Plongeurs</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Nom</th><th>Aptitude</th><th>Certification(s)</th><th>Licence</th></tr></thead><tbody>';
    if (!names.length) {
      html += `<tr><td colspan="4" class="pdf-muted">Aucun plongeur affecté</td></tr>`;
    } else {
      names.forEach(nm=>{
        const info = getDiverInfo(nm);
        html += `<tr><td>${esc(nm)}</td><td>${esc(info.apt)}</td><td>${esc(info.cert)}</td><td>${esc(info.lic)}</td></tr>`;
      });
    }
    html += '</tbody></table>';

    // Données réalisées (colonnes)
    html += `<div class="pdf-section-title">${esc(gid)} — Réalisé</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Plongeur</th><th>Prof. max réelle (m)</th><th>Runtime réel (min)</th><th>Sortie réelle</th></tr></thead><tbody>';
    if (!names.length) {
      html += `<tr><td colspan="4" class="pdf-muted">Aucun</td></tr>`;
    } else {
      names.forEach(nm=>{
        const e = getAfterEntryPdf(gid, nm);
        html += `<tr>
          <td>${esc(nm)}</td>
          <td style="text-align:center;">${esc(pickDepthPdf(e))}</td>
          <td style="text-align:center;">${esc(pickRuntimePdf(e))}</td>
          <td style="text-align:center;">${esc(pickExitPdf(gid, e))}</td>
        </tr>`;
      });
    }
    html += '</tbody></table>';

    // Paliers réalisés
    if (!names.length) {
      html += `<div class="pdf-section-title">${esc(gid)} — Paliers réalisés</div>`;
      html += `<div class="pdf-muted">Aucun plongeur affecté</div>`;
    } else {
      names.forEach(nm=>{
        const pDone = loadPaliersGeneric("after", gid, nm);
        renderPaliersMatrix(`${gid} — Paliers réalisés — ${nm}`, pDone);
      });
    }

    // Incidents
    renderIncidentsTable(gid, names);

    // MultiDeco (si Trimix/CCR)
    renderMultiDecoBlock(gid);

    html += '</div>'; // pdf-page
  };

  // Append AFTER pages for AUTONOME (Exploration) groups only
  if (bucket.EXPLORATION.length) {
    bucket.EXPLORATION.forEach((gid)=> {
      renderAutonomeGroupAfterPage(gid);
    });
  }




  // ===== AFTER PDF — ENCADREMENT + FORMATION (1 groupe = 1 page, header répété avec site) =====
  // NOTE: PAGE 1 + "Programme du jour" (prévu) sont intouchés; on ajoute uniquement des pages APRÈS ici.

  const getInstructorByIdPdf = (id)=> {
    const arr = Array.isArray(instructorLibrary) ? instructorLibrary : [];
    const hit = arr.find(x => x && x.id === id);
    if (!hit) return null;
    return {
      name: clean(hit.name),
      aptitude: clean(hit.aptitude),
      certification: clean(hit.certification),
      licence: clean(hit.licence)
    };
  };

  const getGroupInstructorPdf = (gid)=> {
    const sup = (groupSupervisors && groupSupervisors[gid]) ? groupSupervisors[gid] : null;
    if (!sup || sup.type !== "INSTRUCTOR_LIB" || !sup.value) return null;
    return getInstructorByIdPdf(sup.value);
  };

  const renderEncadreFormationGroupAfterPage = (gid, practice)=> {
    const isEncadre = (practice === "ENCADREE");
    const isFormation = (practice === "FORMATION");
    const title = isEncadre ? `Encadré — ${gid}` : `Formation — ${gid}`;
    const roleLabel = isEncadre ? "Encadrant" : "Formateur";

    html += '<div class="pdf-page">';
    html += headerHtml(title);

    const names = getGroupNames(gid) || [];

    // Leader = instructeur (instructorLibrary, par ID)
    const inst = getGroupInstructorPdf(gid);
    html += `<div class="pdf-section-title">${esc(gid)} — Leader</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Nom</th><th>Rôle</th><th>Aptitude</th><th>Certification(s)</th><th>Licence</th></tr></thead><tbody>';
    if (!inst || !inst.name) {
      html += `<tr><td>Aucun</td><td>${esc(roleLabel)}</td><td>—</td><td>—</td><td>—</td></tr>`;
    } else {
      html += `<tr><td>${esc(inst.name)}</td><td>${esc(roleLabel)}</td><td>${esc(dash(inst.aptitude))}</td><td>${esc(dash(inst.certification))}</td><td>${esc(dash(inst.licence))}</td></tr>`;
    }
    html += '</tbody></table>';

    // Plongeurs (identité)
    html += `<div class="pdf-section-title">${esc(gid)} — Plongeurs</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Nom</th><th>Aptitude</th><th>Certification(s)</th><th>Licence</th></tr></thead><tbody>';
    if (!names.length) {
      html += `<tr><td colspan="4" class="pdf-muted">Aucun plongeur affecté</td></tr>`;
    } else {
      names.forEach(nm=>{
        const info = getDiverInfo(nm);
        html += `<tr><td>${esc(nm)}</td><td>${esc(info.apt)}</td><td>${esc(info.cert)}</td><td>${esc(info.lic)}</td></tr>`;
      });
    }
    html += '</tbody></table>';

    // Données réalisées (colonnes)
    html += `<div class="pdf-section-title">${esc(gid)} — Réalisé</div>`;
    html += '<table class="pdf-table"><thead><tr><th>Plongeur</th><th>Prof. max réelle (m)</th><th>Runtime réel (min)</th><th>Sortie réelle</th></tr></thead><tbody>';
    if (!names.length) {
      html += `<tr><td colspan="4" class="pdf-muted">Aucun</td></tr>`;
    } else {
      names.forEach(nm=>{
        const e = getAfterEntryPdf(gid, nm);
        html += `<tr>
          <td>${esc(nm)}</td>
          <td style="text-align:center;">${esc(pickDepthPdf(e))}</td>
          <td style="text-align:center;">${esc(pickRuntimePdf(e))}</td>
          <td style="text-align:center;">${esc(pickExitPdf(gid, e))}</td>
        </tr>`;
      });
    }
    html += '</tbody></table>';

    // Paliers réalisés
    html += `<div class="pdf-section-title">${esc(gid)} — Paliers réalisés</div>`;

    // Formation: paliers groupe APRÈS si présents
    if (isFormation) {
      const gp = getAfterGroupPaliers ? getAfterGroupPaliers(gid) : [];
      if (Array.isArray(gp) && gp.length) {
        renderPaliersMatrix(`${gid} — Paliers réalisés — Groupe`, gp);
      }
    }

    if (!names.length) {
      html += `<div class="pdf-muted">Aucun plongeur affecté</div>`;
    } else {
      names.forEach(nm=>{
        const pDone = loadPaliersGeneric("after", gid, nm);
        renderPaliersMatrix(`${gid} — Paliers réalisés — ${nm}`, pDone);
      });
    }

    // Incidents
    renderIncidentsTable(gid, names);

    // MultiDeco (si Trimix/CCR)
    renderMultiDecoBlock(gid);

    html += '</div>'; // pdf-page
  };

  // Append AFTER pages: ENCADREMENT then FORMATION (order fixed)
  if (bucket.ENCADREMENT.length) {
    bucket.ENCADREMENT.forEach((gid)=> {
      renderEncadreFormationGroupAfterPage(gid, "ENCADREE");
    });
  }
  if (bucket.FORMATION.length) {
    bucket.FORMATION.forEach((gid)=> {
      renderEncadreFormationGroupAfterPage(gid, "FORMATION");
    });
  }


  // ---- Final page: DP validation & signature (visible in preview) ----
  const renderDpSignaturePage = ()=> {
    html += '<div class="pdf-page">';
    html += '<div class="pdf-content">';
    html += headerHtml("PROCÈS-VERBAL — Validation DP");

    html += '<div class="pdf-section-title">Validation finale — Directeur de Plongée</div>';
    html += '<table class="pdf-table"><tbody>';
    html += `<tr><th style="width:32%;">Centre</th><td>${esc(dash(centerName))}${centerId ? (" — " + esc(centerId)) : ""}</td></tr>`;
    html += `<tr><th style="width:32%;">Site</th><td>${esc(dash(ctxSite))}</td></tr>`;
    html += `<tr><th>Date</th><td>${esc(dateFR)}</td></tr>`;
    html += `<tr><th>Structure / Bateau</th><td>${esc(dash(ctxBoat))}</td></tr>`;
    html += `<tr><th>DP</th><td>${esc(dash(ctxDP))}</td></tr>`;
    html += '</tbody></table>';

    html += '<div class="pdf-section-title">Statut du document</div>';
    html += '<table class="pdf-table"><tbody>';
    html += '<tr><th style="width:32%;">Statut</th><td id="dpDocStatus">Brouillon (non validé)</td></tr>';
    html += '<tr><th>Validé le</th><td id="dpValidatedAt">—</td></tr>';
    html += '<tr><th>Signé le</th><td id="dpSignedAt">—</td></tr>';
    html += '</tbody></table>';

    html += '<div class="pdf-section-title">Déclaration du DP (France)</div>';
    html += '<div class="pdf-paragraph">';
    html += 'Je soussigné(e), Directeur de Plongée, atteste avoir organisé et supervisé les plongées mentionnées dans ce document, conformément aux dispositions du Code du Sport et aux règlements fédéraux en vigueur.<br><br>';
    html += 'Les paramètres réalisés, les paliers effectués et les incidents éventuels ont été consignés dans la présente fiche. Les plongeurs ont été informés des consignes de sécurité, et les moyens nécessaires à la sécurité de la plongée ont été mis en œuvre.';
    html += '</div>';

    // DP identity from Contexte du jour + Library lookup (France)
    const dpInfo = getInstructorOnlyInfo(ctxDP);
    const dpNameOut = dash(ctxDP);
    const dpLicOut = dash(dpInfo?.lic);
    const dpAptOut = dash(dpInfo?.apt);
    const dpCertOut = dash(dpInfo?.cert);
    const dpLieuDateOut = (ctxSite ? (ctxSite + " — le " + dateFR) : ("— le " + dateFR));

    html += '<div class="pdf-section-title">Signature</div>';
    html += '<table class="pdf-table"><tbody>';
    html += `<tr><th style="width:32%;">Nom & Prénom</th><td id="dpSigName">${esc(dpNameOut)}</td></tr>`;
    html += `<tr><th>Aptitude</th><td id="dpSigApt">${esc(dpAptOut)}</td></tr>`;
    html += `<tr><th>Certification(s)</th><td id="dpSigCert">${esc(dpCertOut)}</td></tr>`;
    html += `<tr><th>N° de licence</th><td id="dpSigLicence">${esc(dpLicOut)}</td></tr>`;
    html += `<tr><th>Lieu et date</th><td id="dpSigLieuDate">${esc(dpLieuDateOut)}</td></tr>`;
    html += '<tr><th>Signature</th><td style="height:70px;">&nbsp;</td></tr>';
    html += '</tbody></table>';

    html += '</div></div>'; // pdf-content, pdf-page
  };
  renderDpSignaturePage();


  const preview = document.getElementById("pdf-preview");
  if (preview) {
    preview.innerHTML = html;
    preview.scrollIntoView({ behavior: "smooth", block: "start" });
    resetPdfActionsState();
    showPdfActionsBar();
    bindPdfActionsOnce();
    updatePdfActionsUi();
    updateDpSignaturePage();
  }
}

  let pdfState = "draft"; // draft → validated → signed
  let pdfValidatedAt = null;
  let pdfSignedAt = null;

  function updateDpSignaturePage() {
    const st = document.getElementById("dpDocStatus");
    const vAt = document.getElementById("dpValidatedAt");
    const sAt = document.getElementById("dpSignedAt");

    if (st) {
      if (pdfState === "draft") st.textContent = "Brouillon (non validé)";
      else if (pdfState === "validated") st.textContent = "Validé (non signé)";
      else if (pdfState === "signed") st.textContent = "Signé électroniquement";
    }
    if (vAt) vAt.textContent = pdfValidatedAt ? pdfValidatedAt : "—";
    if (sAt) sAt.textContent = pdfSignedAt ? pdfSignedAt : "—";

    // Keep DP identity fields consistent in case context changed before preview
    const n = document.getElementById("dpSigName");
    const a = document.getElementById("dpSigApt");
    const c = document.getElementById("dpSigCert");
    const l = document.getElementById("dpSigLicence");
    const ld = document.getElementById("dpSigLieuDate");
    if (n || a || c || l || ld) {
      try {
        const dpName = clean(document.getElementById("dive_const_dp")?.value);
        const dpI = getEncadrementInfo(dpName);
        if (n) n.textContent = dash(dpName);
        if (a) a.textContent = dash(dpI?.apt);
        if (c) c.textContent = dash(dpI?.cert);
        if (l) l.textContent = dash(dpI?.lic);
        if (ld) {
          const site = clean(document.getElementById("dive_site_name")?.value || document.getElementById("dive_site_select")?.value);
          const dateFRlocal = new Date().toLocaleDateString("fr-FR");
          const base = (site ? (site + " — le " + dateFRlocal) : ("— le " + dateFRlocal));
          // If signed, we also show signed timestamp
          ld.textContent = (pdfState === "signed" && pdfSignedAt) ? (base + " (signé à " + pdfSignedAt + ")") : base;
        }
      } catch(e) {}
    }
  }


  function showPdfActionsBar() {
    const bar = document.getElementById("pdfActionsBar");
    if (bar) bar.style.display = "flex";
  }

  function hidePdfActionsBar() {
    const bar = document.getElementById("pdfActionsBar");
    if (bar) bar.style.display = "none";
  }

  function resetPdfActionsState() {
    pdfState = "draft";
    pdfValidatedAt = null;
    pdfSignedAt = null;
    updateDpSignaturePage();
  }

  function updatePdfActionsUi() {
    const btnValidate = document.getElementById("btnValidate");
    const btnSign = document.getElementById("btnSign");
    const lbl = document.getElementById("pdfStateLabel");

    if (btnValidate) btnValidate.disabled = (pdfState !== "draft");
    if (btnSign) btnSign.disabled = (pdfState !== "validated");

    if (lbl) {
      lbl.classList.remove("state-validated","state-signed");
      if (pdfState === "draft") {
        lbl.textContent = "Brouillon";
      } else if (pdfState === "validated") {
        lbl.textContent = "Validé";
        lbl.classList.add("state-validated");
      } else if (pdfState === "signed") {
        lbl.textContent = "Signé";
        lbl.classList.add("state-signed");
      }
    }

    const stamp = document.getElementById("pdfSignedStamp");
    if (stamp) stamp.style.display = (pdfState === "signed") ? "" : "none";
  }
function renderSignedStamp() {
    const preview = document.getElementById("pdf-preview");
    if (!preview) return;

    let stamp = document.getElementById("pdfSignedStamp");
    if (!stamp) {
      stamp = document.createElement("div");
      stamp.id = "pdfSignedStamp";
      preview.prepend(stamp);
    }
    const now = new Date();
    const ts = now.toLocaleString("fr-FR");
    stamp.textContent = `✔ Document signé électroniquement — ${ts}`;
  }
function closePdfPreview() {
    const preview = document.getElementById("pdf-preview");
    if (preview) preview.innerHTML = "";
    hidePdfActionsBar();
  }

  function bindPdfActionsOnce() {
    const btnValidate = document.getElementById("btnValidate");
    const btnSign = document.getElementById("btnSign");
    const btnQuit = document.getElementById("btnQuit");

    if (btnValidate && !btnValidate.dataset.bound) {
      btnValidate.addEventListener("click", () => {
        pdfState = "validated";
        pdfValidatedAt = new Date().toLocaleString("fr-FR");
        updatePdfActionsUi();
        updateDpSignaturePage();
        alert("Document validé.");
      });
      btnValidate.dataset.bound = "1";
    }

    if (btnSign && !btnSign.dataset.bound) {
      btnSign.addEventListener("click", () => {
        if (pdfState !== "validated") {
          alert("Veuillez valider le document avant signature.");
          return;
        }
        pdfState = "signed";
        pdfSignedAt = new Date().toLocaleString("fr-FR");
        updatePdfActionsUi();
        updateDpSignaturePage();
        renderSignedStamp();
        alert("Document signé électroniquement.");
      });
      btnSign.dataset.bound = "1";
    }

    if (btnQuit && !btnQuit.dataset.bound) {
      btnQuit.addEventListener("click", () => {
        closePdfPreview();
      });
      btnQuit.dataset.bound = "1";
    }
  }
   

  async function exportPdf() {
    buildPdfMock();

    const preview = document.getElementById("pdf-preview");
    if (!preview) {
      alert("Zone de prévisualisation introuvable.");
      return;
    }

    const pages = preview.querySelectorAll(".pdf-page");
    if (!pages.length) {
      alert("Aucune page PDF à exporter.");
      return;
    }

    if (!window.html2canvas || !(window.jspdf && window.jspdf.jsPDF)) {
      alert("Librairies PDF manquantes (html2canvas / jsPDF).");
      return;
    }

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF("p", "mm", "a4");

    try {
      for (let i = 0; i < pages.length; i++) {
        const pageEl = pages[i];

        const canvas = await html2canvas(pageEl, {
          scale: 2,
          useCORS: true
        });

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        const imgOrigWidth = canvas.width;
        const imgOrigHeight = canvas.height;

        const scale = Math.min(
          pageWidth / imgOrigWidth,
          pageHeight / imgOrigHeight
        );

        const imgWidth = imgOrigWidth * scale;
        const imgHeight = imgOrigHeight * scale;

        const x = (pageWidth - imgWidth) / 2;
        const y = 0;

        if (i > 0) {
          pdf.addPage();
        }

        const imgData = canvas.toDataURL("image/jpeg", 0.95);
        pdf.addImage(imgData, "JPEG", x, y, imgWidth, imgHeight);
      }
    } catch (e) {
      console.error("Erreur pendant la génération PDF:", e);
      alert("Erreur pendant la génération du PDF (CORS / html2canvas).");
      return;
    }

    const blob = pdf.output("blob");

    let shared = false;
    if (navigator.share && window.File) {
      try {
        const file = new File([blob], (getCenterDisplayName ? ("DivingLog_" + getCenterDisplayName().replace(/[^a-z0-9]+/gi,"_").slice(0,32)) : "DivingLog") + "_Groupes.pdf", {
          type: "application/pdf"
        });

        if (!navigator.canShare || navigator.canShare({ files: [file] })) {
          await navigator.share({
            files: [file],
            title: (getCenterDisplayName ? (getCenterDisplayName() + " — Groupes") : "Groupes"),
            text: "Plongeurs du jour & groupes (PDF)."
          });
          shared = true;
        }
      } catch (e) {
        console.warn("Partage natif annulé ou non supporté:", e);
      }
    }

    if (!shared) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = (getCenterDisplayName ? ("DivingLog_" + getCenterDisplayName().replace(/[^a-z0-9]+/gi,"_").slice(0,32)) : "DivingLog") + "_Groupes.pdf";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      alert(
        "PDF généré. Ouvre-le puis partage-le via WhatsApp depuis ton appareil."
      );
    }
  }

  function buildGroupColumnForIndex(index) {
  const model = document.querySelector('.group-column[data-group="G1"]');
  if (!model) return null;

  const gid = "G" + index;
  const prefix = "g" + index;

  // Clone G1 template → becomes G2, G3, G4...
  const col = model.cloneNode(true);
  col.setAttribute("data-group", gid);

  // Update header text and base label
  const header = col.querySelector(".group-header");
  if (header) {
    header.setAttribute("data-base-label", "Groupe " + index);
    header.textContent = "Groupe " + index;
  }

  // update before/after button IDs
  const beforeBtn = col.querySelector("#g1_before");
  if (beforeBtn) beforeBtn.id = prefix + "_before";

  const afterBtn = col.querySelector("#g1_after");
  if (afterBtn) afterBtn.id = prefix + "_after";

  // IMPORTANT: clone copies data-bound from G1, but event listeners are NOT cloned.
  // So we must clear data-bound to allow attachGroupButtonsHandlers() to bind clicks for new groups.
  if (beforeBtn) delete beforeBtn.dataset.bound;
  if (afterBtn)  delete afterBtn.dataset.bound;


  // update diver list
  const listEl = col.querySelector("#group-G1-list");
  if (listEl) {
    listEl.id = "group-" + gid + "-list";
    listEl.innerHTML = "";
  }

  return col;
}

  function addNewGroup() {
  const currentCount = GROUP_IDS.length;

  if (currentCount >= MAX_GROUPS) {
    alert("Nombre maximal de groupes atteint (" + MAX_GROUPS + ").");
    return;
  }

  const nextIndex = currentCount + 1;
  const gid = "G" + nextIndex;

  const row = document.getElementById("group-main-row");
  if (!row) {
    alert("Zone des groupes introuvable.");
    return;
  }

  const newCol = buildGroupColumnForIndex(nextIndex);
  if (!newCol) {
    alert("Impossible de créer un nouveau groupe.");
    return;
  }

  GROUP_IDS.push(gid);
  groupAssignments[gid] = [];

  ensureDefaultGroupPractice(gid);
  saveGroupPractice();
  renderValidationBanner();


  row.appendChild(newCol);

  setupGroupDropZones();
  renderGroupAssignments();
  updateGroupHeadersWithLeaders();
  attachGroupButtonsHandlers();
}

  // ===========================
  // NAVIGATION AVANT / APRÈS GROUPE
  // ===========================

  let currentGroupId = null; // G1, G2, ...

 function showMainLayout(focusGroupId) {
  const secPlongeurs = document.getElementById("sec-plongeurs-jour");
  const secGroupes   = document.getElementById("sec-groupes");
  const secExport    = document.getElementById("sec-export");
  const secPdfMock   = document.getElementById("sec-pdf-mock");
  const secBefore    = document.getElementById("sec-before-group");
  const secAfter     = document.getElementById("sec-after-group");
  const secSiteGps   = document.getElementById("sec-site-gps");

  // Boutons "Retour aux groupes"
  const beforeBackBtn = document.getElementById("btn_before_back");
  const afterBackBtn  = document.getElementById("btn_after_back");

  // Afficher uniquement les sections du layout principal
  if (secPlongeurs) secPlongeurs.style.display = "block";
  if (secGroupes)   secGroupes.style.display   = "block";
  if (secExport)    secExport.style.display    = "block";
  if (secPdfMock)   secPdfMock.style.display   = "block";
  if (secSiteGps)   secSiteGps.style.display   = "";

  // Masquer les sections plein écran AVANT / APRÈS
  if (secBefore)    secBefore.style.display    = "none";
  if (secAfter)     secAfter.style.display     = "none";

  // Masquer systématiquement les deux boutons sur la page principale
  if (beforeBackBtn) beforeBackBtn.style.display = "none";
  if (afterBackBtn)  afterBackBtn.style.display  = "none";

  // Focus: revenir précisément sur le groupe qu'on vient de quitter (si demandé)
  const gid = focusGroupId || currentGroupId;
  if (gid) {
    requestAnimationFrame(() => {
      try {
        const col = document.querySelector('.group-column[data-group="' + gid + '"]');
        if (col && typeof col.scrollIntoView === "function") {
          col.scrollIntoView({ block: "start", behavior: "auto" });
        }
      } catch(e) {}
    });
  }
}
  function openBeforeView(groupId) {
  currentGroupId = groupId;

  const secPlongeurs = document.getElementById("sec-plongeurs-jour");
  const secGroupes   = document.getElementById("sec-groupes");
  const secExport    = document.getElementById("sec-export");
  const secPdfMock   = document.getElementById("sec-pdf-mock");
  const secBefore    = document.getElementById("sec-before-group");
  const secAfter     = document.getElementById("sec-after-group");
  const headerName   = document.getElementById("before_group_name");
  const secSiteGps   = document.getElementById("sec-site-gps");

  // Boutons "Retour"
  const beforeBackBtn = document.getElementById("btn_before_back");
  const afterBackBtn  = document.getElementById("btn_after_back");

  // cacher le layout principal
  if (secPlongeurs) secPlongeurs.style.display = "none";
  if (secGroupes)   secGroupes.style.display   = "none";
  if (secExport)    secExport.style.display    = "none";
  if (secPdfMock)   secPdfMock.style.display   = "none";
  if (secSiteGps) secSiteGps.style.display     = "none";

  // ne laisser visible que la section AVANT
  if (secAfter)     secAfter.style.display     = "none";
  if (secBefore)    secBefore.style.display    = "";

  // STEP 1: positionner l'affichage au début de la page
  window.scrollTo({ top: 0, left: 0, behavior: "auto" });

  // n'afficher que le bouton "Retour" AVANT
  if (beforeBackBtn) beforeBackBtn.style.display = "inline-flex";
  if (afterBackBtn)  afterBackBtn.style.display  = "none";

  if (headerName) headerName.textContent = groupId;
  renderBeforeGroupMeta(groupId);
  populateBeforeForm(groupId);
  updateInScenarios();

  // Re-bind selector change AFTER DOM is rendered
  const typeSelect = document.getElementById("group_before_site_group");
  if (typeSelect) {
    typeSelect.onchange = () => {
      updateBeforeLayoutByType();
    };
  }

  // Apply layout immediately
  updateBeforeLayoutByType();

}

function renderBeforeGroupMeta(groupId) {
  const meta = document.getElementById("before_group_meta");
  if (!meta) return;

  const divers = groupAssignments[groupId] || [];
  const info = getGroupResponsibleInfo(groupId);

  let lines = [];
  if (info && info.label) {
    const title = (info.role === "leader") ? "Leader" : "Instructeur";
    lines.push(`${title} : ${info.label}`);
  }
  if (divers.length) lines.push(`${divers.length} plongeur(s) : ${divers.join(", ")}`);
  meta.innerHTML = lines.join("<br>");
}


  function openAfterView(groupId) {
  currentGroupId = groupId;

  const secPlongeurs = document.getElementById("sec-plongeurs-jour");
  const secGroupes   = document.getElementById("sec-groupes");
  const secExport    = document.getElementById("sec-export");
  const secPdfMock   = document.getElementById("sec-pdf-mock");
  const secBefore    = document.getElementById("sec-before-group");
  const secAfter     = document.getElementById("sec-after-group");
  const headerName   = document.getElementById("after_group_name");
  const secSiteGps   = document.getElementById("sec-site-gps");

  // Boutons "Retour"
  const beforeBackBtn = document.getElementById("btn_before_back");
  const afterBackBtn  = document.getElementById("btn_after_back");

  // cacher le layout principal
  if (secPlongeurs) secPlongeurs.style.display = "none";
  if (secGroupes)   secGroupes.style.display   = "none";
  if (secExport)    secExport.style.display    = "none";
  if (secPdfMock)   secPdfMock.style.display   = "none";
  if (secSiteGps) secSiteGps.style.display     = "none";

  // ne laisser visible que la section APRÈS
  if (secBefore)    secBefore.style.display    = "none";
  if (secAfter)     secAfter.style.display     = "";

  // n'afficher que le bouton "Retour" APRÈS
  if (beforeBackBtn) beforeBackBtn.style.display = "none";
  if (afterBackBtn)  afterBackBtn.style.display  = "inline-flex";

  if (headerName) {
    const info = getGroupResponsibleInfo(groupId);
    if (info && info.label) {
      const title = (info.role === "leader") ? "Leader" : "Instructeur";
      headerName.textContent = `${groupId} - ${title.toLowerCase()} ${info.label}`;
    } else {
      headerName.textContent = groupId;
    }
  }
  // Meta: nombre de plongeurs + liste (sous "Groupe")
  try {
    const metaEl = document.getElementById("after_group_meta");
    if (metaEl) {
      const list = getAfterDiverNames(groupId);
      const n = list.length;
      metaEl.textContent = n ? `${n} plongeur${n > 1 ? "s" : ""} : ${list.join(", ")}` : "";
    }
  } catch (e) {}
  // --- FIX regression (TRIMIX/CCR): garantir que l'heure IN du groupe est bien stockée
  // Nécessaire pour le calcul auto des "Heure de sortie" par plongeur dans la fiche APRÈS.
  try {
    const rec = getGroupRecord(groupId);
    if (rec) {
      if (!rec.before) rec.before = {};
      const inEl = document.getElementById("group_before_in_planned");
      const v = inEl ? String(inEl.value || "").trim() : "";
      if (v) {
        rec.before.inPlanned = v;
        saveGroupDetails();
      }
    }
  } catch (e) {}
  populateAfterForm(groupId);
  attachHHMMInput(document.getElementById("group_after_exit_real"));
  // STEP 2: se placer au début du bloc "Groupe – données réelles"
  const afterAnchor = document.getElementById("group_after_date")
                  || document.getElementById("after_group_header")
                  || secAfter;
  requestAnimationFrame(() => {
    try { afterAnchor.scrollIntoView({ block: "start", behavior: "auto" }); } catch (e) {}
  });
}

  // Attacher proprement les handlers sur les boutons Avant / Après
  function attachGroupButtonsHandlers() {
    if (!Array.isArray(GROUP_IDS)) return;

    GROUP_IDS.forEach(gid => {
      const index  = parseInt(gid.substring(1), 10); // G1 -> 1, G2 -> 2...
      if (!index || isNaN(index)) return;
      const prefix = "g" + index;

      const beforeBtn = document.getElementById(prefix + "_before");
      const afterBtn  = document.getElementById(prefix + "_after");

      if (beforeBtn && !beforeBtn.dataset.bound) {
        beforeBtn.addEventListener("click", function () {
          openBeforeView(gid);
        });
        beforeBtn.dataset.bound = "1";
      }

      if (afterBtn && !afterBtn.dataset.bound) {
        afterBtn.addEventListener("click", function () {
          openAfterView(gid);
        });
        afterBtn.dataset.bound = "1";
      }
    });
  }

function populateBeforeForm(groupId) {
  const rec = getGroupRecord(groupId);
  if (!rec) return;

  const before = rec.before || {};

  const dateEl        = document.getElementById("group_before_date");
  const dtrMaxEl      = document.getElementById("group_before_dtr_max");
  const siteMainEl    = document.getElementById("group_before_site_main");
  const siteGroupEl   = document.getElementById("group_before_site_group");
  const modeEl        = document.getElementById("group_before_mode");
  const depthEl       = document.getElementById("group_before_depth_planned");
  const bottomTimeEl  = document.getElementById("group_before_bottom_time_planned");
  const rtGroupEl     = document.getElementById("group_before_runtime_group_planned");
  const inPlannedEl   = document.getElementById("group_before_in_planned");
  const exitPlannedEl = document.getElementById("group_before_exit_planned");
  const rt1El         = document.getElementById("group_before_rt1");
  const rt2El         = document.getElementById("group_before_rt2");
  const rt3El         = document.getElementById("group_before_rt3");

  if (dateEl)        dateEl.value        = before.date        || "";
  if (dtrMaxEl)      dtrMaxEl.value      = (before.dtrMaxMin != null) ? String(before.dtrMaxMin) : "";
  const titleDate = document.getElementById("before_date_title");
  if (titleDate)  titleDate.textContent = (before.date && String(before.date).trim()) ? String(before.date).trim() : "—";
  if (siteMainEl)    siteMainEl.value    = before.siteMain    || "";
  if (siteGroupEl)   siteGroupEl.value   = before.siteGroup   || "";
  if (modeEl)        modeEl.value        = before.mode        || "";

  if (depthEl)       depthEl.value       =
      (before.depthPlanned        != null ? before.depthPlanned        : "");
  if (bottomTimeEl)  bottomTimeEl.value  =
      (before.bottomTimePlanned   != null ? before.bottomTimePlanned   : "");
  if (rtGroupEl)     rtGroupEl.value     =
      (before.runtimeGroupPlanned != null ? before.runtimeGroupPlanned : "");

  if (inPlannedEl)   inPlannedEl.value   = before.inPlanned   || "";
  if (exitPlannedEl) exitPlannedEl.value = before.exitPlanned || "";
  if (rt1El)         rt1El.value         = before.rt1         || "";
  if (rt2El)         rt2El.value         = before.rt2         || "";
  if (rt3El)         rt3El.value         = before.rt3         || "";

  // __STEP1_PER_GROUP_DEFAULTS__ (per group, like Fiche de plongée)
  // Default date (dd/mm/yyyy) only if empty
  if (dateEl && (!dateEl.value || String(dateEl.value).trim() === "")) {
    dateEl.value = todayDDMMYYYY();
    before.date = dateEl.value;
  }
  // Default time_in only if empty
  if (inPlannedEl && (!inPlannedEl.value || String(inPlannedEl.value).trim() === "")) {
    inPlannedEl.value = nowHHMM();
    before.inPlanned = inPlannedEl.value;
  }
  // Compute exit if RT minutes present
  if (exitPlannedEl) {
    // ensure RT input is editable (may be present only in header)
    const rtInput = document.getElementById("group_before_runtime_group_planned");
    if (rtInput) {
      rtInput.removeAttribute("disabled");
      rtInput.removeAttribute("readonly");
    }
    updateExitPlannedFromInAndRT();
    if (exitPlannedEl.value) before.exitPlanned = exitPlannedEl.value;
  }

  // Normalize type selector (legacy site text -> AIR)
  if (siteGroupEl) {
    const v = String(siteGroupEl.value || "").trim();
    if (v !== "AIR" && v !== "TRIMIX_CCR") siteGroupEl.value = "AIR";
  }

  // Apply UI visibility for AIR vs TRIMIX/CCR
  updateBeforeLayoutByType();
  updateBeforeAnalyseButtonState();

  // --- Rebind MultiDeco inputs AFTER DOM is rendered (important: DOM may be re-created) ---
  
  if (rt1El) {
    rt1El.oninput = updateBeforeAnalyseButtonState;
    rt1El.onchange = updateBeforeAnalyseButtonState; // paste on some browsers triggers change
  }
  if (rt2El) {
    rt2El.oninput = updateBeforeAnalyseButtonState;
    rt2El.onchange = updateBeforeAnalyseButtonState;
  }
  if (rt3El) {
    rt3El.oninput = updateBeforeAnalyseButtonState;
    rt3El.onchange = updateBeforeAnalyseButtonState;
  }

  // Ensure correct state immediately after populate (e.g., reload with stored RT1)
  updateBeforeAnalyseButtonState();
  // Sync header summary (date/DTR/sortie)
  const dtrSpan = document.getElementById("before_md_dtr");
  if (dtrSpan) dtrSpan.textContent = (before.dtrMaxMin != null) ? (before.dtrMaxMin + " min") : "—";
  const exitSpan = document.getElementById("before_md_exit");
  if (exitSpan) exitSpan.textContent = (before.exitPlanned && String(before.exitPlanned).trim()) ? String(before.exitPlanned).trim() : "—";


}

// --- STEP 3.2/3.3: Avant plongée AIR vs TRIMIX/CCR (UI + stockage brut MultiDeco) ---
function beforeGetTypeValue(){
  const sel = document.getElementById("group_before_site_group");
  const v = sel ? String(sel.value || "").trim() : "";
  return (v === "TRIMIX_CCR") ? "TRIMIX_CCR" : "AIR";
}

function updateBeforeLayoutByType(){
  const type = beforeGetTypeValue();
  const trimixBox = document.getElementById("before_trimix_container");
  if (trimixBox) trimixBox.style.display = (type === "TRIMIX_CCR") ? "block" : "none";

  // Hide AIR-only inputs when TRIMIX/CCR
  const hide = (type === "TRIMIX_CCR");

  const rtGroupEl = document.getElementById("group_before_runtime_group_planned");
  const depthEl   = document.getElementById("group_before_depth_planned");
  const exitEl    = document.getElementById("group_before_exit_planned");

  [rtGroupEl, depthEl, exitEl].forEach((el) => {
    if (!el) return;
    const field = el.closest ? el.closest(".field") : el.parentElement;
    if (field) field.style.display = hide ? "none" : "";
  });

  // In TRIMIX/CCR, keep selector + inPlanned + scenarios visible as-is.
  updateBeforeAnalyseButtonState();
}

function updateBeforeAnalyseButtonState(){
  const type = beforeGetTypeValue();
  const btn = document.getElementById("btn_analyser_rt1");
  if (!btn) return;

  const rt1 = document.getElementById("group_before_rt1");
  const hasRT1 = rt1 && String(rt1.value || "").trim().length > 0;

  btn.disabled = !(type === "TRIMIX_CCR" && hasRT1);
}

function saveBeforeMultiDecoRaw(){
  if (!currentGroupId) return;
  const rec = getGroupRecord(currentGroupId);
  if (!rec) return;
  if (!rec.before) rec.before = {};

  const rt1El = document.getElementById("group_before_rt1");
  const rt2El = document.getElementById("group_before_rt2");
  const rt3El = document.getElementById("group_before_rt3");

  rec.before.rt1 = rt1El ? String(rt1El.value || "") : "";
  rec.before.rt2 = rt2El ? String(rt2El.value || "") : "";
  rec.before.rt3 = rt3El ? String(rt3El.value || "") : "";

  saveGroupDetails();

  const st = document.getElementById("before_md_status");
  if (st) st.textContent = "RT enregistrés (brut) ✓";
}




function renderAfterDivers(groupId) {
  const container = document.getElementById("group_after_divers_container");
  if (!container) return;

  container.innerHTML = "";

  const rec = getGroupRecord(groupId);
  if (!rec) return;
  const before = rec.before || {};
  const isAir = String(before.siteGroup || "").toUpperCase() === "AIR";

  const after = rec.after || {};
  if (!after.divers || typeof after.divers !== "object") after.divers = {};

  const names = getAfterDiverNames(groupId);
  if (!names.length) {
    container.innerHTML = '<p class="help-text">Aucun plongeur affecté à ce groupe.</p>';
    return;
  }

  names.forEach(diverName => {
    const key = normalizeName(diverName);
    const beforeP = loadPaliersGeneric("before", groupId, diverName);
    const afterEntry = after.divers[key] || {};

   
   // AFTER is factual: do NOT prefill "paliers effectués" from planned
   // UI convenience only: if no "after" exists yet, show planned stops as starting point (no storage write here)
    const pDoneStored = (Array.isArray(afterEntry.paliersDone) ? afterEntry.paliersDone : []);
    const pDone =
      pDoneStored.length
        ? pDoneStored
        : (Array.isArray(beforeP) ? beforeP.map(p => ({ ...p })) : []);
    const rtVal = (afterEntry.runtimeMin != null && afterEntry.runtimeMin !== "") ? String(afterEntry.runtimeMin) : ((afterEntry.runtimeReal != null) ? String(afterEntry.runtimeReal) : "");
    const exitVal = (afterEntry.exitHHMM != null && afterEntry.exitHHMM !== "") ? String(afterEntry.exitHHMM) : ((afterEntry.exitReal != null && afterEntry.exitReal !== "") ? String(afterEntry.exitReal) : (after.exitReal || ""));
    const depthVal =
      (afterEntry.depthRealM != null && afterEntry.depthRealM !== "")
        ? String(afterEntry.depthRealM)
        : "";
    const card = document.createElement("div");
    card.className = "diver-card";
    card.style.marginBottom = "8px";

    const main = document.createElement("div");
    main.className = "diver-card-main";

    // Top line
    const top = document.createElement("div");
    top.style.display = "flex";
    top.style.flexWrap = "wrap";
    top.style.gap = "10px";
    top.style.alignItems = "center";

    const nameEl = document.createElement("div");
    nameEl.className = "diver-card-name";
    nameEl.textContent = diverName;

    const rtWrap = document.createElement("div");
    rtWrap.style.display = "flex";
    rtWrap.style.gap = "6px";
    rtWrap.style.alignItems = "center";
    rtWrap.innerHTML = '<span class="help-text" style="margin:0;">Runtime réalisé</span>';

    const rtInput = document.createElement("input");
    rtInput.type = "number";
    rtInput.inputMode = "numeric";
    rtInput.min = "0";
    rtInput.step = "1";
    rtInput.placeholder = "min";
    rtInput.id = "after_rt__" + key;
    rtInput.value = rtVal;
    rtInput.style.maxWidth = "110px";
    rtInput.style.width = "110px";

    const rtUnit = document.createElement("span");
    rtUnit.className = "help-text";
    rtUnit.style.margin = "0";
    rtUnit.textContent = "min";

    const exitWrap = document.createElement("div");
    exitWrap.style.display = "flex";
    exitWrap.style.gap = "6px";
    exitWrap.style.alignItems = "center";
    exitWrap.innerHTML = '<span class="help-text" style="margin:0;">Heure de sortie</span>';

    const exitInput = document.createElement("input");
    exitInput.type = "text";
    exitInput.inputMode = "numeric";
    exitInput.placeholder = "HH:MM";
    exitInput.maxLength = 5;
    exitInput.id = "after_exit__" + key;
    exitInput.value = exitVal;
    exitInput.style.maxWidth = "110px";
    exitInput.style.width = "110px";
    attachHHMMInput(exitInput);
    // --- Cohérence Runtime <-> Heure de sortie (spec 1.1) ---
    // Base: heure de mise à l'eau réelle du groupe (stockée dans BEFORE inPlanned)
    const timeInGroup = (rec.before && rec.before.inPlanned) ? String(rec.before.inPlanned) : "";
    const toMinutes = (hhmm) => {
      const p = parseHHMM(hhmm);
      return p ? (p.hh * 60 + p.mm) : null;
    };
    const fromMinutes = (mins) => {
      if (mins == null || isNaN(mins)) return "";
      const m = ((mins % (24*60)) + (24*60)) % (24*60);
      const hh = Math.floor(m/60), mm = m % 60;
      return String(hh).padStart(2,"0") + ":" + String(mm).padStart(2,"0");
    };
    const computeRuntime = (inHHMM, outHHMM) => {
      const a = toMinutes(inHHMM);
      const b = toMinutes(outHHMM);
      if (a == null || b == null) return null;
      let d = b - a;
      if (d < 0) d += 24*60; // passage minuit
      return d;
    };

    // Si l'un change, on met à jour l'autre (sans boucle infinie)
    let _syncLock = false;

    const syncFromRuntime = () => {
      if (_syncLock) return;
      if (!timeInGroup) return;
      const rt = parseInt(rtInput.value, 10);
      if (isNaN(rt)) return;
      const inMin = toMinutes(timeInGroup);
      if (inMin == null) return;
      _syncLock = true;
      exitInput.value = fromMinutes(inMin + rt);
      _syncLock = false;
    };

    const syncFromExit = () => {
      if (_syncLock) return;
      if (!timeInGroup) return;
      const rt = computeRuntime(timeInGroup, exitInput.value);
      if (rt == null) return;
      _syncLock = true;
      rtInput.value = String(rt);
      _syncLock = false;
    };

    rtInput.addEventListener("input", syncFromRuntime);
    exitInput.addEventListener("input", syncFromExit);

const depthWrap = document.createElement("div");
depthWrap.style.display = "flex";
depthWrap.style.gap = "6px";
depthWrap.style.alignItems = "center";
depthWrap.innerHTML = '<span class="help-text" style="margin:0;">Profondeur réalisée</span>';

const depthInput = document.createElement("input");
depthInput.type = "number";
depthInput.inputMode = "numeric";
depthInput.min = "0";
depthInput.step = "1";
depthInput.placeholder = "m";
depthInput.id = "after_depth__" + key;
depthInput.value = depthVal;
depthInput.style.maxWidth = "110px";
    depthInput.style.width = "110px";

// --- Persist "valeurs réalisées" to state (prevents wipe on rerender after "Déco réalisée") ---
const persistAfterReal = () => {
  const diversStore = ensureAfterDiversStore(groupId);
  if (!diversStore[key]) diversStore[key] = {};
  // runtime (minutes)
  const rtStr = String(rtInput.value ?? "").trim();
  diversStore[key].runtimeMin = (rtStr === "") ? "" : String(parseInt(rtStr, 10));
  // exit time (HH:MM)
  diversStore[key].exitHHMM = String(exitInput.value ?? "").trim();
  // depth (meters)
  const dStr = String(depthInput.value ?? "").trim();
  diversStore[key].depthRealM = (dStr === "") ? "" : String(parseInt(dStr, 10));
  saveGroupDetails();
};

// Persist on edits
rtInput.addEventListener("input", persistAfterReal);
exitInput.addEventListener("input", persistAfterReal);
depthInput.addEventListener("input", persistAfterReal);


// Validation stricte entier (sans casser l’UX)
depthInput.addEventListener("blur", () => {
  const v = String(depthInput.value ?? "").trim();
  if (v === "") return;
  const n = parseInt(v, 10);
  if (isNaN(n) || String(n) !== v || n < 0) {
    depthInput.value = "";
  } else {
    depthInput.value = String(n);
  }
});

const depthUnit = document.createElement("span");
depthUnit.className = "help-text";
depthUnit.style.margin = "0";
depthUnit.textContent = "m";

// --- NUMPAD button (AFTER) ---
if (typeof numpadIsTouchDevice === "function" && numpadIsTouchDevice()) {
  depthInput.addEventListener("focus", ()=>numpadOpenFor(depthInput));
  depthInput.addEventListener("click", ()=>numpadOpenFor(depthInput));
}
const depthField = document.createElement("div");
depthField.className = "numpad-field";
depthField.appendChild(depthInput);
const depthBtn = document.createElement("button");
depthBtn.type = "button";
depthBtn.className = "numpad-open";
depthBtn.textContent = "123";
depthBtn.setAttribute("data-numpad-for", depthInput.id);
depthField.appendChild(depthBtn);

depthWrap.appendChild(depthField);
depthWrap.appendChild(depthUnit);


    top.appendChild(nameEl);
    // --- NUMPAD button (AFTER) ---
    if (typeof numpadIsTouchDevice === "function" && numpadIsTouchDevice()) {
      rtInput.addEventListener("focus", ()=>numpadOpenFor(rtInput));
      rtInput.addEventListener("click", ()=>numpadOpenFor(rtInput));
    }
    const rtField = document.createElement("div");
    rtField.className = "numpad-field";
    rtField.appendChild(rtInput);
    const rtBtn = document.createElement("button");
    rtBtn.type = "button";
    rtBtn.className = "numpad-open";
    rtBtn.textContent = "123";
    rtBtn.setAttribute("data-numpad-for", rtInput.id);
    rtField.appendChild(rtBtn);

    rtWrap.appendChild(rtField);
    rtWrap.appendChild(rtUnit);
    exitWrap.appendChild(exitInput);

    // (v1.001) Incidents par plongeur : bouton discret + mini panel (checkbox multiples)
    const incidentBtn = document.createElement("button");
    incidentBtn.type = "button";
    incidentBtn.className = "incident-btn";
    incidentBtn.textContent = "Incident";
    incidentBtn.style.marginLeft = "6px";

    const incidentPanel = document.createElement("div");
    incidentPanel.className = "incident-panel";

    const incSelected = Array.isArray(afterEntry.incidents) ? afterEntry.incidents.slice() : [];

    const syncIncidentBtn = () => {
      const n = incSelected.length || 0;
      incidentBtn.textContent = n ? ("Incident (" + n + ")") : "Incident";
      incidentBtn.setAttribute("data-n", String(n));
    };

    const persistIncidents = () => {
      if (!after.divers[key]) after.divers[key] = {};
      after.divers[key].incidents = incSelected.slice();
      saveGroupDetails();
      syncIncidentBtn();
    };

    const mkTag = (value, label) => {
      const wrap = document.createElement("label");
      wrap.className = "inc-tag";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = value;
      cb.checked = incSelected.includes(value);
      cb.addEventListener("change", () => {
        const i = incSelected.indexOf(value);
        if (cb.checked) {
          if (i === -1) incSelected.push(value);
        } else {
          if (i !== -1) incSelected.splice(i, 1);
        }
        persistIncidents();
      });
      const txt = document.createElement("span");
      txt.textContent = label;
      wrap.appendChild(cb);
      wrap.appendChild(txt);
      return wrap;
    };

     // Matériel / Gaz + Humain / Procédure — 2 colonnes alignées (4 + 4)
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.className = "inc-close";
    closeBtn.textContent = "×";
    closeBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      incidentPanel.style.display = "none";
    });
    incidentPanel.appendChild(closeBtn);

    const grid = document.createElement("div");
    grid.className = "inc-grid";

    const col1 = document.createElement("div");
    col1.className = "inc-col";
    const t1 = document.createElement("div");
    t1.className = "inc-title";
    t1.textContent = "Matériel / Gaz";
    col1.appendChild(t1);
    col1.appendChild(mkTag("mat_oc_free_flow", "OC free flow: perte gaz"));
    col1.appendChild(mkTag("mat_besoin_gaz", "Besoin gaz"));
    col1.appendChild(mkTag("mat_mauvais_lestage", "Mauvais lestage"));
    col1.appendChild(mkTag("mat_probleme_materiel", "Problème matériel"));

    const col2 = document.createElement("div");
    col2.className = "inc-col";
    const t2 = document.createElement("div");
    t2.className = "inc-title";
    t2.textContent = "Humain / Procédure";
    col2.appendChild(t2);
    col2.appendChild(mkTag("hum_probleme_flotta", "Problème de flottabilité"));
    col2.appendChild(mkTag("hum_palier_nonrespect", "Paliers non respectés"));
    col2.appendChild(mkTag("hum_perte_binome", "Perte de binôme"));
    col2.appendChild(mkTag("hum_incident_decompression", "Incident décompression"));

    grid.appendChild(col1);
    grid.appendChild(col2);
    incidentPanel.appendChild(grid);

    // Remarque (optionnelle) — 1 à 2 lignes max
    const t3 = document.createElement("div");
    t3.className = "inc-title";
    t3.textContent = "Remarque";

    const note = document.createElement("textarea");
    note.className = "inc-note";
    note.rows = 2;
    note.maxLength = 140;
    note.placeholder = "1–2 lignes max…";
    note.value = (after.divers[key] && after.divers[key].incident_note) ? after.divers[key].incident_note : "";
    note.addEventListener("input", () => {
      if (!after.divers[key]) after.divers[key] = {};
      after.divers[key].incident_note = note.value.slice(0, 140);
      saveGroupDetails();
    });

    incidentPanel.appendChild(t3);
    incidentPanel.appendChild(note);
    syncIncidentBtn();

    incidentBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();

      const isOpen = incidentPanel.style.display === "block";
      incidentPanel.style.display = isOpen ? "none" : "block";

      // Close on outside click (does NOT block other buttons)
      if (!isOpen) {
        const onDocClick = (e) => {
          if (!incidentPanel.contains(e.target) && e.target !== incidentBtn) {
            incidentPanel.style.display = "none";
            document.removeEventListener("click", onDocClick);
          }
        };
        document.addEventListener("click", onDocClick);
      }
    });

    // Click inside panel should not close it
    incidentPanel.addEventListener("click", (e) => e.stopPropagation());


    
    // Put Incident button next to the diver name (head row)
    top.appendChild(incidentBtn);

    // Realised fields row (horizontal on iPhone/Android)
    const realRow = document.createElement("div");
    realRow.className = "after-real-row";
    realRow.appendChild(rtWrap);
    realRow.appendChild(exitWrap);
    realRow.appendChild(depthWrap);

    // Incidents panel (toggled by button)
    top.appendChild(incidentPanel);

    // ✅ UX: un seul point d’édition viable des paliers réalisés (modal), pas de saisie par cellule
    const editStopsBtn = document.createElement("button");
    editStopsBtn.type = "button";
    editStopsBtn.className = "btn";
    editStopsBtn.textContent = "✏️ Déco réalisée";
    editStopsBtn.addEventListener("click", function (ev) {
      ev.preventDefault();
      ev.stopPropagation();
      openPalierModal(groupId, diverName, "after");
    });


    // Horizontal stops table
    const tableWrap = document.createElement("div");
    tableWrap.className = "palier-hscroll";
    tableWrap.style.marginTop = "8px";
    // NOTE: do not rely only on overflowX in inline style; the wrapper needs flex-safe constraints.
    // CSS (.palier-hscroll) provides width/max-width/min-width + touch scrolling.
    tableWrap.style.overflowX = "auto";
    tableWrap.style.maxWidth = "100%";
    tableWrap.style.width = "100%";
    tableWrap.style.minWidth = "0";
    tableWrap.style.overflowY = "hidden";
    tableWrap.style.webkitOverflowScrolling = "touch";

    const parseDepth = (v) => {
      if (v == null) return NaN;
      const s = (typeof v === "number") ? String(v) : String(v).replace(",", ".").trim();
      const num = parseFloat(s); // handles "9m", "9 m", "9.0"
      if (isNaN(num)) return NaN;
      // Rule: depths must follow a 3m step (computer-decided stops)
      const d = Math.round(num);
      if (Math.abs(num - d) > 1e-6) return NaN;
      if (d % 3 !== 0) return NaN;
      return d;
    };

    // Depth columns: always show at least 12/9/6/3m (stable layout),
    // and add any planned stops assigned to the diver.
    const baseDepths = [12, 9, 6, 3];
    const depthSet = new Set(baseDepths);

    if (Array.isArray(beforeP)) {
      beforeP.forEach(p => {
        const d = parseDepth(p.depth);
        if (!isNaN(d)) depthSet.add(d);
      });
    }

    // Also include any factual (after) stops that might not exist in RT1
    if (Array.isArray(pDoneStored)) {
      pDoneStored.forEach(p => {
        const d = parseDepth(p.depth);
        if (!isNaN(d)) depthSet.add(d);
      });
    }

    const depths = Array.from(depthSet);
    // affichage du plus profond au plus faible (21, 18, ... 6)
    depths.sort((a,b)=>b-a);

    {
      const plannedMap = {};
      (Array.isArray(beforeP) ? beforeP : []).forEach(p => {
        const d = parseDepth(p.depth);
        if (!isNaN(d)) plannedMap[d] = (p.time != null ? String(p.time) : "");
      });

      const doneMap = {};
      (Array.isArray(pDoneStored) ? pDoneStored : []).forEach(p => {
        const d = parseDepth(p.depth);
        if (!isNaN(d)) doneMap[d] = (p.time != null ? String(p.time) : "");
      });

      const tbl = document.createElement("table");
      tbl.className = "after-stops-table";
      tbl.style.minWidth = String(Math.max(320, depths.length * 70)) + "px";

      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      const th0 = document.createElement("th");
      th0.textContent = "Palier";
      trh.appendChild(th0);
      depths.forEach(d => {
        const th = document.createElement("th");
        th.textContent = d + " m";
        trh.appendChild(th);
      });
      thead.appendChild(trh);

      const tbody = document.createElement("tbody");



      // Row 1: planned from RT1 (before)
      const trPlanned = document.createElement("tr");
      const tdP0 = document.createElement("td");
      tdP0.textContent = "RT1 prévu (min)";
      trPlanned.appendChild(tdP0);
      depths.forEach(d => {
        const td = document.createElement("td");
        const v = (plannedMap[d] != null && String(plannedMap[d]).trim() !== "") ? String(plannedMap[d]).trim() : "";
        td.textContent = v ? (v + " min") : "—";
        trPlanned.appendChild(td);
      });

      if (!isAir) {
        tbody.appendChild(trPlanned);
      }

      // Row 2: factual (after) stops
      const trDone = document.createElement("tr");
      const tdD0 = document.createElement("td");
      tdD0.textContent = "Réel (min)";
      trDone.appendChild(tdD0);
      depths.forEach(d => {
        const td = document.createElement("td");
        const v = (doneMap[d] != null && String(doneMap[d]).trim() !== "") ? String(doneMap[d]).trim() : "";
        td.textContent = v ? (v + " min") : "—";
        trDone.appendChild(td);
      });
      tbody.appendChild(trDone);

      tbl.appendChild(thead);
      tbl.appendChild(tbody);
      tableWrap.appendChild(tbl);
    }

    main.appendChild(top);
    main.appendChild(editStopsBtn);
    main.appendChild(realRow);
    main.appendChild(tableWrap);
    card.appendChild(main);
    container.appendChild(card);
  });
}

function populateAfterForm(groupId) {
  const rec = getGroupRecord(groupId);
  if (!rec) return;

  const after = rec.after || {};
  if (!after.divers || typeof after.divers !== "object") after.divers = {};
  rec.after = after;

  const dateEl       = document.getElementById("group_after_date");
  const exitRealEl   = document.getElementById("group_after_exit_real");
  const incidentsEl  = document.getElementById("group_after_group_incidents");

  if (dateEl)       dateEl.value      = after.date      || "";
  if (exitRealEl)   exitRealEl.value  = after.exitReal  || "";
  if (incidentsEl)  incidentsEl.value = after.groupIncidents || "";

  renderAfterDivers(groupId);
}

function collectAfterFormAndSave() {
  if (!currentGroupId) {
    alert("Aucun groupe sélectionné.");
    return;
  }

  const rec = getGroupRecord(currentGroupId);
  if (!rec) return;

  if (!rec.after) rec.after = {};
  const after = rec.after;
  if (!after.divers || typeof after.divers !== "object") after.divers = {};

  const dateEl       = document.getElementById("group_after_date");
  const exitRealEl   = document.getElementById("group_after_exit_real");
  const incidentsEl  = document.getElementById("group_after_group_incidents");

  after.date = dateEl ? dateEl.value : "";
  after.exitReal = exitRealEl ? exitRealEl.value : "";
  after.groupIncidents = incidentsEl ? incidentsEl.value : "";

  const names = getAfterDiverNames(currentGroupId);
  names.forEach(diverName => {
    const key = normalizeName(diverName);
    const entry = after.divers[key] || {};

    const rtEl = document.getElementById("after_rt__" + key);
    const exEl = document.getElementById("after_exit__" + key);

    const rtRaw = rtEl ? String(rtEl.value).trim() : "";
    const rtMin = rtRaw === "" ? null : parseInt(rtRaw, 10);
    entry.runtimeMin = (!isNaN(rtMin) ? rtMin : null);
    // backward compat (older exports) — keep a string field too
    entry.runtimeReal = (entry.runtimeMin != null ? String(entry.runtimeMin) : "");

    const exRaw = exEl ? String(exEl.value).trim() : "";
    entry.exitHHMM = exRaw || "";
    entry.exitReal = entry.exitHHMM;
    const depthEl = document.getElementById("after_depth__" + key);
    const depthRaw = depthEl ? String(depthEl.value ?? "").trim() : "";
    const depthM = (depthRaw === "") ? null : parseInt(depthRaw, 10);
    entry.depthRealM = (!isNaN(depthM) ? depthM : null);

    // Paliers effectués: colonnes stables (12/9/6/3) + paliers affectés (BEFORE)
    const parseDepth = (v) => {
      if (v == null) return NaN;
      if (typeof v === "number") return v;
      const s = String(v).replace(",", ".").trim();
      return parseFloat(s);
    };

    const planned = loadPaliersGeneric("before", currentGroupId, diverName);
    const baseDepths = [12, 9, 6, 3];
    const depthSet = new Set(baseDepths);

    if (Array.isArray(planned)) {
      planned.forEach(p => {
        const d = parseDepth(p.depth);
        if (!isNaN(d)) depthSet.add(d);
      });
    }

    const depths = Array.from(depthSet).sort((a,b)=>b-a);

    // ✅ UI "Après" n’édite plus les paliers par cellule (non viable).
    // Les paliers réalisés se modifient via le modal (openPalierModal) et sont stockés dans entry.paliersDone.
    // Donc ici: on NE DOIT PAS écraser entry.paliersDone si aucun champ par cellule n’existe.
    let foundAnyStopInput = false;
    const pDone = [];
    depths.forEach(d => {
      const inp = document.getElementById("after_stop__" + key + "__" + d);
      if (!inp) return;
      foundAnyStopInput = true;
      const v = String(inp.value ?? "").trim();
      if (v === "") return;
      const t = parseInt(v, 10);
      if (!isNaN(t)) pDone.push({ depth: d, time: t });
    });
    if (foundAnyStopInput) entry.paliersDone = pDone;

    after.divers[key] = entry;
  });

  rec.after = after;
  saveGroupDetails();

  alert("Données APRÈS plongée sauvegardées pour " + currentGroupId + ".");
}


function collectBeforeFormAndSave() {
  if (!currentGroupId) {
    alert("Aucun groupe sélectionné.");
    return;
  }

  const rec = getGroupRecord(currentGroupId);
  if (!rec) return;

  // ✅ PRESERVE per-diver store (paliers, source, etc.)
  const existingBefore = (rec.before && typeof rec.before === "object") ? rec.before : {};
  const preservedDivers = (existingBefore.divers && typeof existingBefore.divers === "object")
    ? existingBefore.divers
    : undefined;

  const dateEl        = document.getElementById("group_before_date");
  const dtrMaxEl      = document.getElementById("group_before_dtr_max");
  const siteMainEl    = document.getElementById("group_before_site_main");
  const siteGroupEl   = document.getElementById("group_before_site_group");
  const modeEl        = document.getElementById("group_before_mode");
  const depthEl       = document.getElementById("group_before_depth_planned");
  const bottomTimeEl  = document.getElementById("group_before_bottom_time_planned");
  const rtGroupEl     = document.getElementById("group_before_runtime_group_planned");
  const inPlannedEl   = document.getElementById("group_before_in_planned");
  const exitPlannedEl = document.getElementById("group_before_exit_planned");
  const rt1El         = document.getElementById("group_before_rt1");
  const rt2El         = document.getElementById("group_before_rt2");
  const rt3El         = document.getElementById("group_before_rt3");

  // ✅ Update only fields, keep existing structure
  const groupType = siteGroupEl ? String(siteGroupEl.value || "").trim() : String(existingBefore.siteGroup || "").trim();
  const isTrimixCCRType = (groupType === "TRIMIX_CCR");

  // When TRIMIX/CCR: depth/runtime/exit inputs are hidden in UI and may be empty.
  // Do NOT overwrite stored planned values with empty fields.
  const depthPlannedVal =
    (depthEl && depthEl.value !== "") ? Number(depthEl.value)
    : (isTrimixCCRType ? (existingBefore.depthPlanned != null ? existingBefore.depthPlanned : null) : null);

  const bottomTimePlannedVal =
    (bottomTimeEl && bottomTimeEl.value !== "") ? Number(bottomTimeEl.value)
    : (existingBefore.bottomTimePlanned != null ? existingBefore.bottomTimePlanned : null);

  const runtimeGroupPlannedVal =
    (rtGroupEl && rtGroupEl.value !== "") ? Number(rtGroupEl.value)
    : (isTrimixCCRType ? (existingBefore.runtimeGroupPlanned != null ? existingBefore.runtimeGroupPlanned : null) : null);

  const exitPlannedVal =
    (exitPlannedEl && String(exitPlannedEl.value || "").trim() !== "") ? exitPlannedEl.value
    : (isTrimixCCRType ? (existingBefore.exitPlanned || "") : "");

  // ✅ Update only fields, keep existing structure
  const nextBefore = {
    ...existingBefore,
    date:        dateEl        ? dateEl.value        : "",
    dtrMaxMin:   dtrMaxEl      && dtrMaxEl.value     !== "" ? Number(dtrMaxEl.value) : null,
    siteMain:    siteMainEl    ? siteMainEl.value    : "",
    siteGroup:   siteGroupEl   ? siteGroupEl.value   : "",
    mode:        modeEl        ? modeEl.value        : "",
    depthPlanned:       depthPlannedVal,
    bottomTimePlanned:  bottomTimePlannedVal,
    runtimeGroupPlanned:runtimeGroupPlannedVal,
    inPlanned:   inPlannedEl   ? inPlannedEl.value   : "",
    exitPlanned: exitPlannedVal,
    rt1:         rt1El         ? rt1El.value         : "",
    rt2:         rt2El         ? rt2El.value         : "",
    rt3:         rt3El         ? rt3El.value         : ""
  };

  if (preservedDivers) nextBefore.divers = preservedDivers;

  rec.before = nextBefore;
  saveGroupDetails();

  alert("Données AVANT plongée sauvegardées pour " + currentGroupId + ".");
}

function pad2(n){ return String(n).padStart(2,"0"); }

function nowHHMM(){
  const d = new Date();
  return pad2(d.getHours()) + ":" + pad2(d.getMinutes());
}

function addMinutesHHMM(hhmm, addMin){
  const s = String(hhmm || "").trim();
  if (!s) return "";
  const m = s.match(/^(\d{1,2}):(\d{2})(?::\d{2})?$/);
  if (!m) return "";
  const hh = Number(m[1]), mm = Number(m[2]);
  let total = hh*60 + mm + addMin;
  total = ((total % (24*60)) + (24*60)) % (24*60);
  const H = Math.floor(total/60), M = total % 60;
  return String(H).padStart(2,"0") + ":" + String(M).padStart(2,"0");
}

function updateInScenarios(){
  const inEl = document.getElementById("group_before_in_planned");
  if (!inEl) return;

  const base = inEl.value;

  const map = [
    ["btn_in_plus_5", 5],
    ["btn_in_plus_10", 10],
    ["btn_in_plus_15", 15],
    ["btn_in_plus_20", 20],
  ];

  map.forEach(([id, add]) => {
    const b = document.getElementById(id);
    if (!b) return;

    const t = base ? addMinutesHHMM(base, add) : "";
    b.dataset.time = t;          // heure calculée
    b.title = t ? t : "";        // (optionnel) hover desktop
    b.disabled = !base;          // si pas d'heure, on désactive
  });
}

/* ===========================
   STEP 1 CLEAN (align with FICHE DE PLONGÉE but PER GROUP)
   - group_before_in_planned default = system time (only if group's value empty, when opening group)
   - group_before_date default = today dd/mm/yyyy (only if empty, when opening group)
   - exit planned = in planned + runtimeGroupPlanned (minutes)
   =========================== */

function todayDDMMYYYY(){
  const d = new Date();
  return String(d.getDate()).padStart(2,"0") + "/" + String(d.getMonth()+1).padStart(2,"0") + "/" + d.getFullYear();
}
function parseHHMM(val){
  const m = String(val || "").trim().match(/^(\d{1,2}):(\d{2})$/);
  if (!m) return null;
  const hh = parseInt(m[1],10), mm = parseInt(m[2],10);
  if (hh<0||hh>23||mm<0||mm>59) return null;
  return {hh,mm};
}

function normalizeHHMM(val){
  const p = parseHHMM(val);
  if (!p) return "";
  return String(p.hh).padStart(2,"0") + ":" + String(p.mm).padStart(2,"0");
}
function attachHHMMInput(el, onValidChange){
  if (!el) return;
  const handler = () => {
    const norm = normalizeHHMM(el.value);
    if (norm) el.value = norm;
    if (typeof onValidChange === "function") onValidChange();
  };
  el.addEventListener("blur", handler);
  el.addEventListener("change", handler);
}

function updateExitPlannedFromInAndRT(){
  const inEl = document.getElementById("group_before_in_planned");
  const rtEl = document.getElementById("group_before_runtime_group_planned");
  const outEl= document.getElementById("group_before_exit_planned");
  if (!inEl || !rtEl || !outEl) return;
  const r = parseInt(rtEl.value,10);
  if (!inEl.value || isNaN(r)) return;
  const out = addMinutesHHMM(inEl.value, r);
  if (out) outEl.value = out;
  const exitSpan = document.getElementById("before_md_exit");
  if (exitSpan) exitSpan.textContent = out || "—";
}

// ===== NUMPAD UNIVERSAL (AVANT only) =====
let __numpadTarget = null;

function numpadIsTouchDevice(){
  // Android tablets + iPad + touch laptops
  return window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
}

function numpadOpenFor(el){
  const ov = document.getElementById("numpad_overlay");
  if (!ov || !el) return;
  __numpadTarget = el;
  ov.style.display = "flex";
}

function numpadClose(){
  const ov = document.getElementById("numpad_overlay");
  if (!ov) return;
  ov.style.display = "none";
  __numpadTarget = null;
}

function numpadEmitInput(){
  if (!__numpadTarget) return;
  __numpadTarget.dispatchEvent(new Event("input", { bubbles:true }));
  __numpadTarget.dispatchEvent(new Event("change", { bubbles:true }));
}

function numpadAppendDigit(d){
  if (!__numpadTarget) return;
  __numpadTarget.value = String(__numpadTarget.value || "") + String(d);
  numpadEmitInput();
}

function numpadBackspace(){
  if (!__numpadTarget) return;
  const v = String(__numpadTarget.value || "");
  __numpadTarget.value = v.slice(0, -1);
  numpadEmitInput();
}

function numpadClear(){
  if (!__numpadTarget) return;
  __numpadTarget.value = "";
  numpadEmitInput();
}

function initNumpadUI(){
  const grid = document.getElementById("numpad_grid");
  if (!grid) return;

  // buttons 1..9, 0
  grid.innerHTML = "";
  ["1","2","3","4","5","6","7","8","9","0"].forEach(d=>{
    const b = document.createElement("button");
    b.type = "button";
    b.className = "numpad-btn";
    b.textContent = d;
    b.addEventListener("click", ()=>numpadAppendDigit(d));
    grid.appendChild(b);
  });

  const ov = document.getElementById("numpad_overlay");
  document.getElementById("numpad_back")?.addEventListener("click", numpadBackspace);
  document.getElementById("numpad_clear")?.addEventListener("click", numpadClear);
  document.getElementById("numpad_ok")?.addEventListener("click", numpadClose);

  // click outside to close
  ov?.addEventListener("click", (e)=>{ if (e.target === ov) numpadClose(); });

  // ESC closes (desktop)
  document.addEventListener("keydown", (e)=>{ if (e.key === "Escape") numpadClose(); });

  // delegation: dynamic 123 buttons (AFTER cards are rendered dynamically)
  document.addEventListener("click", (e)=>{
    const btn = e.target && e.target.closest ? e.target.closest(".numpad-open[data-numpad-for]") : null;
    if (!btn) return;
    const id = btn.getAttribute("data-numpad-for");
    const el = id ? document.getElementById(id) : null;
    if (el) numpadOpenFor(el);
  });
}

function attachNumpadToBeforeOnly(){
  const beforeIds = [
    "group_before_dtr_max",
    "group_before_depth_planned",
    "group_before_runtime_group_planned"
  ];

  // Auto-open on touch devices when focusing these fields
  if (numpadIsTouchDevice()){
    beforeIds.forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener("focus", ()=>numpadOpenFor(el));
      el.addEventListener("click", ()=>numpadOpenFor(el));
    });
  }

  // Always enable "123" buttons
  document.querySelectorAll(".numpad-open[data-numpad-for]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-numpad-for");
      const el = document.getElementById(id);
      if (el) numpadOpenFor(el);
    });
  });
}



// ===============================
// SITE LIBRARY & GPS (localStorage)
// ===============================
function loadSiteLibrary() {
  try {
    const raw = localStorage.getItem(SITE_LIBRARY_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  } catch (e) {
    console.warn("loadSiteLibrary error", e);
    return [];
  }
}

function saveSiteLibrary(arr) {
  try {
    localStorage.setItem(SITE_LIBRARY_KEY, JSON.stringify(Array.isArray(arr) ? arr : []));
  } catch (e) {
    console.warn("saveSiteLibrary error", e);
  }
}

function normalizeSiteName(name) {
  return (name || "").trim();
}

function renderSiteSelect(selectedName) {
  const sel = document.getElementById("dive_site_select");
  if (!sel) return;

  const lib = loadSiteLibrary()
    .filter(s => s && typeof s.name === "string" && s.name.trim().length > 0);

  // Sort by name (locale-aware)
  lib.sort((a, b) => a.name.localeCompare(b.name, "fr", { sensitivity: "base" }));

  const keep = typeof selectedName === "string" ? selectedName : sel.value;

  sel.innerHTML = '<option value="">— Choisir un site —</option>';
  lib.forEach(site => {
    const opt = document.createElement("option");
    opt.value = site.name;
    opt.textContent = site.name;
    sel.appendChild(opt);
  });

  if (keep) sel.value = keep;
}

function applySelectedSiteToFields(siteName) {
  const nameEl = document.getElementById("dive_site_name");
  const latEl  = document.getElementById("dive_gps_lat");
  const lonEl  = document.getElementById("dive_gps_lon");
  const accEl  = document.getElementById("dive_gps_acc");

  const lib = loadSiteLibrary();
  const site = lib.find(s => s && s.name === siteName);

  if (nameEl) nameEl.value = site ? (site.name || "") : "";
  if (latEl)  latEl.value  = site && (site.lat !== undefined && site.lat !== null) ? String(site.lat) : "";
  if (lonEl)  lonEl.value  = site && (site.lon !== undefined && site.lon !== null) ? String(site.lon) : "";
  if (accEl)  accEl.value  = site && (site.acc !== undefined && site.acc !== null) ? String(site.acc) : "";

  updateGpsNavDisplay();

  // Persist through the existing saveFiche() behavior (inputs trigger saving elsewhere)
  if (typeof saveFiche === "function") saveFiche();
}

function upsertCurrentSite() {
  const sel    = document.getElementById("dive_site_select");
  const nameEl = document.getElementById("dive_site_name");
  const latEl  = document.getElementById("dive_gps_lat");
  const lonEl  = document.getElementById("dive_gps_lon");
  const accEl  = document.getElementById("dive_gps_acc");

  const name = normalizeSiteName(nameEl ? nameEl.value : (sel ? sel.value : ""));
  if (!name) return { ok: false, msg: "Nom du site requis." };

  const lat = latEl && latEl.value !== "" ? Number(latEl.value) : null;
  const lon = lonEl && lonEl.value !== "" ? Number(lonEl.value) : null;
  const acc = accEl && accEl.value !== "" ? Number(accEl.value) : null;

  const lib = loadSiteLibrary();
  const idx = lib.findIndex(s => s && s.name === name);

  const rec = { name, lat, lon, acc, updatedAt: Date.now() };
  if (idx >= 0) lib[idx] = rec;
  else lib.push(rec);

  saveSiteLibrary(lib);
  renderSiteSelect(name);
  if (sel) sel.value = name;
  applySelectedSiteToFields(name);

  return { ok: true, msg: "Site enregistré." };
}

function deleteSelectedSite() {
  const sel = document.getElementById("dive_site_select");
  if (!sel || !sel.value) return { ok: false, msg: "Aucun site sélectionné." };

  const name = sel.value;
  const lib = loadSiteLibrary();
  const next = lib.filter(s => !(s && s.name === name));
  saveSiteLibrary(next);

  // Clear selection + fields
  sel.value = "";
  renderSiteSelect("");
  applySelectedSiteToFields("");

  return { ok: true, msg: "Site supprimé." };
}

function captureGPSIntoFields() {
  const statusEl = document.getElementById("site_gps_status");
  const latEl  = document.getElementById("dive_gps_lat");
  const lonEl  = document.getElementById("dive_gps_lon");
  const accEl  = document.getElementById("dive_gps_acc");

  if (!navigator.geolocation) {
    if (statusEl) statusEl.textContent = "GPS indisponible.";
    return;
  }
  if (statusEl) statusEl.textContent = "Capture GPS…";

  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const { latitude, longitude, accuracy } = pos.coords || {};
      if (latEl) latEl.value = latitude != null ? latitude.toFixed(6) : "";
      if (lonEl) lonEl.value = longitude != null ? longitude.toFixed(6) : "";
      if (accEl) accEl.value = accuracy != null ? Math.round(accuracy) : "";
      updateGpsNavDisplay();
      if (statusEl) statusEl.textContent = "GPS OK.";
      if (typeof saveFiche === "function") saveFiche();
    },
    (err) => {
      if (statusEl) statusEl.textContent = "Erreur GPS.";
      console.warn("GPS error", err);
    },
    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
  );
}




// Backward-compat wrappers (keep DOMContentLoaded wiring stable)
function setSiteGpsStatus(msg) {
  const el = document.getElementById("site_gps_status");
  if (el) el.textContent = msg || "";
}

function formatNavDegMin(value, isLat) {
  const v = Number(value);
  if (!isFinite(v)) return "";
  const hemi = isLat ? (v >= 0 ? "N" : "S") : (v >= 0 ? "E" : "W");
  const av = Math.abs(v);
  const deg = Math.floor(av);
  const minutes = (av - deg) * 60;
  // Navionics-style: degrees + minutes (decimal)
  const minStr = minutes.toFixed(3).padStart(6, "0"); // e.g. 02.186
  const degStr = String(deg).padStart(isLat ? 2 : 3, "0");
  return `${hemi} ${degStr}°${minStr}’`;
}

function updateGpsNavDisplay() {
  const out = document.getElementById("dive_gps_nav");
  const latEl = document.getElementById("dive_gps_lat");
  const lonEl = document.getElementById("dive_gps_lon");
  if (!out) return;

  const lat = latEl ? latEl.value.trim() : "";
  const lon = lonEl ? lonEl.value.trim() : "";
  const a = formatNavDegMin(lat, true);
  const b = formatNavDegMin(lon, false);

  out.textContent = (a && b) ? `${a}   ${b}` : "—";
}
function applySiteById(siteName) { applySelectedSiteToFields(siteName); }
function captureGPS() { captureGPSIntoFields(); }
function upsertSiteFromFields() {
  const r = upsertCurrentSite();
  return r;
}
document.addEventListener("DOMContentLoaded", function () {
  window.__doInit = function(){
    try { ensurePersistentStorageDlog(); } catch(_) {}
    loadFiche();
    updateGpsNavDisplay();
    loadDiverLibrary();
    instructorLibrary = loadInstructorLibrary();
    // Non-destructive seed: only if instructor library is empty/missing (first run / after purge)
    try {
      if ((!Array.isArray(instructorLibrary) || instructorLibrary.length === 0) &&
          typeof seedInstructorLibraryIfEmpty === "function") {
        const seeded = seedInstructorLibraryIfEmpty();
        if (seeded) instructorLibrary = loadInstructorLibrary();
      }
    } catch(e) {}
    // Non-destructive sync: if instructor library is still empty on this origin, enrich from diverLibrary/BASE_DIVERS
    try {
      if ((!Array.isArray(instructorLibrary) || instructorLibrary.length === 0) &&
          typeof syncInstructorsFromDiverLibrary === "function") {
        const nAdded = syncInstructorsFromDiverLibrary({ onlyIfEmpty: true });
        if (nAdded > 0) instructorLibrary = loadInstructorLibrary();
      }
    } catch(e) {}
    try { refreshContextInstructorDatalists(); } catch(e) {}loadCertLibrary();

    // Live validation: DP (Contexte du jour)
    const dpEl = document.getElementById("dive_const_dp");
    if (dpEl) {
      // DP must exist in instructor library (for Encadrement PDF fields)
      ensureInstructorByName(dpEl.value);
      try { refreshContextInstructorDatalists(); } catch(e) {}
      try { renderGroupAssignments(); } catch(e) {}

      // Quick access to instructor library (DP)
      const dpAddBtn = document.getElementById("btn_dp_add");
      if (dpAddBtn) {
        dpAddBtn.addEventListener("click", function(){
          openSimpleNamePickerOverlay({
            title: "DP — choisir / ajouter",
            initialValue: String(dpEl.value || "").trim(),
            placeholder: "Tape le prénom/nom (autocomplete)",
            onConfirm: function(nm){
              ensureInstructorByName(nm);
              dpEl.value = nm;
              saveFiche();
              try { renderGroupAssignments(); } catch(e) {}
              renderValidationBanner();
              try { refreshContextInstructorDatalists(); } catch(e) {}
            }
          });
        });
      }


      // Quick sync: enrich instructor library from diver library (non-destructive)
      const syncBtn = document.getElementById("btn_instructor_sync");
      if (syncBtn) {
        syncBtn.addEventListener("click", function(){
          const n = (typeof syncInstructorsFromDiverLibrary === "function") ? syncInstructorsFromDiverLibrary({ onlyIfEmpty: false }) : 0;
          instructorLibrary = loadInstructorLibrary();
          try { refreshContextInstructorDatalists(); } catch(e) {}
          // Small feedback
          try {
            openToast && openToast((n>0? (n + " instructeur(s) ajouté(s).") : "Aucun nouvel instructeur détecté."));
          } catch(e) {}
        });
      }

      dpEl.addEventListener("input", function(){ renderValidationBanner(); });
      dpEl.addEventListener("change", function(){
        ensureInstructorByName(dpEl.value);
        saveFiche();
        try { renderGroupAssignments(); } catch(e) {}
        renderValidationBanner();
      });
    }



    // Live UI sync: date + DTR (Avant plongée header)
    const beforeDateEl = document.getElementById("group_before_date");
    if (beforeDateEl) {
      const syncTitle = function(){
        const titleDate = document.getElementById("before_date_title");
        if (titleDate) titleDate.textContent = (beforeDateEl.value && String(beforeDateEl.value).trim()) ? String(beforeDateEl.value).trim() : "—";
      };
      beforeDateEl.addEventListener("input", syncTitle);
      beforeDateEl.addEventListener("change", syncTitle);
      syncTitle();
    }

    const beforeDtrEl = document.getElementById("group_before_dtr_max");
    if (beforeDtrEl) {
      const syncDtr = function(){
        const dtrSpan = document.getElementById("before_md_dtr");
        const v = String(beforeDtrEl.value || "").trim();
        if (dtrSpan) dtrSpan.textContent = v ? (v + " min") : "—";
      };
      beforeDtrEl.addEventListener("input", syncDtr);
      beforeDtrEl.addEventListener("change", syncDtr);
      syncDtr();
    }

    // --- Site library & GPS ---
    renderSiteSelect();
    const siteSel = document.getElementById("dive_site_select");
    const gpsBtn  = document.getElementById("btn_gps_capture");
    const saveBtn = document.getElementById("btn_site_save");
    const delBtn  = document.getElementById("btn_site_delete");

    if (siteSel) {
      siteSel.addEventListener("change", function(){
        if (siteSel.value) applySiteById(siteSel.value);
        saveFiche();
      });
    }

    ["dive_site_name","dive_gps_lat","dive_gps_lon","dive_gps_acc"].forEach(id=>{
      const el = document.getElementById(id);
      if (el) el.addEventListener("change", function(){
        if (id === "dive_gps_lat" || id === "dive_gps_lon") updateGpsNavDisplay();
        saveFiche();
      });
      if (el && (id === "dive_gps_lat" || id === "dive_gps_lon")) {
        el.addEventListener("input", function(){ updateGpsNavDisplay(); });
      }
    });

    if (gpsBtn) gpsBtn.addEventListener("click", function(){ captureGPS(); });
    if (saveBtn) saveBtn.addEventListener("click", function(){
      const r = upsertSiteFromFields();
      setSiteGpsStatus(r.msg);
      saveFiche();
    });
    if (delBtn) delBtn.addEventListener("click", function(){
      const r = deleteSelectedSite();
      setSiteGpsStatus(r.msg);
      saveFiche();
    });



    // --- Diver library: Add diver UI (aligned with FICHE_PLONGÉE) ---
    populateAddDiverCertSelect();
    toggleAddDiverManualFields();

    const addBtn = document.getElementById("btn_add_diver");
    const formEl = document.getElementById("add-diver-form");
    const cancelBtn = document.getElementById("btn_add_diver_cancel");
    const confirmBtn = document.getElementById("btn_add_diver_confirm");
    const certSel = document.getElementById("add_diver_cert_select");
    const aptSel = document.getElementById("add_diver_aptitude_select");

    if (addBtn && formEl) {
      addBtn.addEventListener("click", function () {
        formEl.style.display = (formEl.style.display === "none" || !formEl.style.display) ? "block" : "none";
        setAddDiverStatus("");
      });
    }

    if (cancelBtn && formEl) {
      cancelBtn.addEventListener("click", function () {
        formEl.style.display = "none";
        setAddDiverStatus("");
      });
    }

    if (confirmBtn) {
      confirmBtn.addEventListener("click", function () {
        addDiverToLibraryFromForm();
      });
    }

    if (certSel) {
      certSel.addEventListener("change", function () {
        toggleAddDiverManualFields();
      });
    }
    if (aptSel) {
      aptSel.addEventListener("change", function () {
        toggleAddDiverManualFields();
      });
    }

    // --- Edit diver UI wiring ---
    const editBtn = document.getElementById("btn_edit_diver");
    const editFormEl = document.getElementById("edit-diver-form");
    const editCancelBtn = document.getElementById("btn_edit_diver_cancel");
    const editConfirmBtn = document.getElementById("btn_edit_diver_confirm");
    const editSearchEl = document.getElementById("edit_diver_search");
    const editCertSel = document.getElementById("edit_diver_cert_select");
    const editAptSel  = document.getElementById("edit_diver_aptitude_select");

    populateEditDiverCertSelect();
    toggleEditDiverManualFields();

    if (editBtn && editFormEl) {
      editBtn.addEventListener("click", function () {
        editFormEl.style.display = (editFormEl.style.display == "none" || !editFormEl.style.display) ? "block" : "none";
        setEditDiverStatus("");
        if (editFormEl.style.display === "block") {
          refreshEditDiverResults(editSearchEl ? editSearchEl.value : "");
          refreshEditDiverDatalist(editSearchEl ? editSearchEl.value : "");
        }
      });
    }

    if (editCancelBtn && editFormEl) {
      editCancelBtn.addEventListener("click", function () {
        editFormEl.style.display = "none";
        setEditDiverStatus("");
      });
    }

    if (editSearchEl) {
      editSearchEl.addEventListener("input", function () {
        // typing changes selection; avoid saving to a stale diver id
        editDiverSelectedId = null;
        setEditDiverStatus("");
        refreshEditDiverDatalist(editSearchEl.value);
      });
    }

    if (editSearchEl) {
      // When user picks an item from the autocomplete list, select & load the diver automatically
      const _tryPick = function () {
        const d = resolveEditDiverAutocompleteValue(editSearchEl.value);
        if (!d) return;
        fillEditFormFromDiver(d);
      };
      editSearchEl.addEventListener("change", _tryPick);
      editSearchEl.addEventListener("blur", _tryPick);
    }

    if (editCertSel) editCertSel.addEventListener("change", toggleEditDiverManualFields);
    if (editAptSel)  editAptSel.addEventListener("change", toggleEditDiverManualFields);

    if (editConfirmBtn) {
      editConfirmBtn.addEventListener("click", function () {
        editDiverInLibraryFromForm();
      });
    }

    loadDiversDuJour();
    loadGroupAssignments();
    loadGroupLeaders();
    loadGroupDetails();
    groupPractice = loadGroupPractice();
    groupSupervisors = loadGroupSupervisors();
    instructorLibrary = loadInstructorLibrary();
    try { refreshContextInstructorDatalists(); } catch(e) {}

    syncGroupsWithDiversDuJour();

    // Auto-fill heure mise à l’eau à l’ouverture (si vide), puis scénarios +5/+10/+15/+20

    const inEl = document.getElementById("group_before_in_planned");
    if (inEl) {
      if (!inEl.value) inEl.value = nowHHMM();
      updateInScenarios();
      const recalcBeforeTimes = () => { updateInScenarios(); updateExitPlannedFromInAndRT(); };
      inEl.addEventListener("input", recalcBeforeTimes);
      attachHHMMInput(inEl, recalcBeforeTimes);
    }

   // --- AUTO: recalcul sortie estimée quand le runtime change ---
   const rtEl = document.getElementById("group_before_runtime_group_planned");
   if (rtEl) {
     rtEl.addEventListener("input", updateExitPlannedFromInAndRT);
     rtEl.addEventListener("change", updateExitPlannedFromInAndRT);
   }

    ["btn_in_plus_5","btn_in_plus_10","btn_in_plus_15","btn_in_plus_20"].forEach(id=>{
      const b = document.getElementById(id);
      const inEl = document.getElementById("group_before_in_planned");
      if (!b || !inEl) return;

      b.addEventListener("click", () => {
        const t = b.dataset.time || "";
        if (t) {
          inEl.value = t;            // applique le scénario
          updateInScenarios();       // recalcule pour cohérence
          updateExitPlannedFromInAndRT();  // ✅ recalcul sortie estimée
          saveFiche();               // optionnel (si tu veux sauver direct)
        }
      });
    });

    document.querySelectorAll("input, textarea, select").forEach(el => {
      if (!el.id) return;
      const ev =
        el.type === "checkbox" || el.type === "radio" ? "change" : "input";
      el.addEventListener(ev, function () {
        // Prevent loops: group time/rt/out are handled per-group (groupDetails), not via global autosave
        if (el.id === "group_before_in_planned" ||
            el.id === "group_before_runtime_group_planned" ||
            el.id === "group_before_exit_planned") return;
        saveFiche();
      });
    });

    const resetBtn = document.getElementById("btn-reset");
    if (resetBtn) {
      resetBtn.addEventListener("click", function () {
        if (confirm("Effacer tous les champs de la fiche ?")) {
          clearFiche();
        }
      });
    }

    const exportBtn = document.getElementById("btn-export");
    if (exportBtn) {
      exportBtn.addEventListener("click", function () {
        exportWhatsApp();
      });
    }

    renderPlongeursDuJourSelector();
    const btnPJ = document.getElementById("btn_valider_plongeurs_jour");
    if (btnPJ) {
      btnPJ.addEventListener("click", handleValidationPlongeursDuJour);
    }

    renderGroupAssignments();
    setupGroupDropZones();
    renderGroupAssignments();
    setupGroupDropZones();

    const addGroupBtn = document.getElementById("btn_add_group");
    if (addGroupBtn) {
      addGroupBtn.addEventListener("click", function () {
        addNewGroup();
      });
    }
    initGroupModeUI();
    updateGroupHeadersWithLeaders();
    // G4: Export QR par bateau (wiring UI)
    try { ensureGaExportQrWiring(); } catch(e) {}
   const previewBtn = document.getElementById("btn-preview-pdf");
   if (previewBtn) {
     previewBtn.addEventListener("click", function(){
        const v = validateGroupsAndRoles();
        if (v && Array.isArray(v.errors) && v.errors.length) {
          alert("Erreur: corrigez les points rouges (Groupes) avant export.");
          renderValidationBanner();
          return;
        }
        buildPdfMock();
      });
   }

   const exportPdfBtn = document.getElementById("btn-export-pdf");
   if (exportPdfBtn) {
     exportPdfBtn.addEventListener("click", function(){
        const v = validateGroupsAndRoles();
        if (v && Array.isArray(v.errors) && v.errors.length) {
          alert("Erreur: corrigez les points rouges (Groupes) avant export.");
          renderValidationBanner();
          return;
        }
        exportPdf();
      });
   }



    // === Navigation AVANT / APRÈS ===
    attachGroupButtonsHandlers();

    const beforeBackBtn = document.getElementById("btn_before_back");
    if (beforeBackBtn) {
      beforeBackBtn.addEventListener("click", function () {
        // On sauvegarde AVANT plongée pour le groupe courant
        if (typeof collectBeforeFormAndSave === "function") {
         collectBeforeFormAndSave();
        }
       // Puis on revient à l’écran principal
        showMainLayout(currentGroupId);
      });
    }

    const afterBackBtn = document.getElementById("btn_after_back");
    if (afterBackBtn) {
      afterBackBtn.addEventListener("click", function () {
        if (typeof collectAfterFormAndSave === "function") {
         collectAfterFormAndSave();
        }
        showMainLayout(currentGroupId);
      });
    } 


    // --- Avant plongée: AIR vs TRIMIX/CCR ---
    const typeSel = document.getElementById("group_before_site_group");
    if (typeSel) {
      typeSel.addEventListener("change", updateBeforeLayoutByType);
    }

    const rt1Area = document.getElementById("group_before_rt1");
    const rt2Area = document.getElementById("group_before_rt2");
    const rt3Area = document.getElementById("group_before_rt3");
    [rt1Area, rt2Area, rt3Area].forEach((el) => {
      if (!el) return;
      el.addEventListener("input", updateBeforeAnalyseButtonState);
    });

    const analyseBtn = document.getElementById("btn_analyser_rt1");
    if (analyseBtn) {
      analyseBtn.addEventListener("click", function () {
        // Step 3.3: always save raw RT1/RT2/RT3
        saveBeforeMultiDecoRaw();

        // Step 3.4.2: parse RT1 and display planned depth/runtime
        const rt1El = document.getElementById("group_before_rt1");
        const rt1Txt = rt1El ? String(rt1El.value || "") : "";
        const parsed = parseRT1(rt1Txt);

        const depthSpan = document.getElementById("before_md_depth");
        const rtSpan = document.getElementById("before_md_runtime");
        if (depthSpan) {
          depthSpan.textContent = (parsed.plannedDepthM != null) ? (parsed.plannedDepthM + " m") : "—";
        }
        if (rtSpan) {
          rtSpan.textContent = (parsed.plannedRuntimeMin != null) ? (parsed.plannedRuntimeMin + " min") : "—";
        }

        const dtrSpan2 = document.getElementById("before_md_dtr");
        const dtrEl2 = document.getElementById("group_before_dtr_max");
        if (dtrSpan2) {
          const v = dtrEl2 ? String(dtrEl2.value || "").trim() : "";
          dtrSpan2.textContent = v ? (v + " min") : "—";
        }
        const exitSpan2 = document.getElementById("before_md_exit");
        const exitEl2 = document.getElementById("group_before_exit_planned");
        if (exitSpan2) {
          const v = exitEl2 ? String(exitEl2.value || "").trim() : "";
          exitSpan2.textContent = v || "—";
        }

        // Persist extracted planned fields (plan only; still NO palier application here)
        if (currentGroupId) {
          const rec = getGroupRecord(currentGroupId);
          if (rec) {
            if (!rec.before) rec.before = {};
            rec.before.depthPlanned = (parsed.plannedDepthM != null) ? parsed.plannedDepthM : rec.before.depthPlanned;

            // Sync hidden input used by "Enregistrer AVANT" + PDF
            if (parsed.plannedDepthM != null) {
              const _depthEl = document.getElementById("group_before_depth_planned");
              if (_depthEl) _depthEl.value = String(parsed.plannedDepthM);
            }

// IMPORTANT: PDF Page 1 expects runtimeGroupPlanned (not runtimePlanned)
if (parsed.plannedRuntimeMin != null) {
  rec.before.runtimeGroupPlanned = parsed.plannedRuntimeMin;

  // Sync hidden input used by "Enregistrer AVANT" + PDF
  const _rtGroupEl = document.getElementById("group_before_runtime_group_planned");
  if (_rtGroupEl) _rtGroupEl.value = String(parsed.plannedRuntimeMin);

  // backward compat (some UI code may still read runtimePlanned)
  rec.before.runtimePlanned = parsed.plannedRuntimeMin;

  // If we have an in-water planned time, derive exitPlanned from it
  if (rec.before.inPlanned) {
    const computedExit = addMinutesHHMM(rec.before.inPlanned, parsed.plannedRuntimeMin);
    if (computedExit) {
      rec.before.exitPlanned = computedExit;

      // Keep hidden form fields in sync (TRIMIX/CCR hides these inputs, but we still need them for SAVE + PDF)
      const _exitEl = document.getElementById("group_before_exit_planned");
      if (_exitEl) _exitEl.value = computedExit;
    }
  }
}
            saveGroupDetails();
          }
        }


        // Step 3.4.3: apply RT1 stops as PLANNED paliers to eligible divers (Trimix/CCR only)
        // Rule: do not overwrite existing planned paliers if already set manually.
        if (currentGroupId && parsed && Array.isArray(parsed.stops) && parsed.stops.length) {
          const names = getAfterDiverNames(currentGroupId);
          names.forEach(diverName => {
            if (!diverNeedsRT1(diverName)) return;
      
            const paliersFromRT1 = parsed.stops.map(s => ({ depth: s.depthM, time: s.minutes }));
            savePaliersGeneric("before", currentGroupId, diverName, paliersFromRT1);
          });
        }

        const st = document.getElementById("before_md_status");
        if (st) {
          if (parsed.plannedDepthM != null || parsed.plannedRuntimeMin != null || (parsed.stops && parsed.stops.length)) {
            st.textContent = "RT enregistrés (brut) ✓  |  RT1 analysé ✓";
          } else {
            st.textContent = "RT enregistrés (brut) ✓  |  RT1 non reconnu";
          }
        }

        updateBeforeAnalyseButtonState();
      });
    }

    // Ensure correct initial visibility
    updateBeforeLayoutByType(); 

    // --- NUMPAD (AVANT) init ---
    try { initNumpadUI(); attachNumpadToBeforeOnly(); } catch(e) { console.warn('numpad init', e); }

    // --- SPLASH logo 200ms (au chargement) ---
    try { showAppSplash200ms(); } catch(e) { console.warn('splash', e); }

  }; // end __doInit

  });

// --- G3: Bulk boat assignment bindings (Groupes & affectation)
(function initBulkBoatAssign(){
  const sel = document.getElementById("ga_bulk_boat");
  if (!sel) return;
  // populate options
  const n = (typeof getCenterBoatsN === "function") ? getCenterBoatsN() : 1;
  sel.innerHTML = '<option value="">—</option>';
  for (let i = 1; i <= n; i++) {
    const o = document.createElement("option");
    o.value = "B" + i;
    o.textContent = "B" + i;
    sel.appendChild(o);
  }

  const btnApply = document.getElementById("btn_ga_apply_boat");
  const btnClear = document.getElementById("btn_ga_clear_boat");

  if (btnApply) btnApply.onclick = (ev) => {
    ev.stopPropagation();
    applyUnitToAllPDJ(sel.value || "");
    if (typeof renderGroupAssignments === "function") renderGroupAssignments();
  };

  if (btnClear) btnClear.onclick = (ev) => {
    ev.stopPropagation();
    clearUnitsForAllPDJ();
    if (typeof renderGroupAssignments === "function") renderGroupAssignments();
  };
})();

</script>


<script>
/**
 * parseRT1(multiDecoText)
 * Pure function. No side-effects.
 * Returns:
 *  - plannedDepthM (Number|null)
 *  - plannedRuntimeMin (Number|null)
 *  - stops: Array<{ depthM:Number, minutes:Number }>
 *
 * Rules:
 *  - Depths: multiples of 3 only
 *  - Keep 3m if present; do not invent stops
 *  - Durations: math rounding with 30s threshold
 *      minutes = Math.round(seconds / 60)
 */
function parseRT1(multiDecoText) {
  if (!multiDecoText || typeof multiDecoText !== "string") {
    return { plannedDepthM: null, plannedRuntimeMin: null, stops: [] };
  }

console.log("[RT1] raw text ↓↓↓");
console.log(multiDecoText);
  
const lines = multiDecoText.split(/\r?\n/);

  let plannedDepthM = null;
  let plannedRuntimeMin = null;

  const stopsMap = new Map(); // depth -> minutes

  // ===== helpers =====
  function parseSeconds(token) {
    if (!token) return null;
    token = token.trim();

    // mm:ss
    if (/^\d+:\d{1,2}$/.test(token)) {
      const [m, s] = token.split(":").map(Number);
      return m * 60 + s;
    }

    // minutes only
    if (/^\d+$/.test(token)) {
      return Number(token) * 60;
    }

    return null;
  }

  function toMinutes(sec) {
    return Math.round(sec / 60); // règle 30s
  }

  // ===== PASS 1 : profondeur planifiée via Des / Lvl =====
  for (const raw of lines) {
    const line = raw.trim();
    if (!line) continue;

    const m = line.match(/\b(Des|Lvl|LvL|Level|Bottom)\b.*?(\d{1,3})\b/i);
    if (m) {
      const d = Number(m[2]);
      if (!isNaN(d)) {
        if (plannedDepthM === null || d > plannedDepthM) {
          plannedDepthM = d;
        }
      }
    }
  }

  // ===== PASS 2 : runtime planifié (MultiDeco) =====
  // Rule (table export): runtime is in the "Run" column on the LAST profile line (typically Sfc / Asc / Lvl / Des),
  // which appears AFTER the last stop. Do NOT pick gas summary lines like "Gas 80 = 1633 ltr."
  // Priority:
  //   1) If the last profile line contains a mm:ss token, use it (e.g., "Asc 0 74:20").
  //   2) Else, for Sfc: runtime = first numeric token; for Des/Lvl/Asc: runtime = second numeric token (after depth).
  for (let i = lines.length - 1; i >= 0; i--) {
    const line = lines[i].trim();
    if (!line) continue;

    // Skip stop lines
    if (/\b(?:Stop|Stp|Palier)\b/i.test(line)) continue;

    // Consider only profile lines (avoid "Gas ... ltr." summary lines)
    if (!/^(?:Des|Lvl|Asc|Sfc)\b/i.test(line)) continue;

    // 1) mm:ss runtime token on the line (take the last one)
    const mmss = line.match(/(\d+:\d{1,2})/g);
    if (mmss && mmss.length) {
      const sec = parseSeconds(mmss[mmss.length - 1]);
      if (sec !== null) {
        plannedRuntimeMin = toMinutes(sec);
        break;
      }
    }

    // 2) Numeric runtime from columns (minutes)
    const nums = (line.match(/\d+(?:\.\d+)?/g) || []).map(Number).filter((n) => !isNaN(n));
    if (!nums.length) continue;

    if (/^Sfc\b/i.test(line)) {
      plannedRuntimeMin = Math.round(nums[0]);
      break;
    } else if (nums.length >= 2) {
      plannedRuntimeMin = Math.round(nums[1]);
      break;
    }
  }

  // Fallback: keyword-based runtime line (FR/EN)

  if (plannedRuntimeMin === null) {
    for (const raw of lines) {
      const line = raw.trim();
      if (!line) continue;

      const m = line.match(
        /\b(run\s*time|runtime|runt|rt|temps\s*total|dur[eé]e\s*totale)\b.*?(\d+:\d{1,2}|\d+)/i
      );
      if (m) {
        const sec = parseSeconds(m[2]);
        if (sec !== null) {
          plannedRuntimeMin = toMinutes(sec);
          break;
        }
      }
    }
  }


  // ===== PASS 3 : fallback runtime = max time found ===== : fallback runtime = max time found =====
  if (plannedRuntimeMin === null) {
    let maxMin = null;

    for (const raw of lines) {
      const line = raw.trim();
      if (!line) continue;

      const m = line.match(/(\d+:\d{1,2}|\d+)\s*(?:min|mn)?/i);
      if (!m) continue;

      const sec = parseSeconds(m[1]);
      if (sec === null) continue;

      const min = toMinutes(sec);
      if (maxMin === null || min > maxMin) {
        maxMin = min;
      }
    }

    plannedRuntimeMin = maxMin;
  }

  // ===== PASS 4 : paliers (Stop / Stp / Palier) =====
  for (const raw of lines) {
    const line = raw.trim();
    if (!line) continue;

    const m = line.match(
      /\b(?:Stop|Stp|Palier)\b.*?(\d{1,3})\s*m?.*?(\d+:\d{1,2}|\d+)/i
    );

    if (!m) continue;

    const depth = Number(m[1]);
    if (isNaN(depth) || depth % 3 !== 0) continue;

    const sec = parseSeconds(m[2]);
    if (sec === null) continue;

    const min = toMinutes(sec);

    const prev = stopsMap.get(depth);
    if (prev === undefined || min > prev) {
      stopsMap.set(depth, min);
    }
  }

  const stops = Array.from(stopsMap.entries())
    .map(([depthM, minutes]) => ({ depthM, minutes }))
    .sort((a, b) => b.depthM - a.depthM);

  return {
    plannedDepthM,
    plannedRuntimeMin,
    stops
  };
}

// iOS/Safari: ensure libraries are (re)loaded when returning via bfcache or reopening PWA
window.addEventListener("pageshow", function () {
  try {
    loadDiverLibrary();
    // Re-render after possible async IDB load
    setTimeout(function(){ try { renderPlongeursDuJourSelector(); } catch(_) {} }, 0);
  } catch (e) {}
});

window.addEventListener("pagehide", function () {
  try { saveDiverLibrary(); } catch(_) {}
});

</script>


<script>
/* === APTITUDE REF UNIQUE (ARCHITECTURE SAINE / NO REGRESSION) === */
const APTITUDE_REF = [
  { code:"BAPTEME", label:"BAPTÊME", aliases:["BAPTEME","BAPTÊME"] },
  { code:"PE6",label:"PE6",aliases:["PE6"] },
  { code:"PE12",label:"PE12",aliases:["PE12"] },
  { code:"PE20",label:"PE20",aliases:["PE20"] },
  { code:"PE40",label:"PE40",aliases:["PE40"] },
  { code:"PE60",label:"PE60",aliases:["PE60"] },
  { code:"PA12",label:"PA12",aliases:["PA12"] },
  { code:"PA20",label:"PA20",aliases:["PA20"] },
  { code:"PA40",label:"PA40",aliases:["PA40"] },
  { code:"PA60",label:"PA60",aliases:["PA60"] },
  { code:"PTH70",label:"PTH 70",aliases:["PTH70","PTH 70"] },
  { code:"PTH100",label:"PTH 100",aliases:["PTH100","PTH 100","PTH100m","PTH 100m"] },
  { code:"PTH120",label:"PTH 120",aliases:["PTH120","PTH 120"] },
  { code:"CCR40",label:"CCR 40",aliases:["CCR40","CCR 40"] },
  { code:"CCR60",label:"CCR 60",aliases:["CCR60","CCR 60"] },
  { code:"CCR70",label:"CCR 70",aliases:["CCR70","CCR 70"] },
  { code:"CCR100",label:"CCR 100",aliases:["CCR100","CCR 100"] },
  { code:"CCR120",label:"CCR 120",aliases:["CCR120","CCR 120"] },
  { code:"CCR150",label:"CCR 150",aliases:["CCR150","CCR 150"] },
  { code:"E1",label:"E1",aliases:["E1"] },
  { code:"E2",label:"E2",aliases:["E2"] },
  { code:"E3",label:"E3",aliases:["E3"] },
  { code:"E4",label:"E4",aliases:["E4"] },
  { code:"DP",label:"DP",aliases:["DP"] }
];

function canonApt(raw){
  const v=(raw||"").trim().toUpperCase();
  for(const it of APTITUDE_REF){
    if(it.aliases.map(a=>a.toUpperCase()).includes(v)) return it.code;
  }
  return raw||"";
}
function labelApt(raw){
  const c=canonApt(raw);
  const it=APTITUDE_REF.find(x=>x.code===c);
  return it?it.label:(raw||"");
}
function fillAptitudeSelect(selectId,current){
  const sel=document.getElementById(selectId);
  if(!sel) return;
  sel.innerHTML='<option value="">— Sélectionner —</option>';
  APTITUDE_REF.forEach(it=>{
    const o=document.createElement("option");
    o.value=it.code; o.textContent=it.label;
    sel.appendChild(o);
  });
  if(current){
    const c=canonApt(current);
    if(![...sel.options].some(o=>o.value===c)){
      const o=document.createElement("option");
      o.value=c; o.textContent=current+" (existant)";
      sel.insertBefore(o,sel.options[1]||null);
    }
    sel.value=c;
  }
  const o=document.createElement("option");
  o.value="Autre"; o.textContent="Autre (manuel)";
  sel.appendChild(o);
}

/* Override filtre aptitude pour être exhaustif */
if (typeof buildAptitudeFilterOptions === "function") {
  const _oldBuild = buildAptitudeFilterOptions;
}
function buildAptitudeFilterOptions(){
  const sel=document.getElementById("pdj_filter_apt");
  if(!sel) return;
  const prev=sel.value;
  sel.innerHTML='<option value="">Aptitude : toutes</option>';
  APTITUDE_REF.forEach(it=>{
    const o=document.createElement("option");
    o.value=it.code; o.textContent=it.label;
    sel.appendChild(o);
  });
  if(Array.isArray(window.diverLibrary)){
    const extras=[...new Set(diverLibrary.map(d=>d.aptitudes).filter(Boolean))];
    const ref=new Set(APTITUDE_REF.map(x=>x.code));
    const add=extras.filter(v=>!ref.has(canonApt(v)));
    if(add.length){
      const s=document.createElement("option");
      s.disabled=true; s.textContent="— existants (non référencés) —";
      sel.appendChild(s);
      add.forEach(v=>{
        const o=document.createElement("option");
        o.value=canonApt(v); o.textContent=labelApt(v);
        sel.appendChild(o);
      });
    }
  }
  if([...sel.options].some(o=>o.value===prev)) sel.value=prev;
}


// ===============================
// SPLASH logo plein écran (200ms)
// ===============================
function showAppSplash200ms(){
  const s = document.getElementById("app_splash");
  if (!s) return;

  // Avoid double-trigger (multiple DOMContentLoaded listeners / hot reload)
  if (showAppSplash200ms._done) return;
  showAppSplash200ms._done = true;

  s.classList.remove("hide");
  s.style.display = "flex";

  // CRITICAL: ensure at least one paint BEFORE starting the 200ms timer.
  // Otherwise, the timeout can expire before first render and you "never see" the splash.
  const raf = window.requestAnimationFrame || function(cb){ return setTimeout(cb, 16); };

  raf(()=>{
    raf(()=>{
      setTimeout(()=>{
        s.classList.add("hide");
        setTimeout(()=>{ s.style.display = "none"; }, 260);
      }, 300);
    });
  });
}


window.addEventListener("pageshow", (e)=>{
  // Safari bfcache: if page restored, ensure splash is hidden immediately
  if (e && e.persisted){
    const s = document.getElementById("app_splash");
    if (s){
      s.classList.add("hide");
      s.style.display = "none";
    }
  }
});

// =====================================================
// A1 QR = URL (caméra native iOS/Android) — Auto-import
// =====================================================
async function tryAutoImportFromHash() {
  try {
    const m = String(location.hash || "").match(/(?:^|[#&])import=([^&]+)/);
    if (!m) return;

    const id = decodeURIComponent(m[1] || "");
    if (!id) return;

    const r = await fetch(`/.netlify/functions/qr_get?id=${encodeURIComponent(id)}`, { method: "GET" });
    const j = await r.json().catch(()=>null);
    if (!j || !j.ok || !j.body) {
      alert("Import QR: échec (ID introuvable ou expiré).");
      return;
    }

    // Reuse existing business import (expects raw JSON string)
    importDiverFromQrText(j.body);

    // Clean URL to avoid re-import on refresh/back
    history.replaceState(null, "", location.pathname + location.search);
  } catch (e) {
    console.warn("tryAutoImportFromHash error:", e);
  }
}

async function gaUploadQrPageAndMakeUrl(pageObj) {
  const body = JSON.stringify(pageObj);
  const r = await fetch("/.netlify/functions/qr_put", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body
  });
  const j = await r.json().catch(()=>null);
  if (!j || !j.ok || !j.id) throw new Error((j && j.error) ? j.error : "qr_put failed");
  return `${location.origin}/#import=${encodeURIComponent(j.id)}`;
}



document.addEventListener("DOMContentLoaded", ()=> {
  // A1: Scanner QR web désactivé (QR = URL + caméra native)

  // =========================
  // Centre setup (UI wiring)
  // =========================
  const refreshCenterDisplay = () => {
    const el = document.getElementById("center_display");
    if (!el) return;
    const c = loadCenterCfg();
    el.textContent = (c && c.name) ? (c.name + (c.id ? (" — " + c.id) : "")) : "—";
  };

  const btnCfg = document.getElementById("btn_center_setup");
  if (btnCfg) btnCfg.addEventListener("click", () => { openCenterSetupModal(false); });

  const btnClose = document.getElementById("btnCenterSetupClose");
  if (btnClose) btnClose.addEventListener("click", () => { closeCenterSetupModal(); refreshCenterDisplay(); });

  const btnRegen = document.getElementById("btnCenterIdRegen");
  if (btnRegen) btnRegen.addEventListener("click", () => { openCenterSetupModal(true); });

  const btnSave = document.getElementById("btnCenterSetupSave");
  if (btnSave) btnSave.addEventListener("click", () => {
    const nameEl = document.getElementById("center_name_input");
    const boatsEl = document.getElementById("center_boats_input");
    const idEl = document.getElementById("center_id_input");

    const name = (nameEl && nameEl.value) ? String(nameEl.value).trim() : "";
    const boatsN = boatsEl && boatsEl.value ? Number(boatsEl.value) : 1;
    const id = (idEl && idEl.value) ? String(idEl.value).trim() : "";

    if (!name) { alert("Nom du centre requis."); return; }
    if (!id) { alert("ID centre manquant."); return; }

    saveCenterCfg({ name, id, boatsN });
    closeCenterSetupModal();
    refreshCenterDisplay();

    // Init app once center is configured
    if (!window.__dlog_inited) {
      window.__dlog_inited = true;
      try { if (typeof window.__doInit === "function") window.__doInit(); } catch(e) { console.warn("init", e); }
      // Auto-import if opened from QR URL
      try { tryAutoImportFromHash(); } catch(e) { console.warn("auto-import", e); }
    }
  });

  refreshCenterDisplay();

  // ============================================
  // Startup sequencing: Splash first, then setup
  // ============================================
  const runAfterSplash = () => {
    // HARD KILL splash overlay to avoid any iOS click-block (even if opacity=0)
    try {
      const __s = document.getElementById('app_splash');
      if (__s){
        __s.classList.add('hide');
        __s.style.pointerEvents = 'none';
        __s.style.display = 'none';
      }
    } catch(e) { console.warn('splash kill', e); }

    // Gate app init on center cfg
    if (!ensureCenterCfgOrPrompt()) {
      // init will be triggered after save
      return;
    }
    if (!window.__dlog_inited) {
      window.__dlog_inited = true;
      try { if (typeof window.__doInit === "function") window.__doInit(); } catch(e) { console.warn("init", e); }
      // Auto-import if opened from QR URL
      try { tryAutoImportFromHash(); } catch(e) { console.warn("auto-import", e); }
    }
  };

  // Splash hides after ~300ms + 260ms fade; wait a bit to avoid overlay conflicts
  setTimeout(runAfterSplash, 650);
});
</script>



<div class="numpad-overlay" id="numpad_overlay">
  <div class="numpad" role="dialog" aria-modal="true">
    <div class="numpad-grid" id="numpad_grid"></div>
    <div class="numpad-actions">
      <button type="button" class="numpad-btn wide" id="numpad_back">⌫</button>
      <button type="button" class="numpad-btn wide" id="numpad_clear">C</button>
      <button type="button" class="numpad-btn wide" id="numpad_ok">OK</button>
    </div>
  </div>
</div>


<!-- =======================
     A1 REFONTE – ÉCRAN SCANNER QR (plein écran)
     ======================= -->
<div id="qr_scanner_screen" aria-hidden="true">
  <div class="qrss-card" role="dialog" aria-modal="true" aria-label="Scanner QR">
    <div class="qrss-header">
      <div class="qrss-title">Scanner QR</div>
      <button type="button" class="qrss-close" id="qrss_btn_close">✕ Fermer</button>
    </div>

    <div class="qrss-body">
      <div class="qrss-status" id="qrss_status">Prêt. Choisis Caméra ou Photo.</div>
      <div class="qrss-debug" id="qrss_debug" style="font-size:12px;opacity:.75;margin:6px 0 0 0;"></div>

      <div class="qrss-videoWrap" id="qrss_video_wrap" style="display:none;">
        <video id="qrss_video" playsinline muted></video>
      </div>

      <div class="qrss-actions">
        <button type="button" class="primary" id="qrss_btn_camera">📷 Caméra</button>
        <button type="button" class="secondary" id="qrss_btn_photo">🖼 Photo</button>
        <button type="button" class="secondary" id="qrss_btn_snap" style="display:none;">🔍 Analyser frame</button>
      </div>

      <div class="qrss-footnote">
        Import automatique dès détection. Sur iPhone, ouvre le lien dans Safari.
      </div>

      <input type="file" id="qrss_file" accept="image/*" style="display:none;">
    </div>
  </div>
</div>


</body>
</html>


